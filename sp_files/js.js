/*! Dust - Asynchronous Templating - v2.2.3
 * http://linkedin.github.io/dustjs/
 * Copyright (c) 2013 Aleksander Williams; Released under the MIT License */
/*jshint evil:true*/
var dust = {};

function getGlobal(){
    return (function(){
        return this.dust;
    }).call(null);
}

(function(dust) {

    if(!dust) {
        return;
    }
    var ERROR = 'ERROR',
        WARN = 'WARN',
        INFO = 'INFO',
        DEBUG = 'DEBUG',
        levels = [DEBUG, INFO, WARN, ERROR],
        EMPTY_FUNC = function() {},
        logger = EMPTY_FUNC;

    dust.isDebug = false;
    dust.debugLevel = INFO;

    // Try to find the console logger in window scope (browsers) or top level scope (node.js)
    if (typeof window !== 'undefined' && window && window.console && window.console.log) {
        logger = window.console.log;
    } else if (typeof console !== 'undefined' && console && console.log) {
        logger = console.log;
    }

    /**
     * If dust.isDebug is true, Log dust debug statements, info statements, warning statements, and errors.
     * This default implementation will print to the console if it exists.
     * @param {String} message the message to print
     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)
     * @public
     */
    dust.log = function(message, type) {
        type = type || INFO;
        if(dust.isDebug && levels.indexOf(type) >= levels.indexOf(dust.debugLevel)) {
            if(!dust.logQueue) {
                dust.logQueue = [];
            }
            dust.logQueue.push({message: message, type: type});
            logger.call(console || window.console, '[DUST ' + type + ']: ' + message);
        }
    };

    /**
     * If debugging is turned on(dust.isDebug=true) log the error message and throw it.
     * Otherwise try to keep rendering.  This is useful to fail hard in dev mode, but keep rendering in production.
     * @param {Error} error the error message to throw
     * @param {Object} chunk the chunk the error was thrown from
     * @public
     */
    dust.onError = function(error, chunk) {
        dust.log(error.message || error, ERROR);
        if(dust.isDebug) {
            throw error;
        } else {
            return chunk;
        }
    };

    dust.helpers = {};

    dust.cache = {};

    dust.register = function(name, tmpl) {
        if (!name) {
            return;
        }
        dust.cache[name] = tmpl;
    };

    dust.render = function(name, context, callback) {
        var chunk = new Stub(callback).head;
        try {
            dust.load(name, chunk, Context.wrap(context, name)).end();
        } catch (err) {
            dust.onError(err, chunk);
        }
    };

    dust.stream = function(name, context) {
        var stream = new Stream();
        dust.nextTick(function() {
            try {
                dust.load(name, stream.head, Context.wrap(context, name)).end();
            } catch (err) {
                dust.onError(err, stream.head);
            }
        });
        return stream;
    };

    dust.renderSource = function(source, context, callback) {
        return dust.compileFn(source)(context, callback);
    };

    dust.compileFn = function(source, name) {
        var tmpl = dust.loadSource(dust.compile(source, name));
        return function(context, callback) {
            var master = callback ? new Stub(callback) : new Stream();
            dust.nextTick(function() {
                if(typeof tmpl === 'function') {
                    tmpl(master.head, Context.wrap(context, name)).end();
                }
                else {
                    dust.onError(new Error('Template [' + name + '] cannot be resolved to a Dust function'));
                }
            });
            return master;
        };
    };

    dust.load = function(name, chunk, context) {
        var tmpl = dust.cache[name];
        if (tmpl) {
            return tmpl(chunk, context);
        } else {
            if (dust.onLoad) {
                return chunk.map(function(chunk) {
                    dust.onLoad(name, function(err, src) {
                        if (err) {
                            return chunk.setError(err);
                        }
                        if (!dust.cache[name]) {
                            dust.loadSource(dust.compile(src, name));
                        }
                        dust.cache[name](chunk, context).end();
                    });
                });
            }
            return chunk.setError(new Error('Template Not Found: ' + name));
        }
    };

    dust.loadSource = function(source, path) {
        return eval(source);
    };

    if (Array.isArray) {
        dust.isArray = Array.isArray;
    } else {
        dust.isArray = function(arr) {
            return Object.prototype.toString.call(arr) === '[object Array]';
        };
    }

    dust.nextTick = (function() {
        if (typeof process !== 'undefined') {
            return process.nextTick;
        } else {
            return function(callback) {
                setTimeout(callback,0);
            };
        }
    } )();

    dust.isEmpty = function(value) {
        if (dust.isArray(value) && !value.length) {
            return true;
        }
        if (value === 0) {
            return false;
        }
        return (!value);
    };

    // apply the filter chain and return the output string
    dust.filter = function(string, auto, filters) {
        if (filters) {
            for (var i=0, len=filters.length; i<len; i++) {
                var name = filters[i];
                if (name === 's') {
                    auto = null;
                    dust.log('Using unescape filter on [' + string + ']', DEBUG);
                }
                else if (typeof dust.filters[name] === 'function') {
                    string = dust.filters[name](string);
                }
                else {
                    dust.onError(new Error('Invalid filter [' + name + ']'));
                }
            }
        }
        // by default always apply the h filter, unless asked to unescape with |s
        if (auto) {
            string = dust.filters[auto](string);
        }
        return string;
    };

    dust.filters = {
        h: function(value) { return dust.escapeHtml(value); },
        j: function(value) { return dust.escapeJs(value); },
        u: encodeURI,
        uc: encodeURIComponent,
        js: function(value) {
            if (!JSON) {
                dust.log('JSON is undefined.  JSON stringify has not been used on [' + value + ']', WARN);
                return value;
            } else {
                return JSON.stringify(value);
            }
        },
        jp: function(value) {
            if (!JSON) {dust.log('JSON is undefined.  JSON parse has not been used on [' + value + ']', WARN);
                return value;
            } else {
                return JSON.parse(value);
            }
        }
    };

    function Context(stack, global, blocks, templateName) {
        this.stack  = stack;
        this.global = global;
        this.blocks = blocks;
        this.templateName = templateName;
    }

    dust.makeBase = function(global) {
        return new Context(new Stack(), global);
    };

    Context.wrap = function(context, name) {
        if (context instanceof Context) {
            return context;
        }
        return new Context(new Stack(context), {}, null, name);
    };

    /**
     * Public API for getting a value from the context.
     * @method get
     * @param {string|array} path The path to the value. Supported formats are:
     * 'key'
     * 'path.to.key'
     * '.path.to.key'
     * ['path', 'to', 'key']
     * ['key']
     * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the
     * current context (true), or if get should search in parent contexts as well (false).
     * @public
     * @returns {string|object}
     */
    Context.prototype.get = function(path, cur) {
        if (typeof path === 'string') {
            if (path[0] === '.') {
                cur = true;
                path = path.substr(1);
            }
            path = path.split('.');
        }
        return this._get(cur, path);
    };

    /**
     * Get a value from the context
     * @method _get
     * @param {boolean} cur Get only from the current context
     * @param {array} down An array of each step in the path
     * @private
     * @return {string | object}
     */
    Context.prototype._get = function(cur, down) {
        var ctx = this.stack,
            i = 1,
            value, first, len, ctxThis;
        dust.log('Searching for reference [{' + down.join('.') + '}] in template [' + this.getTemplateName() + ']', DEBUG);
        first = down[0];
        len = down.length;

        if (cur && len === 0) {
            ctxThis = ctx;
            ctx = ctx.head;
        } else {
            if (!cur) {
                // Search up the stack for the first value
                while (ctx) {
                    if (ctx.isObject) {
                        ctxThis = ctx.head;
                        value = ctx.head[first];
                        if (value !== undefined) {
                            break;
                        }
                    }
                    ctx = ctx.tail;
                }

                if (value !== undefined) {
                    ctx = value;
                } else {
                    ctx = this.global ? this.global[first] : undefined;
                }
            } else {
                // if scope is limited by a leading dot, don't search up the tree
                ctx = ctx.head[first];
            }

            while (ctx && i < len) {
                ctxThis = ctx;
                ctx = ctx[down[i]];
                i++;
            }
        }

        // Return the ctx or a function wrapping the application of the context.
        if (typeof ctx === 'function') {
            var fn = function() {
                return ctx.apply(ctxThis, arguments);
            };
            fn.isFunction = true;
            return fn;
        } else {
            if (ctx === undefined) {
                dust.log('Cannot find the value for reference [{' + down.join('.') + '}] in template [' + this.getTemplateName() + ']');
            }
            return ctx;
        }
    };

    Context.prototype.getPath = function(cur, down) {
        return this._get(cur, down);
    };

    Context.prototype.push = function(head, idx, len) {
        return new Context(new Stack(head, this.stack, idx, len), this.global, this.blocks, this.getTemplateName());
    };

    Context.prototype.rebase = function(head) {
        return new Context(new Stack(head), this.global, this.blocks, this.getTemplateName());
    };

    Context.prototype.current = function() {
        return this.stack.head;
    };

    Context.prototype.getBlock = function(key, chk, ctx) {
        if (typeof key === 'function') {
            var tempChk = new Chunk();
            key = key(tempChk, this).data.join('');
        }

        var blocks = this.blocks;

        if (!blocks) {
            dust.log('No blocks for context[{' + key + '}] in template [' + this.getTemplateName() + ']', DEBUG);
            return;
        }
        var len = blocks.length, fn;
        while (len--) {
            fn = blocks[len][key];
            if (fn) {
                return fn;
            }
        }
    };

    Context.prototype.shiftBlocks = function(locals) {
        var blocks = this.blocks,
            newBlocks;

        if (locals) {
            if (!blocks) {
                newBlocks = [locals];
            } else {
                newBlocks = blocks.concat([locals]);
            }
            return new Context(this.stack, this.global, newBlocks, this.getTemplateName());
        }
        return this;
    };

    Context.prototype.getTemplateName = function() {
        return this.templateName;
    };

    function Stack(head, tail, idx, len) {
        this.tail = tail;
        this.isObject = head && typeof head === 'object';
        this.head = head;
        this.index = idx;
        this.of = len;
    }

    function Stub(callback) {
        this.head = new Chunk(this);
        this.callback = callback;
        this.out = '';
    }

    Stub.prototype.flush = function() {
        var chunk = this.head;

        while (chunk) {
            if (chunk.flushable) {
                this.out += chunk.data.join(''); //ie7 perf
            } else if (chunk.error) {
                this.callback(chunk.error);
                dust.onError(new Error('Chunk error [' + chunk.error + '] thrown. Ceasing to render this template.'));
                this.flush = EMPTY_FUNC;
                return;
            } else {
                return;
            }
            chunk = chunk.next;
            this.head = chunk;
        }
        this.callback(null, this.out);
    };

    function Stream() {
        this.head = new Chunk(this);
    }

    Stream.prototype.flush = function() {
        var chunk = this.head;

        while(chunk) {
            if (chunk.flushable) {
                this.emit('data', chunk.data.join('')); //ie7 perf
            } else if (chunk.error) {
                this.emit('error', chunk.error);
                dust.onError(new Error('Chunk error [' + chunk.error + '] thrown. Ceasing to render this template.'));
                this.flush = EMPTY_FUNC;
                return;
            } else {
                return;
            }
            chunk = chunk.next;
            this.head = chunk;
        }
        this.emit('end');
    };

    Stream.prototype.emit = function(type, data) {
        if (!this.events) {
            dust.log('No events to emit', INFO);
            return false;
        }
        var handler = this.events[type];
        if (!handler) {
            dust.log('Event type [' + type + '] does not exist', WARN);
            return false;
        }
        if (typeof handler === 'function') {
            handler(data);
        } else if (dust.isArray(handler)) {
            var listeners = handler.slice(0);
            for (var i = 0, l = listeners.length; i < l; i++) {
                listeners[i](data);
            }
        } else {
            dust.onError(new Error('Event Handler [' + handler + '] is not of a type that is handled by emit'));
        }
    };

    Stream.prototype.on = function(type, callback) {
        if (!this.events) {
            this.events = {};
        }
        if (!this.events[type]) {
            dust.log('Event type [' + type + '] does not exist. Using just the specified callback.', WARN);
            if(callback) {
                this.events[type] = callback;
            } else {
                dust.log('Callback for type [' + type + '] does not exist. Listener not registered.', WARN);
            }
        } else if(typeof this.events[type] === 'function') {
            this.events[type] = [this.events[type], callback];
        } else {
            this.events[type].push(callback);
        }
        return this;
    };

    Stream.prototype.pipe = function(stream) {
        this.on('data', function(data) {
            try {
                stream.write(data, 'utf8');
            } catch (err) {
                dust.onError(err, stream.head);
            }
        }).on('end', function() {
                try {
                    return stream.end();
                } catch (err) {
                    dust.onError(err, stream.head);
                }
            }).on('error', function(err) {
                stream.error(err);
            });
        return this;
    };

    function Chunk(root, next, taps) {
        this.root = root;
        this.next = next;
        this.data = []; //ie7 perf
        this.flushable = false;
        this.taps = taps;
    }

    Chunk.prototype.write = function(data) {
        var taps  = this.taps;

        if (taps) {
            data = taps.go(data);
        }
        this.data.push(data);
        return this;
    };

    Chunk.prototype.end = function(data) {
        if (data) {
            this.write(data);
        }
        this.flushable = true;
        this.root.flush();
        return this;
    };

    Chunk.prototype.map = function(callback) {
        var cursor = new Chunk(this.root, this.next, this.taps),
            branch = new Chunk(this.root, cursor, this.taps);

        this.next = branch;
        this.flushable = true;
        callback(branch);
        return cursor;
    };

    Chunk.prototype.tap = function(tap) {
        var taps = this.taps;

        if (taps) {
            this.taps = taps.push(tap);
        } else {
            this.taps = new Tap(tap);
        }
        return this;
    };

    Chunk.prototype.untap = function() {
        this.taps = this.taps.tail;
        return this;
    };

    Chunk.prototype.render = function(body, context) {
        return body(this, context);
    };

    Chunk.prototype.reference = function(elem, context, auto, filters) {
        if (typeof elem === 'function') {
            elem.isFunction = true;
            // Changed the function calling to use apply with the current context to make sure
            // that "this" is wat we expect it to be inside the function
            elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);
            if (elem instanceof Chunk) {
                return elem;
            }
        }
        if (!dust.isEmpty(elem)) {
            return this.write(dust.filter(elem, auto, filters));
        } else {
            return this;
        }
    };

    Chunk.prototype.section = function(elem, context, bodies, params) {
        // anonymous functions
        if (typeof elem === 'function') {
            elem = elem.apply(context.current(), [this, context, bodies, params]);
            // functions that return chunks are assumed to have handled the body and/or have modified the chunk
            // use that return value as the current chunk and go to the next method in the chain
            if (elem instanceof Chunk) {
                return elem;
            }
        }
        var body = bodies.block,
            skip = bodies['else'];

        // a.k.a Inline parameters in the Dust documentations
        if (params) {
            context = context.push(params);
        }

        /*
         Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.
         When elem resolves to a value or object instead of an array, Dust sets the current context to the value
         and renders the block one time.
         */
        //non empty array is truthy, empty array is falsy
        if (dust.isArray(elem)) {
            if (body) {
                var len = elem.length, chunk = this;
                if (len > 0) {
                    // any custom helper can blow up the stack
                    // and store a flattened context, guard defensively
                    if(context.stack.head) {
                        context.stack.head['$len'] = len;
                    }
                    for (var i=0; i<len; i++) {
                        if(context.stack.head) {
                            context.stack.head['$idx'] = i;
                        }
                        chunk = body(chunk, context.push(elem[i], i, len));
                    }
                    if(context.stack.head) {
                        context.stack.head['$idx'] = undefined;
                        context.stack.head['$len'] = undefined;
                    }
                    return chunk;
                }
                else if (skip) {
                    return skip(this, context);
                }
            }
        } else if (elem  === true) {
            // true is truthy but does not change context
            if (body) {
                return body(this, context);
            }
        } else if (elem || elem === 0) {
            // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )
            // zero is truthy
            // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value
            if (body) {
                return body(this, context.push(elem));
            }
            // nonexistent, scalar false value, scalar empty string, null,
            // undefined are all falsy
        } else if (skip) {
            return skip(this, context);
        }
        dust.log('Not rendering section (#) block in template [' + context.getTemplateName() + '], because above key was not found', DEBUG);
        return this;
    };

    Chunk.prototype.exists = function(elem, context, bodies) {
        var body = bodies.block,
            skip = bodies['else'];

        if (!dust.isEmpty(elem)) {
            if (body) {
                return body(this, context);
            }
        } else if (skip) {
            return skip(this, context);
        }
        dust.log('Not rendering exists (?) block in template [' + context.getTemplateName() + '], because above key was not found', DEBUG);
        return this;
    };

    Chunk.prototype.notexists = function(elem, context, bodies) {
        var body = bodies.block,
            skip = bodies['else'];

        if (dust.isEmpty(elem)) {
            if (body) {
                return body(this, context);
            }
        } else if (skip) {
            return skip(this, context);
        }
        dust.log('Not rendering not exists (^) block check in template [' + context.getTemplateName() + '], because above key was found', DEBUG);
        return this;
    };

    Chunk.prototype.block = function(elem, context, bodies) {
        var body = bodies.block;

        if (elem) {
            body = elem;
        }

        if (body) {
            return body(this, context);
        }
        return this;
    };

    Chunk.prototype.partial = function(elem, context, params) {
        var partialContext;
        //put the params context second to match what section does. {.} matches the current context without parameters
        // start with an empty context
        partialContext = dust.makeBase(context.global);
        partialContext.blocks = context.blocks;
        if (context.stack && context.stack.tail){
            // grab the stack(tail) off of the previous context if we have it
            partialContext.stack = context.stack.tail;
        }
        if (params){
            //put params on
            partialContext = partialContext.push(params);
        }

        if(typeof elem === 'string') {
            partialContext.templateName = elem;
        }

        //reattach the head
        partialContext = partialContext.push(context.stack.head);

        var partialChunk;
        if (typeof elem === 'function') {
            partialChunk = this.capture(elem, partialContext, function(name, chunk) {
                partialContext.templateName = partialContext.templateName || name;
                dust.load(name, chunk, partialContext).end();
            });
        } else {
            partialChunk = dust.load(elem, this, partialContext);
        }
        return partialChunk;
    };

    Chunk.prototype.helper = function(name, context, bodies, params) {
        var chunk = this;
        // handle invalid helpers, similar to invalid filters
        try {
            if(dust.helpers[name]) {
                return dust.helpers[name](chunk, context, bodies, params);
            } else {
                return dust.onError(new Error('Invalid helper [' + name + ']'), chunk);
            }
        } catch (err) {
            return dust.onError(err, chunk);
        }
    };

    Chunk.prototype.capture = function(body, context, callback) {
        return this.map(function(chunk) {
            var stub = new Stub(function(err, out) {
                if (err) {
                    chunk.setError(err);
                } else {
                    callback(out, chunk);
                }
            });
            body(stub.head, context).end();
        });
    };

    Chunk.prototype.setError = function(err) {
        this.error = err;
        this.root.flush();
        return this;
    };

    function Tap(head, tail) {
        this.head = head;
        this.tail = tail;
    }

    Tap.prototype.push = function(tap) {
        return new Tap(tap, this);
    };

    Tap.prototype.go = function(value) {
        var tap = this;

        while(tap) {
            value = tap.head(value);
            tap = tap.tail;
        }
        return value;
    };

    var HCHARS = new RegExp(/[&<>\"\']/),
        AMP    = /&/g,
        LT     = /</g,
        GT     = />/g,
        QUOT   = /\"/g,
        SQUOT  = /\'/g;

    dust.escapeHtml = function(s) {
        if (typeof s === 'string') {
            if (!HCHARS.test(s)) {
                return s;
            }
            return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');
        }
        return s;
    };

    var BS = /\\/g,
        FS = /\//g,
        CR = /\r/g,
        LS = /\u2028/g,
        PS = /\u2029/g,
        NL = /\n/g,
        LF = /\f/g,
        SQ = /'/g,
        DQ = /"/g,
        TB = /\t/g;

    dust.escapeJs = function(s) {
        if (typeof s === 'string') {
            return s
                .replace(BS, '\\\\')
                .replace(FS, '\\/')
                .replace(DQ, '\\"')
                .replace(SQ, '\\\'')
                .replace(CR, '\\r')
                .replace(LS, '\\u2028')
                .replace(PS, '\\u2029')
                .replace(NL, '\\n')
                .replace(LF, '\\f')
                .replace(TB, '\\t');
        }
        return s;
    };

})(dust);

if (typeof exports !== 'undefined') {
    if (typeof process !== 'undefined') {
        require('./server')(dust);
    }
    module.exports = dust;
}

/*jshint latedef:false */
var dustCompiler = function(dust) {

    dust.compile = function(source, name) {
        try {
            var ast = filterAST(dust.parse(source));
            return compile(ast, name);
        }
        catch (err)
        {
            if (!err.line || !err.column) {
                throw err;
            }
            throw new SyntaxError(err.message + ' At line : ' + err.line + ', column : ' + err.column);
        }
    };

    function filterAST(ast) {
        var context = {};
        return dust.filterNode(context, ast);
    }

    dust.filterNode = function(context, node) {
        return dust.optimizers[node[0]](context, node);
    };

    dust.optimizers = {
        body:      compactBuffers,
        buffer:    noop,
        special:   convertSpecial,
        format:    nullify,        // TODO: convert format
        reference: visit,
        '#':       visit,
        '?':       visit,
        '^':       visit,
        '<':       visit,
        '+':       visit,
        '@':       visit,
        '%':       visit,
        partial:   visit,
        context:   visit,
        params:    visit,
        bodies:    visit,
        param:     visit,
        filters:   noop,
        key:       noop,
        path:      noop,
        literal:   noop,
        comment:   nullify,
        line:      nullify,
        col:       nullify
    };

    dust.pragmas = {
        esc: function(compiler, context, bodies, params) {
            var old = compiler.auto,
                out;
            if (!context) {
                context = 'h';
            }
            compiler.auto = (context === 's') ? '' : context;
            out = compileParts(compiler, bodies.block);
            compiler.auto = old;
            return out;
        }
    };

    function visit(context, node) {
        var out = [node[0]],
            i, len, res;
        for (i=1, len=node.length; i<len; i++) {
            res = dust.filterNode(context, node[i]);
            if (res) {
                out.push(res);
            }
        }
        return out;
    }

// Compacts consecutive buffer nodes into a single node
    function compactBuffers(context, node) {
        var out = [node[0]],
            memo, i, len, res;
        for (i=1, len=node.length; i<len; i++) {
            res = dust.filterNode(context, node[i]);
            if (res) {
                if (res[0] === 'buffer') {
                    if (memo) {
                        memo[1] += res[1];
                    } else {
                        memo = res;
                        out.push(res);
                    }
                } else {
                    memo = null;
                    out.push(res);
                }
            }
        }
        return out;
    }

    var specialChars = {
        's': ' ',
        'n': '\n',
        'r': '\r',
        'lb': '{',
        'rb': '}'
    };

    function convertSpecial(context, node) {
        return ['buffer', specialChars[node[1]]];
    }

    function noop(context, node) {
        return node;
    }

    function nullify(){}

    function compile(ast, name) {
        var context = {
            name: name,
            bodies: [],
            blocks: {},
            index: 0,
            auto: 'h'
        };

        return '(function(){dust.register(' +
            (name ? '"' + name + '"' : 'null') + ',' +
            dust.compileNode(context, ast) +
            ');' +
            compileBlocks(context) +
            compileBodies(context) +
            'return body_0;' +
            '})();';
    }

    function compileBlocks(context) {
        var out = [],
            blocks = context.blocks,
            name;

        for (name in blocks) {
            out.push('"' + name + '":' + blocks[name]);
        }
        if (out.length) {
            context.blocks = 'ctx=ctx.shiftBlocks(blocks);';
            return 'var blocks={' + out.join(',') + '};';
        }
        return context.blocks = '';
    }

    function compileBodies(context) {
        var out = [],
            bodies = context.bodies,
            blx = context.blocks,
            i, len;

        for (i=0, len=bodies.length; i<len; i++) {
            out[i] = 'function body_' + i + '(chk,ctx){' +
                blx + 'return chk' + bodies[i] + ';}';
        }
        return out.join('');
    }

    function compileParts(context, body) {
        var parts = '',
            i, len;
        for (i=1, len=body.length; i<len; i++) {
            parts += dust.compileNode(context, body[i]);
        }
        return parts;
    }

    dust.compileNode = function(context, node) {
        return dust.nodes[node[0]](context, node);
    };

    dust.nodes = {
        body: function(context, node) {
            var id = context.index++,
                name = 'body_' + id;
            context.bodies[id] = compileParts(context, node);
            return name;
        },

        buffer: function(context, node) {
            return '.write(' + escape(node[1]) + ')';
        },

        format: function(context, node) {
            return '.write(' + escape(node[1] + node[2]) + ')';
        },

        reference: function(context, node) {
            return '.reference(' + dust.compileNode(context, node[1]) +
                ',ctx,' + dust.compileNode(context, node[2]) + ')';
        },

        '#': function(context, node) {
            return compileSection(context, node, 'section');
        },

        '?': function(context, node) {
            return compileSection(context, node, 'exists');
        },

        '^': function(context, node) {
            return compileSection(context, node, 'notexists');
        },

        '<': function(context, node) {
            var bodies = node[4];
            for (var i=1, len=bodies.length; i<len; i++) {
                var param = bodies[i],
                    type = param[1][1];
                if (type === 'block') {
                    context.blocks[node[1].text] = dust.compileNode(context, param[2]);
                    return '';
                }
            }
            return '';
        },

        '+': function(context, node) {
            if (typeof(node[1].text) === 'undefined'  && typeof(node[4]) === 'undefined'){
                return '.block(ctx.getBlock(' +
                    dust.compileNode(context, node[1]) +
                    ',chk, ctx),' + dust.compileNode(context, node[2]) + ', {},' +
                    dust.compileNode(context, node[3]) +
                    ')';
            } else {
                return '.block(ctx.getBlock(' +
                    escape(node[1].text) +
                    '),' + dust.compileNode(context, node[2]) + ',' +
                    dust.compileNode(context, node[4]) + ',' +
                    dust.compileNode(context, node[3]) +
                    ')';
            }
        },

        '@': function(context, node) {
            return '.helper(' +
                escape(node[1].text) +
                ',' + dust.compileNode(context, node[2]) + ',' +
                dust.compileNode(context, node[4]) + ',' +
                dust.compileNode(context, node[3]) +
                ')';
        },

        '%': function(context, node) {
            // TODO: Move these hacks into pragma precompiler
            var name = node[1][1],
                rawBodies,
                bodies,
                rawParams,
                params,
                ctx, b, p, i, len;
            if (!dust.pragmas[name]) {
                return '';
            }

            rawBodies = node[4];
            bodies = {};
            for (i=1, len=rawBodies.length; i<len; i++) {
                b = rawBodies[i];
                bodies[b[1][1]] = b[2];
            }

            rawParams = node[3];
            params = {};
            for (i=1, len=rawParams.length; i<len; i++) {
                p = rawParams[i];
                params[p[1][1]] = p[2][1];
            }

            ctx = node[2][1] ? node[2][1].text : null;

            return dust.pragmas[name](context, ctx, bodies, params);
        },

        partial: function(context, node) {
            return '.partial(' +
                dust.compileNode(context, node[1]) +
                ',' + dust.compileNode(context, node[2]) +
                ',' + dust.compileNode(context, node[3]) + ')';
        },

        context: function(context, node) {
            if (node[1]) {
                return 'ctx.rebase(' + dust.compileNode(context, node[1]) + ')';
            }
            return 'ctx';
        },

        params: function(context, node) {
            var out = [];
            for (var i=1, len=node.length; i<len; i++) {
                out.push(dust.compileNode(context, node[i]));
            }
            if (out.length) {
                return '{' + out.join(',') + '}';
            }
            return 'null';
        },

        bodies: function(context, node) {
            var out = [];
            for (var i=1, len=node.length; i<len; i++) {
                out.push(dust.compileNode(context, node[i]));
            }
            return '{' + out.join(',') + '}';
        },

        param: function(context, node) {
            return dust.compileNode(context, node[1]) + ':' + dust.compileNode(context, node[2]);
        },

        filters: function(context, node) {
            var list = [];
            for (var i=1, len=node.length; i<len; i++) {
                var filter = node[i];
                list.push('"' + filter + '"');
            }
            return '"' + context.auto + '"' +
                (list.length ? ',[' + list.join(',') + ']' : '');
        },

        key: function(context, node) {
            return 'ctx._get(false, ["' + node[1] + '"])';
        },

        path: function(context, node) {
            var current = node[1],
                keys = node[2],
                list = [];

            for (var i=0,len=keys.length; i<len; i++) {
                if (dust.isArray(keys[i])) {
                    list.push(dust.compileNode(context, keys[i]));
                } else {
                    list.push('"' + keys[i] + '"');
                }
            }
            return 'ctx._get(' + current + ',[' + list.join(',') + '])';
        },

        literal: function(context, node) {
            return escape(node[1]);
        }
    };

    function compileSection(context, node, cmd) {
        return '.' + cmd + '(' +
            dust.compileNode(context, node[1]) +
            ',' + dust.compileNode(context, node[2]) + ',' +
            dust.compileNode(context, node[4]) + ',' +
            dust.compileNode(context, node[3]) +
            ')';
    }

    var escape = (typeof JSON === 'undefined') ?
        function(str) { return '"' + dust.escapeJs(str) + '"';} :
        JSON.stringify;

    return dust;

};

if (typeof exports !== 'undefined') {
    module.exports = dustCompiler;
} else {
    dustCompiler(getGlobal());
}

(function(dust){

    var parser = (function(){
        /*
         * Generated by PEG.js 0.7.0.
         *
         * http://pegjs.majda.cz/
         */

        function quote(s) {
            /*
             * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
             * string literal except for the closing quote character, backslash,
             * carriage return, line separator, paragraph separator, and line feed.
             * Any character may appear in the form of an escape sequence.
             *
             * For portability, we also escape escape all control and non-ASCII
             * characters. Note that "\0" and "\v" escape sequences are not used
             * because JSHint does not like the first and IE the second.
             */
            return '"' + s
                .replace(/\\/g, '\\\\')  // backslash
                .replace(/"/g, '\\"')    // closing quote character
                .replace(/\x08/g, '\\b') // backspace
                .replace(/\t/g, '\\t')   // horizontal tab
                .replace(/\n/g, '\\n')   // line feed
                .replace(/\f/g, '\\f')   // form feed
                .replace(/\r/g, '\\r')   // carriage return
                .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
                + '"';
        }

        var result = {
            /*
             * Parses the input with a generated parser. If the parsing is successfull,
             * returns a value explicitly or implicitly specified by the grammar from
             * which the parser was generated (see |PEG.buildParser|). If the parsing is
             * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
             */
            parse: function(input, startRule) {
                var parseFunctions = {
                    "body": parse_body,
                    "part": parse_part,
                    "section": parse_section,
                    "sec_tag_start": parse_sec_tag_start,
                    "end_tag": parse_end_tag,
                    "context": parse_context,
                    "params": parse_params,
                    "bodies": parse_bodies,
                    "reference": parse_reference,
                    "partial": parse_partial,
                    "filters": parse_filters,
                    "special": parse_special,
                    "identifier": parse_identifier,
                    "number": parse_number,
                    "float": parse_float,
                    "integer": parse_integer,
                    "path": parse_path,
                    "key": parse_key,
                    "array": parse_array,
                    "array_part": parse_array_part,
                    "inline": parse_inline,
                    "inline_part": parse_inline_part,
                    "buffer": parse_buffer,
                    "literal": parse_literal,
                    "esc": parse_esc,
                    "comment": parse_comment,
                    "tag": parse_tag,
                    "ld": parse_ld,
                    "rd": parse_rd,
                    "lb": parse_lb,
                    "rb": parse_rb,
                    "eol": parse_eol,
                    "ws": parse_ws
                };

                if (startRule !== undefined) {
                    if (parseFunctions[startRule] === undefined) {
                        throw new Error("Invalid rule name: " + quote(startRule) + ".");
                    }
                } else {
                    startRule = "body";
                }

                var pos = { offset: 0, line: 1, column: 1, seenCR: false };
                var reportFailures = 0;
                var rightmostFailuresPos = { offset: 0, line: 1, column: 1, seenCR: false };
                var rightmostFailuresExpected = [];

                function padLeft(input, padding, length) {
                    var result = input;

                    var padLength = length - input.length;
                    for (var i = 0; i < padLength; i++) {
                        result = padding + result;
                    }

                    return result;
                }

                function escape(ch) {
                    var charCode = ch.charCodeAt(0);
                    var escapeChar;
                    var length;

                    if (charCode <= 0xFF) {
                        escapeChar = 'x';
                        length = 2;
                    } else {
                        escapeChar = 'u';
                        length = 4;
                    }

                    return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
                }

                function clone(object) {
                    var result = {};
                    for (var key in object) {
                        result[key] = object[key];
                    }
                    return result;
                }

                function advance(pos, n) {
                    var endOffset = pos.offset + n;

                    for (var offset = pos.offset; offset < endOffset; offset++) {
                        var ch = input.charAt(offset);
                        if (ch === "\n") {
                            if (!pos.seenCR) { pos.line++; }
                            pos.column = 1;
                            pos.seenCR = false;
                        } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                            pos.line++;
                            pos.column = 1;
                            pos.seenCR = true;
                        } else {
                            pos.column++;
                            pos.seenCR = false;
                        }
                    }

                    pos.offset += n;
                }

                function matchFailed(failure) {
                    if (pos.offset < rightmostFailuresPos.offset) {
                        return;
                    }

                    if (pos.offset > rightmostFailuresPos.offset) {
                        rightmostFailuresPos = clone(pos);
                        rightmostFailuresExpected = [];
                    }

                    rightmostFailuresExpected.push(failure);
                }

                function parse_body() {
                    var result0, result1;
                    var pos0;

                    pos0 = clone(pos);
                    result0 = [];
                    result1 = parse_part();
                    while (result1 !== null) {
                        result0.push(result1);
                        result1 = parse_part();
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, p) { return ["body"].concat(p).concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    return result0;
                }

                function parse_part() {
                    var result0;

                    result0 = parse_comment();
                    if (result0 === null) {
                        result0 = parse_section();
                        if (result0 === null) {
                            result0 = parse_partial();
                            if (result0 === null) {
                                result0 = parse_special();
                                if (result0 === null) {
                                    result0 = parse_reference();
                                    if (result0 === null) {
                                        result0 = parse_buffer();
                                    }
                                }
                            }
                        }
                    }
                    return result0;
                }

                function parse_section() {
                    var result0, result1, result2, result3, result4, result5, result6;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_sec_tag_start();
                    if (result0 !== null) {
                        result1 = [];
                        result2 = parse_ws();
                        while (result2 !== null) {
                            result1.push(result2);
                            result2 = parse_ws();
                        }
                        if (result1 !== null) {
                            result2 = parse_rd();
                            if (result2 !== null) {
                                result3 = parse_body();
                                if (result3 !== null) {
                                    result4 = parse_bodies();
                                    if (result4 !== null) {
                                        result5 = parse_end_tag();
                                        result5 = result5 !== null ? result5 : "";
                                        if (result5 !== null) {
                                            result6 = (function(offset, line, column, t, b, e, n) {if( (!n) || (t[1].text !== n.text) ) { throw new Error("Expected end tag for "+t[1].text+" but it was not found. At line : "+line+", column : " + column)} return true;})(pos.offset, pos.line, pos.column, result0, result3, result4, result5) ? "" : null;
                                            if (result6 !== null) {
                                                result0 = [result0, result1, result2, result3, result4, result5, result6];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, t, b, e, n) { e.push(["param", ["literal", "block"], b]); t.push(e); return t.concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[0], result0[3], result0[4], result0[5]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    if (result0 === null) {
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_sec_tag_start();
                        if (result0 !== null) {
                            result1 = [];
                            result2 = parse_ws();
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_ws();
                            }
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 47) {
                                    result2 = "/";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("\"/\"");
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse_rd();
                                    if (result3 !== null) {
                                        result0 = [result0, result1, result2, result3];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = (function(offset, line, column, t) { t.push(["bodies"]); return t.concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[0]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("section");
                    }
                    return result0;
                }

                function parse_sec_tag_start() {
                    var result0, result1, result2, result3, result4, result5;
                    var pos0, pos1;

                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_ld();
                    if (result0 !== null) {
                        if (/^[#?^<+@%]/.test(input.charAt(pos.offset))) {
                            result1 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("[#?^<+@%]");
                            }
                        }
                        if (result1 !== null) {
                            result2 = [];
                            result3 = parse_ws();
                            while (result3 !== null) {
                                result2.push(result3);
                                result3 = parse_ws();
                            }
                            if (result2 !== null) {
                                result3 = parse_identifier();
                                if (result3 !== null) {
                                    result4 = parse_context();
                                    if (result4 !== null) {
                                        result5 = parse_params();
                                        if (result5 !== null) {
                                            result0 = [result0, result1, result2, result3, result4, result5];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, t, n, c, p) { return [t, n, c, p] })(pos0.offset, pos0.line, pos0.column, result0[1], result0[3], result0[4], result0[5]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    return result0;
                }

                function parse_end_tag() {
                    var result0, result1, result2, result3, result4, result5;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_ld();
                    if (result0 !== null) {
                        if (input.charCodeAt(pos.offset) === 47) {
                            result1 = "/";
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"/\"");
                            }
                        }
                        if (result1 !== null) {
                            result2 = [];
                            result3 = parse_ws();
                            while (result3 !== null) {
                                result2.push(result3);
                                result3 = parse_ws();
                            }
                            if (result2 !== null) {
                                result3 = parse_identifier();
                                if (result3 !== null) {
                                    result4 = [];
                                    result5 = parse_ws();
                                    while (result5 !== null) {
                                        result4.push(result5);
                                        result5 = parse_ws();
                                    }
                                    if (result4 !== null) {
                                        result5 = parse_rd();
                                        if (result5 !== null) {
                                            result0 = [result0, result1, result2, result3, result4, result5];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, n) { return n })(pos0.offset, pos0.line, pos0.column, result0[3]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("end tag");
                    }
                    return result0;
                }

                function parse_context() {
                    var result0, result1;
                    var pos0, pos1, pos2;

                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    pos2 = clone(pos);
                    if (input.charCodeAt(pos.offset) === 58) {
                        result0 = ":";
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\":\"");
                        }
                    }
                    if (result0 !== null) {
                        result1 = parse_identifier();
                        if (result1 !== null) {
                            result0 = [result0, result1];
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos2);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, n) {return n})(pos1.offset, pos1.line, pos1.column, result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos1);
                    }
                    result0 = result0 !== null ? result0 : "";
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, n) { return n ? ["context", n] : ["context"] })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    return result0;
                }

                function parse_params() {
                    var result0, result1, result2, result3, result4;
                    var pos0, pos1, pos2;

                    reportFailures++;
                    pos0 = clone(pos);
                    result0 = [];
                    pos1 = clone(pos);
                    pos2 = clone(pos);
                    result2 = parse_ws();
                    if (result2 !== null) {
                        result1 = [];
                        while (result2 !== null) {
                            result1.push(result2);
                            result2 = parse_ws();
                        }
                    } else {
                        result1 = null;
                    }
                    if (result1 !== null) {
                        result2 = parse_key();
                        if (result2 !== null) {
                            if (input.charCodeAt(pos.offset) === 61) {
                                result3 = "=";
                                advance(pos, 1);
                            } else {
                                result3 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\"=\"");
                                }
                            }
                            if (result3 !== null) {
                                result4 = parse_number();
                                if (result4 === null) {
                                    result4 = parse_identifier();
                                    if (result4 === null) {
                                        result4 = parse_inline();
                                    }
                                }
                                if (result4 !== null) {
                                    result1 = [result1, result2, result3, result4];
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                    } else {
                        result1 = null;
                        pos = clone(pos2);
                    }
                    if (result1 !== null) {
                        result1 = (function(offset, line, column, k, v) {return ["param", ["literal", k], v]})(pos1.offset, pos1.line, pos1.column, result1[1], result1[3]);
                    }
                    if (result1 === null) {
                        pos = clone(pos1);
                    }
                    while (result1 !== null) {
                        result0.push(result1);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        result2 = parse_ws();
                        if (result2 !== null) {
                            result1 = [];
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_ws();
                            }
                        } else {
                            result1 = null;
                        }
                        if (result1 !== null) {
                            result2 = parse_key();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                    result3 = "=";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("\"=\"");
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse_number();
                                    if (result4 === null) {
                                        result4 = parse_identifier();
                                        if (result4 === null) {
                                            result4 = parse_inline();
                                        }
                                    }
                                    if (result4 !== null) {
                                        result1 = [result1, result2, result3, result4];
                                    } else {
                                        result1 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                        if (result1 !== null) {
                            result1 = (function(offset, line, column, k, v) {return ["param", ["literal", k], v]})(pos1.offset, pos1.line, pos1.column, result1[1], result1[3]);
                        }
                        if (result1 === null) {
                            pos = clone(pos1);
                        }
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, p) { return ["params"].concat(p) })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("params");
                    }
                    return result0;
                }

                function parse_bodies() {
                    var result0, result1, result2, result3, result4, result5;
                    var pos0, pos1, pos2;

                    reportFailures++;
                    pos0 = clone(pos);
                    result0 = [];
                    pos1 = clone(pos);
                    pos2 = clone(pos);
                    result1 = parse_ld();
                    if (result1 !== null) {
                        if (input.charCodeAt(pos.offset) === 58) {
                            result2 = ":";
                            advance(pos, 1);
                        } else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\":\"");
                            }
                        }
                        if (result2 !== null) {
                            result3 = parse_key();
                            if (result3 !== null) {
                                result4 = parse_rd();
                                if (result4 !== null) {
                                    result5 = parse_body();
                                    if (result5 !== null) {
                                        result1 = [result1, result2, result3, result4, result5];
                                    } else {
                                        result1 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                    } else {
                        result1 = null;
                        pos = clone(pos2);
                    }
                    if (result1 !== null) {
                        result1 = (function(offset, line, column, k, v) {return ["param", ["literal", k], v]})(pos1.offset, pos1.line, pos1.column, result1[2], result1[4]);
                    }
                    if (result1 === null) {
                        pos = clone(pos1);
                    }
                    while (result1 !== null) {
                        result0.push(result1);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        result1 = parse_ld();
                        if (result1 !== null) {
                            if (input.charCodeAt(pos.offset) === 58) {
                                result2 = ":";
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                }
                            }
                            if (result2 !== null) {
                                result3 = parse_key();
                                if (result3 !== null) {
                                    result4 = parse_rd();
                                    if (result4 !== null) {
                                        result5 = parse_body();
                                        if (result5 !== null) {
                                            result1 = [result1, result2, result3, result4, result5];
                                        } else {
                                            result1 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result1 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                        if (result1 !== null) {
                            result1 = (function(offset, line, column, k, v) {return ["param", ["literal", k], v]})(pos1.offset, pos1.line, pos1.column, result1[2], result1[4]);
                        }
                        if (result1 === null) {
                            pos = clone(pos1);
                        }
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, p) { return ["bodies"].concat(p) })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("bodies");
                    }
                    return result0;
                }

                function parse_reference() {
                    var result0, result1, result2, result3;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_ld();
                    if (result0 !== null) {
                        result1 = parse_identifier();
                        if (result1 !== null) {
                            result2 = parse_filters();
                            if (result2 !== null) {
                                result3 = parse_rd();
                                if (result3 !== null) {
                                    result0 = [result0, result1, result2, result3];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, n, f) { return ["reference", n, f].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("reference");
                    }
                    return result0;
                }

                function parse_partial() {
                    var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                    var pos0, pos1, pos2;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_ld();
                    if (result0 !== null) {
                        if (input.charCodeAt(pos.offset) === 62) {
                            result1 = ">";
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("\">\"");
                            }
                        }
                        if (result1 === null) {
                            if (input.charCodeAt(pos.offset) === 43) {
                                result1 = "+";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\"+\"");
                                }
                            }
                        }
                        if (result1 !== null) {
                            result2 = [];
                            result3 = parse_ws();
                            while (result3 !== null) {
                                result2.push(result3);
                                result3 = parse_ws();
                            }
                            if (result2 !== null) {
                                pos2 = clone(pos);
                                result3 = parse_key();
                                if (result3 !== null) {
                                    result3 = (function(offset, line, column, k) {return ["literal", k]})(pos2.offset, pos2.line, pos2.column, result3);
                                }
                                if (result3 === null) {
                                    pos = clone(pos2);
                                }
                                if (result3 === null) {
                                    result3 = parse_inline();
                                }
                                if (result3 !== null) {
                                    result4 = parse_context();
                                    if (result4 !== null) {
                                        result5 = parse_params();
                                        if (result5 !== null) {
                                            result6 = [];
                                            result7 = parse_ws();
                                            while (result7 !== null) {
                                                result6.push(result7);
                                                result7 = parse_ws();
                                            }
                                            if (result6 !== null) {
                                                if (input.charCodeAt(pos.offset) === 47) {
                                                    result7 = "/";
                                                    advance(pos, 1);
                                                } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed("\"/\"");
                                                    }
                                                }
                                                if (result7 !== null) {
                                                    result8 = parse_rd();
                                                    if (result8 !== null) {
                                                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, s, n, c, p) { var key = (s ===">")? "partial" : s; return [key, n, c, p].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[1], result0[3], result0[4], result0[5]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("partial");
                    }
                    return result0;
                }

                function parse_filters() {
                    var result0, result1, result2;
                    var pos0, pos1, pos2;

                    reportFailures++;
                    pos0 = clone(pos);
                    result0 = [];
                    pos1 = clone(pos);
                    pos2 = clone(pos);
                    if (input.charCodeAt(pos.offset) === 124) {
                        result1 = "|";
                        advance(pos, 1);
                    } else {
                        result1 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"|\"");
                        }
                    }
                    if (result1 !== null) {
                        result2 = parse_key();
                        if (result2 !== null) {
                            result1 = [result1, result2];
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                    } else {
                        result1 = null;
                        pos = clone(pos2);
                    }
                    if (result1 !== null) {
                        result1 = (function(offset, line, column, n) {return n})(pos1.offset, pos1.line, pos1.column, result1[1]);
                    }
                    if (result1 === null) {
                        pos = clone(pos1);
                    }
                    while (result1 !== null) {
                        result0.push(result1);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 124) {
                            result1 = "|";
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"|\"");
                            }
                        }
                        if (result1 !== null) {
                            result2 = parse_key();
                            if (result2 !== null) {
                                result1 = [result1, result2];
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                        if (result1 !== null) {
                            result1 = (function(offset, line, column, n) {return n})(pos1.offset, pos1.line, pos1.column, result1[1]);
                        }
                        if (result1 === null) {
                            pos = clone(pos1);
                        }
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, f) { return ["filters"].concat(f) })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("filters");
                    }
                    return result0;
                }

                function parse_special() {
                    var result0, result1, result2, result3;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_ld();
                    if (result0 !== null) {
                        if (input.charCodeAt(pos.offset) === 126) {
                            result1 = "~";
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"~\"");
                            }
                        }
                        if (result1 !== null) {
                            result2 = parse_key();
                            if (result2 !== null) {
                                result3 = parse_rd();
                                if (result3 !== null) {
                                    result0 = [result0, result1, result2, result3];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, k) { return ["special", k].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[2]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("special");
                    }
                    return result0;
                }

                function parse_identifier() {
                    var result0;
                    var pos0;

                    reportFailures++;
                    pos0 = clone(pos);
                    result0 = parse_path();
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, p) { var arr = ["path"].concat(p); arr.text = p[1].join('.'); return arr; })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    if (result0 === null) {
                        pos0 = clone(pos);
                        result0 = parse_key();
                        if (result0 !== null) {
                            result0 = (function(offset, line, column, k) { var arr = ["key", k]; arr.text = k; return arr; })(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("identifier");
                    }
                    return result0;
                }

                function parse_number() {
                    var result0;
                    var pos0;

                    reportFailures++;
                    pos0 = clone(pos);
                    result0 = parse_float();
                    if (result0 === null) {
                        result0 = parse_integer();
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, n) { return ['literal', n]; })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("number");
                    }
                    return result0;
                }

                function parse_float() {
                    var result0, result1, result2, result3;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_integer();
                    if (result0 !== null) {
                        if (input.charCodeAt(pos.offset) === 46) {
                            result1 = ".";
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("\".\"");
                            }
                        }
                        if (result1 !== null) {
                            result3 = parse_integer();
                            if (result3 !== null) {
                                result2 = [];
                                while (result3 !== null) {
                                    result2.push(result3);
                                    result3 = parse_integer();
                                }
                            } else {
                                result2 = null;
                            }
                            if (result2 !== null) {
                                result0 = [result0, result1, result2];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, l, r) { return parseFloat(l + "." + r.join('')); })(pos0.offset, pos0.line, pos0.column, result0[0], result0[2]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("float");
                    }
                    return result0;
                }

                function parse_integer() {
                    var result0, result1;
                    var pos0;

                    reportFailures++;
                    pos0 = clone(pos);
                    if (/^[0-9]/.test(input.charAt(pos.offset))) {
                        result1 = input.charAt(pos.offset);
                        advance(pos, 1);
                    } else {
                        result1 = null;
                        if (reportFailures === 0) {
                            matchFailed("[0-9]");
                        }
                    }
                    if (result1 !== null) {
                        result0 = [];
                        while (result1 !== null) {
                            result0.push(result1);
                            if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                result1 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[0-9]");
                                }
                            }
                        }
                    } else {
                        result0 = null;
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, digits) { return parseInt(digits.join(""), 10); })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("integer");
                    }
                    return result0;
                }

                function parse_path() {
                    var result0, result1, result2;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_key();
                    result0 = result0 !== null ? result0 : "";
                    if (result0 !== null) {
                        result2 = parse_array_part();
                        if (result2 === null) {
                            result2 = parse_array();
                        }
                        if (result2 !== null) {
                            result1 = [];
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_array_part();
                                if (result2 === null) {
                                    result2 = parse_array();
                                }
                            }
                        } else {
                            result1 = null;
                        }
                        if (result1 !== null) {
                            result0 = [result0, result1];
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, k, d) {
                            d = d[0];
                            if (k && d) {
                                d.unshift(k);
                                return [false, d].concat([['line', line], ['col', column]]);
                            }
                            return [true, d].concat([['line', line], ['col', column]]);
                        })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    if (result0 === null) {
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 46) {
                            result0 = ".";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("\".\"");
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            result2 = parse_array_part();
                            if (result2 === null) {
                                result2 = parse_array();
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_array_part();
                                if (result2 === null) {
                                    result2 = parse_array();
                                }
                            }
                            if (result1 !== null) {
                                result0 = [result0, result1];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = (function(offset, line, column, d) {
                                if (d.length > 0) {
                                    return [true, d[0]].concat([['line', line], ['col', column]]);
                                }
                                return [true, []].concat([['line', line], ['col', column]]);
                            })(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("path");
                    }
                    return result0;
                }

                function parse_key() {
                    var result0, result1, result2;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    if (/^[a-zA-Z_$]/.test(input.charAt(pos.offset))) {
                        result0 = input.charAt(pos.offset);
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("[a-zA-Z_$]");
                        }
                    }
                    if (result0 !== null) {
                        result1 = [];
                        if (/^[0-9a-zA-Z_$\-]/.test(input.charAt(pos.offset))) {
                            result2 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("[0-9a-zA-Z_$\\-]");
                            }
                        }
                        while (result2 !== null) {
                            result1.push(result2);
                            if (/^[0-9a-zA-Z_$\-]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[0-9a-zA-Z_$\\-]");
                                }
                            }
                        }
                        if (result1 !== null) {
                            result0 = [result0, result1];
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, h, t) { return h + t.join('') })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("key");
                    }
                    return result0;
                }

                function parse_array() {
                    var result0, result1, result2;
                    var pos0, pos1, pos2, pos3, pos4;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    pos2 = clone(pos);
                    pos3 = clone(pos);
                    result0 = parse_lb();
                    if (result0 !== null) {
                        pos4 = clone(pos);
                        if (/^[0-9]/.test(input.charAt(pos.offset))) {
                            result2 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("[0-9]");
                            }
                        }
                        if (result2 !== null) {
                            result1 = [];
                            while (result2 !== null) {
                                result1.push(result2);
                                if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                    result2 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[0-9]");
                                    }
                                }
                            }
                        } else {
                            result1 = null;
                        }
                        if (result1 !== null) {
                            result1 = (function(offset, line, column, n) {return n.join('')})(pos4.offset, pos4.line, pos4.column, result1);
                        }
                        if (result1 === null) {
                            pos = clone(pos4);
                        }
                        if (result1 === null) {
                            result1 = parse_identifier();
                        }
                        if (result1 !== null) {
                            result2 = parse_rb();
                            if (result2 !== null) {
                                result0 = [result0, result1, result2];
                            } else {
                                result0 = null;
                                pos = clone(pos3);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos3);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos3);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, a) {return a; })(pos2.offset, pos2.line, pos2.column, result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos2);
                    }
                    if (result0 !== null) {
                        result1 = parse_array_part();
                        result1 = result1 !== null ? result1 : "";
                        if (result1 !== null) {
                            result0 = [result0, result1];
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, i, nk) { if(nk) { nk.unshift(i); } else {nk = [i] } return nk; })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("array");
                    }
                    return result0;
                }

                function parse_array_part() {
                    var result0, result1, result2;
                    var pos0, pos1, pos2, pos3;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    pos2 = clone(pos);
                    pos3 = clone(pos);
                    if (input.charCodeAt(pos.offset) === 46) {
                        result1 = ".";
                        advance(pos, 1);
                    } else {
                        result1 = null;
                        if (reportFailures === 0) {
                            matchFailed("\".\"");
                        }
                    }
                    if (result1 !== null) {
                        result2 = parse_key();
                        if (result2 !== null) {
                            result1 = [result1, result2];
                        } else {
                            result1 = null;
                            pos = clone(pos3);
                        }
                    } else {
                        result1 = null;
                        pos = clone(pos3);
                    }
                    if (result1 !== null) {
                        result1 = (function(offset, line, column, k) {return k})(pos2.offset, pos2.line, pos2.column, result1[1]);
                    }
                    if (result1 === null) {
                        pos = clone(pos2);
                    }
                    if (result1 !== null) {
                        result0 = [];
                        while (result1 !== null) {
                            result0.push(result1);
                            pos2 = clone(pos);
                            pos3 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 46) {
                                result1 = ".";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\".\"");
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse_key();
                                if (result2 !== null) {
                                    result1 = [result1, result2];
                                } else {
                                    result1 = null;
                                    pos = clone(pos3);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos3);
                            }
                            if (result1 !== null) {
                                result1 = (function(offset, line, column, k) {return k})(pos2.offset, pos2.line, pos2.column, result1[1]);
                            }
                            if (result1 === null) {
                                pos = clone(pos2);
                            }
                        }
                    } else {
                        result0 = null;
                    }
                    if (result0 !== null) {
                        result1 = parse_array();
                        result1 = result1 !== null ? result1 : "";
                        if (result1 !== null) {
                            result0 = [result0, result1];
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, d, a) { if (a) { return d.concat(a); } else { return d; } })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("array_part");
                    }
                    return result0;
                }

                function parse_inline() {
                    var result0, result1, result2;
                    var pos0, pos1;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    if (input.charCodeAt(pos.offset) === 34) {
                        result0 = "\"";
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"\\\"\"");
                        }
                    }
                    if (result0 !== null) {
                        if (input.charCodeAt(pos.offset) === 34) {
                            result1 = "\"";
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"\\\"\"");
                            }
                        }
                        if (result1 !== null) {
                            result0 = [result0, result1];
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column) { return ["literal", ""].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    if (result0 === null) {
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 34) {
                            result0 = "\"";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"\\\"\"");
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_literal();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 34) {
                                    result2 = "\"";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("\"\\\"\"");
                                    }
                                }
                                if (result2 !== null) {
                                    result0 = [result0, result1, result2];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = (function(offset, line, column, l) { return ["literal", l].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 34) {
                                result0 = "\"";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\"\\\"\"");
                                }
                            }
                            if (result0 !== null) {
                                result2 = parse_inline_part();
                                if (result2 !== null) {
                                    result1 = [];
                                    while (result2 !== null) {
                                        result1.push(result2);
                                        result2 = parse_inline_part();
                                    }
                                } else {
                                    result1 = null;
                                }
                                if (result1 !== null) {
                                    if (input.charCodeAt(pos.offset) === 34) {
                                        result2 = "\"";
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("\"\\\"\"");
                                        }
                                    }
                                    if (result2 !== null) {
                                        result0 = [result0, result1, result2];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = (function(offset, line, column, p) { return ["body"].concat(p).concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[1]);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("inline");
                    }
                    return result0;
                }

                function parse_inline_part() {
                    var result0;
                    var pos0;

                    result0 = parse_special();
                    if (result0 === null) {
                        result0 = parse_reference();
                        if (result0 === null) {
                            pos0 = clone(pos);
                            result0 = parse_literal();
                            if (result0 !== null) {
                                result0 = (function(offset, line, column, l) { return ["buffer", l] })(pos0.offset, pos0.line, pos0.column, result0);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                    }
                    return result0;
                }

                function parse_buffer() {
                    var result0, result1, result2, result3, result4;
                    var pos0, pos1, pos2, pos3;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    result0 = parse_eol();
                    if (result0 !== null) {
                        result1 = [];
                        result2 = parse_ws();
                        while (result2 !== null) {
                            result1.push(result2);
                            result2 = parse_ws();
                        }
                        if (result1 !== null) {
                            result0 = [result0, result1];
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, e, w) { return ["format", e, w.join('')].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    if (result0 === null) {
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        pos3 = clone(pos);
                        reportFailures++;
                        result1 = parse_tag();
                        reportFailures--;
                        if (result1 === null) {
                            result1 = "";
                        } else {
                            result1 = null;
                            pos = clone(pos3);
                        }
                        if (result1 !== null) {
                            pos3 = clone(pos);
                            reportFailures++;
                            result2 = parse_comment();
                            reportFailures--;
                            if (result2 === null) {
                                result2 = "";
                            } else {
                                result2 = null;
                                pos = clone(pos3);
                            }
                            if (result2 !== null) {
                                pos3 = clone(pos);
                                reportFailures++;
                                result3 = parse_eol();
                                reportFailures--;
                                if (result3 === null) {
                                    result3 = "";
                                } else {
                                    result3 = null;
                                    pos = clone(pos3);
                                }
                                if (result3 !== null) {
                                    if (input.length > pos.offset) {
                                        result4 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("any character");
                                        }
                                    }
                                    if (result4 !== null) {
                                        result1 = [result1, result2, result3, result4];
                                    } else {
                                        result1 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                        if (result1 !== null) {
                            result1 = (function(offset, line, column, c) {return c})(pos1.offset, pos1.line, pos1.column, result1[3]);
                        }
                        if (result1 === null) {
                            pos = clone(pos1);
                        }
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                pos1 = clone(pos);
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                reportFailures++;
                                result1 = parse_tag();
                                reportFailures--;
                                if (result1 === null) {
                                    result1 = "";
                                } else {
                                    result1 = null;
                                    pos = clone(pos3);
                                }
                                if (result1 !== null) {
                                    pos3 = clone(pos);
                                    reportFailures++;
                                    result2 = parse_comment();
                                    reportFailures--;
                                    if (result2 === null) {
                                        result2 = "";
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                    if (result2 !== null) {
                                        pos3 = clone(pos);
                                        reportFailures++;
                                        result3 = parse_eol();
                                        reportFailures--;
                                        if (result3 === null) {
                                            result3 = "";
                                        } else {
                                            result3 = null;
                                            pos = clone(pos3);
                                        }
                                        if (result3 !== null) {
                                            if (input.length > pos.offset) {
                                                result4 = input.charAt(pos.offset);
                                                advance(pos, 1);
                                            } else {
                                                result4 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed("any character");
                                                }
                                            }
                                            if (result4 !== null) {
                                                result1 = [result1, result2, result3, result4];
                                            } else {
                                                result1 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result1 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result1 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                                if (result1 !== null) {
                                    result1 = (function(offset, line, column, c) {return c})(pos1.offset, pos1.line, pos1.column, result1[3]);
                                }
                                if (result1 === null) {
                                    pos = clone(pos1);
                                }
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = (function(offset, line, column, b) { return ["buffer", b.join('')].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("buffer");
                    }
                    return result0;
                }

                function parse_literal() {
                    var result0, result1, result2;
                    var pos0, pos1, pos2, pos3;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    pos2 = clone(pos);
                    pos3 = clone(pos);
                    reportFailures++;
                    result1 = parse_tag();
                    reportFailures--;
                    if (result1 === null) {
                        result1 = "";
                    } else {
                        result1 = null;
                        pos = clone(pos3);
                    }
                    if (result1 !== null) {
                        result2 = parse_esc();
                        if (result2 === null) {
                            if (/^[^"]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[^\"]");
                                }
                            }
                        }
                        if (result2 !== null) {
                            result1 = [result1, result2];
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                    } else {
                        result1 = null;
                        pos = clone(pos2);
                    }
                    if (result1 !== null) {
                        result1 = (function(offset, line, column, c) {return c})(pos1.offset, pos1.line, pos1.column, result1[1]);
                    }
                    if (result1 === null) {
                        pos = clone(pos1);
                    }
                    if (result1 !== null) {
                        result0 = [];
                        while (result1 !== null) {
                            result0.push(result1);
                            pos1 = clone(pos);
                            pos2 = clone(pos);
                            pos3 = clone(pos);
                            reportFailures++;
                            result1 = parse_tag();
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos3);
                            }
                            if (result1 !== null) {
                                result2 = parse_esc();
                                if (result2 === null) {
                                    if (/^[^"]/.test(input.charAt(pos.offset))) {
                                        result2 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[^\"]");
                                        }
                                    }
                                }
                                if (result2 !== null) {
                                    result1 = [result1, result2];
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result1 = (function(offset, line, column, c) {return c})(pos1.offset, pos1.line, pos1.column, result1[1]);
                            }
                            if (result1 === null) {
                                pos = clone(pos1);
                            }
                        }
                    } else {
                        result0 = null;
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, b) { return b.join('') })(pos0.offset, pos0.line, pos0.column, result0);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("literal");
                    }
                    return result0;
                }

                function parse_esc() {
                    var result0;
                    var pos0;

                    pos0 = clone(pos);
                    if (input.substr(pos.offset, 2) === "\\\"") {
                        result0 = "\\\"";
                        advance(pos, 2);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"\\\\\\\"\"");
                        }
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column) { return '"' })(pos0.offset, pos0.line, pos0.column);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    return result0;
                }

                function parse_comment() {
                    var result0, result1, result2, result3;
                    var pos0, pos1, pos2, pos3, pos4;

                    reportFailures++;
                    pos0 = clone(pos);
                    pos1 = clone(pos);
                    if (input.substr(pos.offset, 2) === "{!") {
                        result0 = "{!";
                        advance(pos, 2);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"{!\"");
                        }
                    }
                    if (result0 !== null) {
                        result1 = [];
                        pos2 = clone(pos);
                        pos3 = clone(pos);
                        pos4 = clone(pos);
                        reportFailures++;
                        if (input.substr(pos.offset, 2) === "!}") {
                            result2 = "!}";
                            advance(pos, 2);
                        } else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"!}\"");
                            }
                        }
                        reportFailures--;
                        if (result2 === null) {
                            result2 = "";
                        } else {
                            result2 = null;
                            pos = clone(pos4);
                        }
                        if (result2 !== null) {
                            if (input.length > pos.offset) {
                                result3 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result3 = null;
                                if (reportFailures === 0) {
                                    matchFailed("any character");
                                }
                            }
                            if (result3 !== null) {
                                result2 = [result2, result3];
                            } else {
                                result2 = null;
                                pos = clone(pos3);
                            }
                        } else {
                            result2 = null;
                            pos = clone(pos3);
                        }
                        if (result2 !== null) {
                            result2 = (function(offset, line, column, c) {return c})(pos2.offset, pos2.line, pos2.column, result2[1]);
                        }
                        if (result2 === null) {
                            pos = clone(pos2);
                        }
                        while (result2 !== null) {
                            result1.push(result2);
                            pos2 = clone(pos);
                            pos3 = clone(pos);
                            pos4 = clone(pos);
                            reportFailures++;
                            if (input.substr(pos.offset, 2) === "!}") {
                                result2 = "!}";
                                advance(pos, 2);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\"!}\"");
                                }
                            }
                            reportFailures--;
                            if (result2 === null) {
                                result2 = "";
                            } else {
                                result2 = null;
                                pos = clone(pos4);
                            }
                            if (result2 !== null) {
                                if (input.length > pos.offset) {
                                    result3 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("any character");
                                    }
                                }
                                if (result3 !== null) {
                                    result2 = [result2, result3];
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos3);
                            }
                            if (result2 !== null) {
                                result2 = (function(offset, line, column, c) {return c})(pos2.offset, pos2.line, pos2.column, result2[1]);
                            }
                            if (result2 === null) {
                                pos = clone(pos2);
                            }
                        }
                        if (result1 !== null) {
                            if (input.substr(pos.offset, 2) === "!}") {
                                result2 = "!}";
                                advance(pos, 2);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\"!}\"");
                                }
                            }
                            if (result2 !== null) {
                                result0 = [result0, result1, result2];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos1);
                    }
                    if (result0 !== null) {
                        result0 = (function(offset, line, column, c) { return ["comment", c.join('')].concat([['line', line], ['col', column]]) })(pos0.offset, pos0.line, pos0.column, result0[1]);
                    }
                    if (result0 === null) {
                        pos = clone(pos0);
                    }
                    reportFailures--;
                    if (reportFailures === 0 && result0 === null) {
                        matchFailed("comment");
                    }
                    return result0;
                }

                function parse_tag() {
                    var result0, result1, result2, result3, result4, result5, result6, result7;
                    var pos0, pos1, pos2;

                    pos0 = clone(pos);
                    result0 = parse_ld();
                    if (result0 !== null) {
                        result1 = [];
                        result2 = parse_ws();
                        while (result2 !== null) {
                            result1.push(result2);
                            result2 = parse_ws();
                        }
                        if (result1 !== null) {
                            if (/^[#?^><+%:@\/~%]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[#?^><+%:@\\/~%]");
                                }
                            }
                            if (result2 !== null) {
                                result3 = [];
                                result4 = parse_ws();
                                while (result4 !== null) {
                                    result3.push(result4);
                                    result4 = parse_ws();
                                }
                                if (result3 !== null) {
                                    pos1 = clone(pos);
                                    pos2 = clone(pos);
                                    reportFailures++;
                                    result5 = parse_rd();
                                    reportFailures--;
                                    if (result5 === null) {
                                        result5 = "";
                                    } else {
                                        result5 = null;
                                        pos = clone(pos2);
                                    }
                                    if (result5 !== null) {
                                        pos2 = clone(pos);
                                        reportFailures++;
                                        result6 = parse_eol();
                                        reportFailures--;
                                        if (result6 === null) {
                                            result6 = "";
                                        } else {
                                            result6 = null;
                                            pos = clone(pos2);
                                        }
                                        if (result6 !== null) {
                                            if (input.length > pos.offset) {
                                                result7 = input.charAt(pos.offset);
                                                advance(pos, 1);
                                            } else {
                                                result7 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed("any character");
                                                }
                                            }
                                            if (result7 !== null) {
                                                result5 = [result5, result6, result7];
                                            } else {
                                                result5 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result5 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result5 = null;
                                        pos = clone(pos1);
                                    }
                                    if (result5 !== null) {
                                        result4 = [];
                                        while (result5 !== null) {
                                            result4.push(result5);
                                            pos1 = clone(pos);
                                            pos2 = clone(pos);
                                            reportFailures++;
                                            result5 = parse_rd();
                                            reportFailures--;
                                            if (result5 === null) {
                                                result5 = "";
                                            } else {
                                                result5 = null;
                                                pos = clone(pos2);
                                            }
                                            if (result5 !== null) {
                                                pos2 = clone(pos);
                                                reportFailures++;
                                                result6 = parse_eol();
                                                reportFailures--;
                                                if (result6 === null) {
                                                    result6 = "";
                                                } else {
                                                    result6 = null;
                                                    pos = clone(pos2);
                                                }
                                                if (result6 !== null) {
                                                    if (input.length > pos.offset) {
                                                        result7 = input.charAt(pos.offset);
                                                        advance(pos, 1);
                                                    } else {
                                                        result7 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed("any character");
                                                        }
                                                    }
                                                    if (result7 !== null) {
                                                        result5 = [result5, result6, result7];
                                                    } else {
                                                        result5 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result5 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result5 = null;
                                                pos = clone(pos1);
                                            }
                                        }
                                    } else {
                                        result4 = null;
                                    }
                                    if (result4 !== null) {
                                        result5 = [];
                                        result6 = parse_ws();
                                        while (result6 !== null) {
                                            result5.push(result6);
                                            result6 = parse_ws();
                                        }
                                        if (result5 !== null) {
                                            result6 = parse_rd();
                                            if (result6 !== null) {
                                                result0 = [result0, result1, result2, result3, result4, result5, result6];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos0);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos0);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos0);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos0);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos0);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                    } else {
                        result0 = null;
                        pos = clone(pos0);
                    }
                    if (result0 === null) {
                        result0 = parse_reference();
                    }
                    return result0;
                }

                function parse_ld() {
                    var result0;

                    if (input.charCodeAt(pos.offset) === 123) {
                        result0 = "{";
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"{\"");
                        }
                    }
                    return result0;
                }

                function parse_rd() {
                    var result0;

                    if (input.charCodeAt(pos.offset) === 125) {
                        result0 = "}";
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"}\"");
                        }
                    }
                    return result0;
                }

                function parse_lb() {
                    var result0;

                    if (input.charCodeAt(pos.offset) === 91) {
                        result0 = "[";
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"[\"");
                        }
                    }
                    return result0;
                }

                function parse_rb() {
                    var result0;

                    if (input.charCodeAt(pos.offset) === 93) {
                        result0 = "]";
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"]\"");
                        }
                    }
                    return result0;
                }

                function parse_eol() {
                    var result0;

                    if (input.charCodeAt(pos.offset) === 10) {
                        result0 = "\n";
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"\\n\"");
                        }
                    }
                    if (result0 === null) {
                        if (input.substr(pos.offset, 2) === "\r\n") {
                            result0 = "\r\n";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"\\r\\n\"");
                            }
                        }
                        if (result0 === null) {
                            if (input.charCodeAt(pos.offset) === 13) {
                                result0 = "\r";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\"\\r\"");
                                }
                            }
                            if (result0 === null) {
                                if (input.charCodeAt(pos.offset) === 8232) {
                                    result0 = "\u2028";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("\"\\u2028\"");
                                    }
                                }
                                if (result0 === null) {
                                    if (input.charCodeAt(pos.offset) === 8233) {
                                        result0 = "\u2029";
                                        advance(pos, 1);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("\"\\u2029\"");
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return result0;
                }

                function parse_ws() {
                    var result0;

                    if (/^[\t\x0B\f \xA0\uFEFF]/.test(input.charAt(pos.offset))) {
                        result0 = input.charAt(pos.offset);
                        advance(pos, 1);
                    } else {
                        result0 = null;
                        if (reportFailures === 0) {
                            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF]");
                        }
                    }
                    if (result0 === null) {
                        result0 = parse_eol();
                    }
                    return result0;
                }


                function cleanupExpected(expected) {
                    expected.sort();

                    var lastExpected = null;
                    var cleanExpected = [];
                    for (var i = 0; i < expected.length; i++) {
                        if (expected[i] !== lastExpected) {
                            cleanExpected.push(expected[i]);
                            lastExpected = expected[i];
                        }
                    }
                    return cleanExpected;
                }



                var result = parseFunctions[startRule]();

                /*
                 * The parser is now in one of the following three states:
                 *
                 * 1. The parser successfully parsed the whole input.
                 *
                 *    - |result !== null|
                 *    - |pos.offset === input.length|
                 *    - |rightmostFailuresExpected| may or may not contain something
                 *
                 * 2. The parser successfully parsed only a part of the input.
                 *
                 *    - |result !== null|
                 *    - |pos.offset < input.length|
                 *    - |rightmostFailuresExpected| may or may not contain something
                 *
                 * 3. The parser did not successfully parse any part of the input.
                 *
                 *   - |result === null|
                 *   - |pos.offset === 0|
                 *   - |rightmostFailuresExpected| contains at least one failure
                 *
                 * All code following this comment (including called functions) must
                 * handle these states.
                 */
                if (result === null || pos.offset !== input.length) {
                    var offset = Math.max(pos.offset, rightmostFailuresPos.offset);
                    var found = offset < input.length ? input.charAt(offset) : null;
                    var errorPosition = pos.offset > rightmostFailuresPos.offset ? pos : rightmostFailuresPos;

                    throw new parser.SyntaxError(
                        cleanupExpected(rightmostFailuresExpected),
                        found,
                        offset,
                        errorPosition.line,
                        errorPosition.column
                    );
                }

                return result;
            },

            /* Returns the parser source code. */
            toSource: function() { return this._source; }
        };

        /* Thrown when a parser encounters a syntax error. */

        result.SyntaxError = function(expected, found, offset, line, column) {
            function buildMessage(expected, found) {
                var expectedHumanized, foundHumanized;

                switch (expected.length) {
                    case 0:
                        expectedHumanized = "end of input";
                        break;
                    case 1:
                        expectedHumanized = expected[0];
                        break;
                    default:
                        expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
                            + " or "
                            + expected[expected.length - 1];
                }

                foundHumanized = found ? quote(found) : "end of input";

                return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
            }

            this.name = "SyntaxError";
            this.expected = expected;
            this.found = found;
            this.message = buildMessage(expected, found);
            this.offset = offset;
            this.line = line;
            this.column = column;
        };

        result.SyntaxError.prototype = Error.prototype;

        return result;
    })();

    dust.parse = parser.parse;

})(typeof exports !== 'undefined' ? exports : getGlobal());
/*! dustjs-helpers - v1.2.0
* https://github.com/linkedin/dustjs-helpers
* Copyright (c) 2014 Aleksander Williams; Released under the MIT License */
(function(dust){

// Note: all error conditions are logged to console and failed silently

/* make a safe version of console if it is not available
 * currently supporting:
 *   _console.log
 * */
var _console = (typeof console !== 'undefined')? console: {
  log: function(){
     /* a noop*/
   }
};

function isSelect(context) {
  var value = context.current();
  return typeof value === "object" && value.isSelect === true;
}

// Utility method : toString() equivalent for functions
function jsonFilter(key, value) {
  if (typeof value === "function") {
    //to make sure all environments format functions the same way
    return value.toString()
      //remove all leading and trailing whitespace
      .replace(/(^\s+|\s+$)/mg, '')
      //remove new line characters
      .replace(/\n/mg, '')
      //replace , and 0 or more spaces with ", "
      .replace(/,\s*/mg, ', ')
      //insert space between ){
      .replace(/\)\{/mg, ') {')
    ;
  }
  return value;
}

// Utility method: to invoke the given filter operation such as eq/gt etc
function filter(chunk, context, bodies, params, filterOp) {
  params = params || {};
  var body = bodies.block,
      actualKey,
      expectedValue,
      filterOpType = params.filterOpType || '';
  // when @eq, @lt etc are used as standalone helpers, key is required and hence check for defined
  if ( typeof params.key !== "undefined") {
    actualKey = dust.helpers.tap(params.key, chunk, context);
  }
  else if (isSelect(context)) {
    actualKey = context.current().selectKey;
    //  supports only one of the blocks in the select to be selected
    if (context.current().isResolved) {
      filterOp = function() { return false; };
    }
  }
  else {
    _console.log ("No key specified for filter in:" + filterOpType + " helper ");
    return chunk;
  }
  expectedValue = dust.helpers.tap(params.value, chunk, context);
  // coerce both the actualKey and expectedValue to the same type for equality and non-equality compares
  if (filterOp(coerce(expectedValue, params.type, context), coerce(actualKey, params.type, context))) {
    if (isSelect(context)) {
      context.current().isResolved = true;
    }
    // we want helpers without bodies to fail gracefully so check it first
    if(body) {
     return chunk.render(body, context);
    }
    else {
      _console.log( "Missing body block in the " + filterOpType + " helper ");
      return chunk;
    }
   }
   else if (bodies['else']) {
    return chunk.render(bodies['else'], context);
  }
  return chunk;
}

function coerce (value, type, context) {
  if (value) {
    switch (type || typeof(value)) {
      case 'number': return +value;
      case 'string': return String(value);
      case 'boolean': {
        value = (value === 'false' ? false : value);
        return Boolean(value);
      }
      case 'date': return new Date(value);
      case 'context': return context.get(value);
    }
  }

  return value;
}

var helpers = {

  // Utility helping to resolve dust references in the given chunk
  // uses the Chunk.render method to resolve value
  /*
   Reference resolution rules:
   if value exists in JSON:
    "" or '' will evaluate to false, boolean false, null, or undefined will evaluate to false,
    numeric 0 evaluates to true, so does, string "0", string "null", string "undefined" and string "false". 
    Also note that empty array -> [] is evaluated to false and empty object -> {} and non-empty object are evaluated to true
    The type of the return value is string ( since we concatenate to support interpolated references 

   if value does not exist in JSON and the input is a single reference: {x}
     dust render emits empty string, and we then return false   
     
   if values does not exist in JSON and the input is interpolated references : {x} < {y}
     dust render emits <  and we return the partial output 
     
  */
  "tap": function(input, chunk, context) {
    // return given input if there is no dust reference to resolve
    // dust compiles a string/reference such as {foo} to a function
    if (typeof input !== "function") {
      return input;
    }

    var dustBodyOutput = '',
      returnValue;

    //use chunk render to evaluate output. For simple functions result will be returned from render call,
    //for dust body functions result will be output via callback function
    returnValue = chunk.tap(function(data) {
      dustBodyOutput += data;
      return '';
    }).render(input, context);

    chunk.untap();

    //assume it's a simple function call if return result is not a chunk
    if (returnValue.constructor !== chunk.constructor) {
      //use returnValue as a result of tap
      return returnValue;
    } else if (dustBodyOutput === '') {
      return false;
    } else {
      return dustBodyOutput;
    }
  },

  "sep": function(chunk, context, bodies) {
    var body = bodies.block;
    if (context.stack.index === context.stack.of - 1) {
      return chunk;
    }
    if(body) {
     return bodies.block(chunk, context);
    }
    else {
     return chunk;
    }
  },

  "idx": function(chunk, context, bodies) {
    var body = bodies.block;
     if(body) {
       return bodies.block(chunk, context.push(context.stack.index));
     }
     else {
       return chunk;
     }
  },

  /**
   * contextDump helper
   * @param key specifies how much to dump.
   * "current" dumps current context. "full" dumps the full context stack.
   * @param to specifies where to write dump output.
   * Values can be "console" or "output". Default is output.
   */
  "contextDump": function(chunk, context, bodies, params) {
    var p = params || {},
      to = p.to || 'output',
      key = p.key || 'current',
      dump;
    to = dust.helpers.tap(to, chunk, context);
    key = dust.helpers.tap(key, chunk, context);
    if (key === 'full') {
      dump = JSON.stringify(context.stack, jsonFilter, 2);
    }
    else {
      dump = JSON.stringify(context.stack.head, jsonFilter, 2);
    }
    if (to === 'console') {
      _console.log(dump);
      return chunk;
    }
    else {
      return chunk.write(dump);
    }
  },
  /**
   if helper for complex evaluation complex logic expressions.
   Note : #1 if helper fails gracefully when there is no body block nor else block
          #2 Undefined values and false values in the JSON need to be handled specially with .length check
             for e.g @if cond=" '{a}'.length && '{b}'.length" is advised when there are chances of the a and b been
             undefined or false in the context
          #3 Use only when the default ? and ^ dust operators and the select fall short in addressing the given logic,
             since eval executes in the global scope
          #4 All dust references are default escaped as they are resolved, hence eval will block malicious scripts in the context
             Be mindful of evaluating a expression that is passed through the unescape filter -> |s
   @param cond, either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. cond="2>3"
                a dust reference is also enclosed in double quotes, e.g. cond="'{val}'' > 3"
    cond argument should evaluate to a valid javascript expression
   **/

  "if": function( chunk, context, bodies, params ){
    var body = bodies.block,
        skip = bodies['else'];
    if( params && params.cond){
      var cond = params.cond;
      cond = dust.helpers.tap(cond, chunk, context);
      // eval expressions with given dust references
      if(eval(cond)){
       if(body) {
        return chunk.render( bodies.block, context );
       }
       else {
         _console.log( "Missing body block in the if helper!" );
         return chunk;
       }
      }
      if(skip){
       return chunk.render( bodies['else'], context );
      }
    }
    // no condition
    else {
      _console.log( "No condition given in the if helper!" );
    }
    return chunk;
  },

  /**
   * math helper
   * @param key is the value to perform math against
   * @param method is the math method,  is a valid string supported by math helper like mod, add, subtract
   * @param operand is the second value needed for operations like mod, add, subtract, etc.
   * @param round is a flag to assure that an integer is returned
   */
  "math": function ( chunk, context, bodies, params ) {
    //key and method are required for further processing
    if( params && typeof params.key !== "undefined" && params.method ){
      var key  = params.key,
          method = params.method,
          // operand can be null for "abs", ceil and floor
          operand = params.operand,
          round = params.round,
          mathOut = null,
          operError = function(){_console.log("operand is required for this math method"); return null;};
      key  = dust.helpers.tap(key, chunk, context);
      operand = dust.helpers.tap(operand, chunk, context);
      //  TODO: handle  and tests for negatives and floats in all math operations
      switch(method) {
        case "mod":
          if(operand === 0 || operand === -0) {
            _console.log("operand for divide operation is 0/-0: expect Nan!");
          }
          mathOut = parseFloat(key) %  parseFloat(operand);
          break;
        case "add":
          mathOut = parseFloat(key) + parseFloat(operand);
          break;
        case "subtract":
          mathOut = parseFloat(key) - parseFloat(operand);
          break;
        case "multiply":
          mathOut = parseFloat(key) * parseFloat(operand);
          break;
        case "divide":
         if(operand === 0 || operand === -0) {
           _console.log("operand for divide operation is 0/-0: expect Nan/Infinity!");
         }
          mathOut = parseFloat(key) / parseFloat(operand);
          break;
        case "ceil":
          mathOut = Math.ceil(parseFloat(key));
          break;
        case "floor":
          mathOut = Math.floor(parseFloat(key));
          break;
        case "round":
          mathOut = Math.round(parseFloat(key));
          break;
        case "abs":
          mathOut = Math.abs(parseFloat(key));
          break;
        default:
          _console.log( "method passed is not supported" );
     }

      if (mathOut !== null){
        if (round) {
          mathOut = Math.round(mathOut);
        }
        if (bodies && bodies.block) {
          // with bodies act like the select helper with mathOut as the key
          // like the select helper bodies['else'] is meaningless and is ignored
          return chunk.render(bodies.block, context.push({ isSelect: true, isResolved: false, selectKey: mathOut }));
        } else {
          // self closing math helper will return the calculated output
          return chunk.write(mathOut);
        }
       } else {
        return chunk;
      }
    }
    // no key parameter and no method
    else {
      _console.log( "Key is a required parameter for math helper along with method/operand!" );
    }
    return chunk;
  },
   /**
   select helper works with one of the eq/ne/gt/gte/lt/lte/default providing the functionality
   of branching conditions
   @param key,  ( required ) either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   **/
  "select": function(chunk, context, bodies, params) {
    var body = bodies.block;
    // key is required for processing, hence check for defined
    if( params && typeof params.key !== "undefined"){
      // returns given input as output, if the input is not a dust reference, else does a context lookup
      var key = dust.helpers.tap(params.key, chunk, context);
      // bodies['else'] is meaningless and is ignored
      if( body ) {
       return chunk.render(bodies.block, context.push({ isSelect: true, isResolved: false, selectKey: key }));
      }
      else {
       _console.log( "Missing body block in the select helper ");
       return chunk;
      }
    }
    // no key
    else {
      _console.log( "No key given in the select helper!" );
    }
    return chunk;
  },

  /**
   eq helper compares the given key is same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "eq": function(chunk, context, bodies, params) {
    if(params) {
      params.filterOpType = "eq";
    }
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual === expected; });
  },

  /**
   ne helper compares the given key is not the same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "ne": function(chunk, context, bodies, params) {
    if(params) {
      params.filterOpType = "ne";
      return filter(chunk, context, bodies, params, function(expected, actual) { return actual !== expected; });
    }
   return chunk;
  },

  /**
   lt helper compares the given key is less than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "lt": function(chunk, context, bodies, params) {
     if(params) {
       params.filterOpType = "lt";
       return filter(chunk, context, bodies, params, function(expected, actual) { return actual < expected; });
     }
  },

  /**
   lte helper compares the given key is less or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
  **/
  "lte": function(chunk, context, bodies, params) {
     if(params) {
       params.filterOpType = "lte";
       return filter(chunk, context, bodies, params, function(expected, actual) { return actual <= expected; });
     }
    return chunk;
  },


  /**
   gt helper compares the given key is greater than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "gt": function(chunk, context, bodies, params) {
    // if no params do no go further
    if(params) {
      params.filterOpType = "gt";
      return filter(chunk, context, bodies, params, function(expected, actual) { return actual > expected; });
    }
    return chunk;
  },

 /**
   gte helper, compares the given key is greater than or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
  **/
  "gte": function(chunk, context, bodies, params) {
     if(params) {
      params.filterOpType = "gte";
      return filter(chunk, context, bodies, params, function(expected, actual) { return actual >= expected; });
     }
    return chunk; 
  },

  // to be used in conjunction with the select helper
  // TODO: fix the helper to do nothing when used standalone
  "default": function(chunk, context, bodies, params) {
    // does not require any params
     if(params) {
        params.filterOpType = "default";
      }
     return filter(chunk, context, bodies, params, function(expected, actual) { return true; });
  },

  /**
  * size helper prints the size of the given key
  * Note : size helper is self closing and does not support bodies
  * @param key, the element whose size is returned
  */
  "size": function( chunk, context, bodies, params ) {
    var key, value=0, nr, k;
    params = params || {};
    key = params.key;
    if (!key || key === true) { //undefined, null, "", 0
      value = 0;
    }
    else if(dust.isArray(key)) { //array
      value = key.length;
    }
    else if (!isNaN(parseFloat(key)) && isFinite(key)) { //numeric values
      value = key;
    }
    else if (typeof key  === "object") { //object test
      //objects, null and array all have typeof ojbect...
      //null and array are already tested so typeof is sufficient http://jsperf.com/isobject-tests
      nr = 0;
      for(k in key){
        if(Object.hasOwnProperty.call(key,k)){
          nr++;
        }
      }
      value = nr;
    } else {
      value = (key + '').length; //any other value (strings etc.)
    }
    return chunk.write(value);
  }
  
  
};

dust.helpers = helpers;

})(typeof exports !== 'undefined' ? module.exports = require('dustjs-linkedin') : dust);

//! moment.js
//! version : 2.5.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function(a){function b(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function c(a,b){return function(c){return k(a.call(this,c),b)}}function d(a,b){return function(c){return this.lang().ordinal(a.call(this,c),b)}}function e(){}function f(a){w(a),h(this,a)}function g(a){var b=q(a),c=b.year||0,d=b.month||0,e=b.week||0,f=b.day||0,g=b.hour||0,h=b.minute||0,i=b.second||0,j=b.millisecond||0;this._milliseconds=+j+1e3*i+6e4*h+36e5*g,this._days=+f+7*e,this._months=+d+12*c,this._data={},this._bubble()}function h(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return b.hasOwnProperty("toString")&&(a.toString=b.toString),b.hasOwnProperty("valueOf")&&(a.valueOf=b.valueOf),a}function i(a){var b,c={};for(b in a)a.hasOwnProperty(b)&&qb.hasOwnProperty(b)&&(c[b]=a[b]);return c}function j(a){return 0>a?Math.ceil(a):Math.floor(a)}function k(a,b,c){for(var d=""+Math.abs(a),e=a>=0;d.length<b;)d="0"+d;return(e?c?"+":"":"-")+d}function l(a,b,c,d){var e,f,g=b._milliseconds,h=b._days,i=b._months;g&&a._d.setTime(+a._d+g*c),(h||i)&&(e=a.minute(),f=a.hour()),h&&a.date(a.date()+h*c),i&&a.month(a.month()+i*c),g&&!d&&db.updateOffset(a),(h||i)&&(a.minute(e),a.hour(f))}function m(a){return"[object Array]"===Object.prototype.toString.call(a)}function n(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}function o(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&s(a[d])!==s(b[d]))&&g++;return g+f}function p(a){if(a){var b=a.toLowerCase().replace(/(.)s$/,"$1");a=Tb[a]||Ub[b]||b}return a}function q(a){var b,c,d={};for(c in a)a.hasOwnProperty(c)&&(b=p(c),b&&(d[b]=a[c]));return d}function r(b){var c,d;if(0===b.indexOf("week"))c=7,d="day";else{if(0!==b.indexOf("month"))return;c=12,d="month"}db[b]=function(e,f){var g,h,i=db.fn._lang[b],j=[];if("number"==typeof e&&(f=e,e=a),h=function(a){var b=db().utc().set(d,a);return i.call(db.fn._lang,b,e||"")},null!=f)return h(f);for(g=0;c>g;g++)j.push(h(g));return j}}function s(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function t(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function u(a){return v(a)?366:365}function v(a){return a%4===0&&a%100!==0||a%400===0}function w(a){var b;a._a&&-2===a._pf.overflow&&(b=a._a[jb]<0||a._a[jb]>11?jb:a._a[kb]<1||a._a[kb]>t(a._a[ib],a._a[jb])?kb:a._a[lb]<0||a._a[lb]>23?lb:a._a[mb]<0||a._a[mb]>59?mb:a._a[nb]<0||a._a[nb]>59?nb:a._a[ob]<0||a._a[ob]>999?ob:-1,a._pf._overflowDayOfYear&&(ib>b||b>kb)&&(b=kb),a._pf.overflow=b)}function x(a){return null==a._isValid&&(a._isValid=!isNaN(a._d.getTime())&&a._pf.overflow<0&&!a._pf.empty&&!a._pf.invalidMonth&&!a._pf.nullInput&&!a._pf.invalidFormat&&!a._pf.userInvalidated,a._strict&&(a._isValid=a._isValid&&0===a._pf.charsLeftOver&&0===a._pf.unusedTokens.length)),a._isValid}function y(a){return a?a.toLowerCase().replace("_","-"):a}function z(a,b){return b._isUTC?db(a).zone(b._offset||0):db(a).local()}function A(a,b){return b.abbr=a,pb[a]||(pb[a]=new e),pb[a].set(b),pb[a]}function B(a){delete pb[a]}function C(a){var b,c,d,e,f=0,g=function(a){if(!pb[a]&&rb)try{require("./lang/"+a)}catch(b){}return pb[a]};if(!a)return db.fn._lang;if(!m(a)){if(c=g(a))return c;a=[a]}for(;f<a.length;){for(e=y(a[f]).split("-"),b=e.length,d=y(a[f+1]),d=d?d.split("-"):null;b>0;){if(c=g(e.slice(0,b).join("-")))return c;if(d&&d.length>=b&&o(e,d,!0)>=b-1)break;b--}f++}return db.fn._lang}function D(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function E(a){var b,c,d=a.match(vb);for(b=0,c=d.length;c>b;b++)d[b]=Yb[d[b]]?Yb[d[b]]:D(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function F(a,b){return a.isValid()?(b=G(b,a.lang()),Vb[b]||(Vb[b]=E(b)),Vb[b](a)):a.lang().invalidDate()}function G(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(wb.lastIndex=0;d>=0&&wb.test(a);)a=a.replace(wb,c),wb.lastIndex=0,d-=1;return a}function H(a,b){var c,d=b._strict;switch(a){case"DDDD":return Ib;case"YYYY":case"GGGG":case"gggg":return d?Jb:zb;case"Y":case"G":case"g":return Lb;case"YYYYYY":case"YYYYY":case"GGGGG":case"ggggg":return d?Kb:Ab;case"S":if(d)return Gb;case"SS":if(d)return Hb;case"SSS":if(d)return Ib;case"DDD":return yb;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":return Cb;case"a":case"A":return C(b._l)._meridiemParse;case"X":return Fb;case"Z":case"ZZ":return Db;case"T":return Eb;case"SSSS":return Bb;case"MM":case"DD":case"YY":case"GG":case"gg":case"HH":case"hh":case"mm":case"ss":case"ww":case"WW":return d?Hb:xb;case"M":case"D":case"d":case"H":case"h":case"m":case"s":case"w":case"W":case"e":case"E":return xb;default:return c=new RegExp(P(O(a.replace("\\","")),"i"))}}function I(a){a=a||"";var b=a.match(Db)||[],c=b[b.length-1]||[],d=(c+"").match(Qb)||["-",0,0],e=+(60*d[1])+s(d[2]);return"+"===d[0]?-e:e}function J(a,b,c){var d,e=c._a;switch(a){case"M":case"MM":null!=b&&(e[jb]=s(b)-1);break;case"MMM":case"MMMM":d=C(c._l).monthsParse(b),null!=d?e[jb]=d:c._pf.invalidMonth=b;break;case"D":case"DD":null!=b&&(e[kb]=s(b));break;case"DDD":case"DDDD":null!=b&&(c._dayOfYear=s(b));break;case"YY":e[ib]=s(b)+(s(b)>68?1900:2e3);break;case"YYYY":case"YYYYY":case"YYYYYY":e[ib]=s(b);break;case"a":case"A":c._isPm=C(c._l).isPM(b);break;case"H":case"HH":case"h":case"hh":e[lb]=s(b);break;case"m":case"mm":e[mb]=s(b);break;case"s":case"ss":e[nb]=s(b);break;case"S":case"SS":case"SSS":case"SSSS":e[ob]=s(1e3*("0."+b));break;case"X":c._d=new Date(1e3*parseFloat(b));break;case"Z":case"ZZ":c._useUTC=!0,c._tzm=I(b);break;case"w":case"ww":case"W":case"WW":case"d":case"dd":case"ddd":case"dddd":case"e":case"E":a=a.substr(0,1);case"gg":case"gggg":case"GG":case"GGGG":case"GGGGG":a=a.substr(0,2),b&&(c._w=c._w||{},c._w[a]=b)}}function K(a){var b,c,d,e,f,g,h,i,j,k,l=[];if(!a._d){for(d=M(a),a._w&&null==a._a[kb]&&null==a._a[jb]&&(f=function(b){var c=parseInt(b,10);return b?b.length<3?c>68?1900+c:2e3+c:c:null==a._a[ib]?db().weekYear():a._a[ib]},g=a._w,null!=g.GG||null!=g.W||null!=g.E?h=Z(f(g.GG),g.W||1,g.E,4,1):(i=C(a._l),j=null!=g.d?V(g.d,i):null!=g.e?parseInt(g.e,10)+i._week.dow:0,k=parseInt(g.w,10)||1,null!=g.d&&j<i._week.dow&&k++,h=Z(f(g.gg),k,j,i._week.doy,i._week.dow)),a._a[ib]=h.year,a._dayOfYear=h.dayOfYear),a._dayOfYear&&(e=null==a._a[ib]?d[ib]:a._a[ib],a._dayOfYear>u(e)&&(a._pf._overflowDayOfYear=!0),c=U(e,0,a._dayOfYear),a._a[jb]=c.getUTCMonth(),a._a[kb]=c.getUTCDate()),b=0;3>b&&null==a._a[b];++b)a._a[b]=l[b]=d[b];for(;7>b;b++)a._a[b]=l[b]=null==a._a[b]?2===b?1:0:a._a[b];l[lb]+=s((a._tzm||0)/60),l[mb]+=s((a._tzm||0)%60),a._d=(a._useUTC?U:T).apply(null,l)}}function L(a){var b;a._d||(b=q(a._i),a._a=[b.year,b.month,b.day,b.hour,b.minute,b.second,b.millisecond],K(a))}function M(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function N(a){a._a=[],a._pf.empty=!0;var b,c,d,e,f,g=C(a._l),h=""+a._i,i=h.length,j=0;for(d=G(a._f,g).match(vb)||[],b=0;b<d.length;b++)e=d[b],c=(h.match(H(e,a))||[])[0],c&&(f=h.substr(0,h.indexOf(c)),f.length>0&&a._pf.unusedInput.push(f),h=h.slice(h.indexOf(c)+c.length),j+=c.length),Yb[e]?(c?a._pf.empty=!1:a._pf.unusedTokens.push(e),J(e,c,a)):a._strict&&!c&&a._pf.unusedTokens.push(e);a._pf.charsLeftOver=i-j,h.length>0&&a._pf.unusedInput.push(h),a._isPm&&a._a[lb]<12&&(a._a[lb]+=12),a._isPm===!1&&12===a._a[lb]&&(a._a[lb]=0),K(a),w(a)}function O(a){return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e})}function P(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function Q(a){var c,d,e,f,g;if(0===a._f.length)return a._pf.invalidFormat=!0,a._d=new Date(0/0),void 0;for(f=0;f<a._f.length;f++)g=0,c=h({},a),c._pf=b(),c._f=a._f[f],N(c),x(c)&&(g+=c._pf.charsLeftOver,g+=10*c._pf.unusedTokens.length,c._pf.score=g,(null==e||e>g)&&(e=g,d=c));h(a,d||c)}function R(a){var b,c,d=a._i,e=Mb.exec(d);if(e){for(a._pf.iso=!0,b=0,c=Ob.length;c>b;b++)if(Ob[b][1].exec(d)){a._f=Ob[b][0]+(e[6]||" ");break}for(b=0,c=Pb.length;c>b;b++)if(Pb[b][1].exec(d)){a._f+=Pb[b][0];break}d.match(Db)&&(a._f+="Z"),N(a)}else a._d=new Date(d)}function S(b){var c=b._i,d=sb.exec(c);c===a?b._d=new Date:d?b._d=new Date(+d[1]):"string"==typeof c?R(b):m(c)?(b._a=c.slice(0),K(b)):n(c)?b._d=new Date(+c):"object"==typeof c?L(b):b._d=new Date(c)}function T(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function U(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function V(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function W(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function X(a,b,c){var d=hb(Math.abs(a)/1e3),e=hb(d/60),f=hb(e/60),g=hb(f/24),h=hb(g/365),i=45>d&&["s",d]||1===e&&["m"]||45>e&&["mm",e]||1===f&&["h"]||22>f&&["hh",f]||1===g&&["d"]||25>=g&&["dd",g]||45>=g&&["M"]||345>g&&["MM",hb(g/30)]||1===h&&["y"]||["yy",h];return i[2]=b,i[3]=a>0,i[4]=c,W.apply({},i)}function Y(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=db(a).add("d",f),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function Z(a,b,c,d,e){var f,g,h=U(a,0,1).getUTCDay();return c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:u(a-1)+g}}function $(a){var b=a._i,c=a._f;return null===b?db.invalid({nullInput:!0}):("string"==typeof b&&(a._i=b=C().preparse(b)),db.isMoment(b)?(a=i(b),a._d=new Date(+b._d)):c?m(c)?Q(a):N(a):S(a),new f(a))}function _(a,b){db.fn[a]=db.fn[a+"s"]=function(a){var c=this._isUTC?"UTC":"";return null!=a?(this._d["set"+c+b](a),db.updateOffset(this),this):this._d["get"+c+b]()}}function ab(a){db.duration.fn[a]=function(){return this._data[a]}}function bb(a,b){db.duration.fn["as"+a]=function(){return+this/b}}function cb(a){var b=!1,c=db;"undefined"==typeof ender&&(a?(gb.moment=function(){return!b&&console&&console.warn&&(b=!0,console.warn("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.")),c.apply(null,arguments)},h(gb.moment,c)):gb.moment=db)}for(var db,eb,fb="2.5.1",gb=this,hb=Math.round,ib=0,jb=1,kb=2,lb=3,mb=4,nb=5,ob=6,pb={},qb={_isAMomentObject:null,_i:null,_f:null,_l:null,_strict:null,_isUTC:null,_offset:null,_pf:null,_lang:null},rb="undefined"!=typeof module&&module.exports&&"undefined"!=typeof require,sb=/^\/?Date\((\-?\d+)/i,tb=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,ub=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,vb=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,wb=/(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,xb=/\d\d?/,yb=/\d{1,3}/,zb=/\d{1,4}/,Ab=/[+\-]?\d{1,6}/,Bb=/\d+/,Cb=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Db=/Z|[\+\-]\d\d:?\d\d/gi,Eb=/T/i,Fb=/[\+\-]?\d+(\.\d{1,3})?/,Gb=/\d/,Hb=/\d\d/,Ib=/\d{3}/,Jb=/\d{4}/,Kb=/[+-]?\d{6}/,Lb=/[+-]?\d+/,Mb=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Nb="YYYY-MM-DDTHH:mm:ssZ",Ob=[["YYYYYY-MM-DD",/[+-]\d{6}-\d{2}-\d{2}/],["YYYY-MM-DD",/\d{4}-\d{2}-\d{2}/],["GGGG-[W]WW-E",/\d{4}-W\d{2}-\d/],["GGGG-[W]WW",/\d{4}-W\d{2}/],["YYYY-DDD",/\d{4}-\d{3}/]],Pb=[["HH:mm:ss.SSSS",/(T| )\d\d:\d\d:\d\d\.\d{1,3}/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],Qb=/([\+\-]|\d\d)/gi,Rb="Date|Hours|Minutes|Seconds|Milliseconds".split("|"),Sb={Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6},Tb={ms:"millisecond",s:"second",m:"minute",h:"hour",d:"day",D:"date",w:"week",W:"isoWeek",M:"month",y:"year",DDD:"dayOfYear",e:"weekday",E:"isoWeekday",gg:"weekYear",GG:"isoWeekYear"},Ub={dayofyear:"dayOfYear",isoweekday:"isoWeekday",isoweek:"isoWeek",weekyear:"weekYear",isoweekyear:"isoWeekYear"},Vb={},Wb="DDD w W M D d".split(" "),Xb="M D H h m s w W".split(" "),Yb={M:function(){return this.month()+1},MMM:function(a){return this.lang().monthsShort(this,a)},MMMM:function(a){return this.lang().months(this,a)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(a){return this.lang().weekdaysMin(this,a)},ddd:function(a){return this.lang().weekdaysShort(this,a)},dddd:function(a){return this.lang().weekdays(this,a)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return k(this.year()%100,2)},YYYY:function(){return k(this.year(),4)},YYYYY:function(){return k(this.year(),5)},YYYYYY:function(){var a=this.year(),b=a>=0?"+":"-";return b+k(Math.abs(a),6)},gg:function(){return k(this.weekYear()%100,2)},gggg:function(){return k(this.weekYear(),4)},ggggg:function(){return k(this.weekYear(),5)},GG:function(){return k(this.isoWeekYear()%100,2)},GGGG:function(){return k(this.isoWeekYear(),4)},GGGGG:function(){return k(this.isoWeekYear(),5)},e:function(){return this.weekday()},E:function(){return this.isoWeekday()},a:function(){return this.lang().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.lang().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return s(this.milliseconds()/100)},SS:function(){return k(s(this.milliseconds()/10),2)},SSS:function(){return k(this.milliseconds(),3)},SSSS:function(){return k(this.milliseconds(),3)},Z:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+k(s(a/60),2)+":"+k(s(a)%60,2)},ZZ:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+k(s(a/60),2)+k(s(a)%60,2)},z:function(){return this.zoneAbbr()},zz:function(){return this.zoneName()},X:function(){return this.unix()},Q:function(){return this.quarter()}},Zb=["months","monthsShort","weekdays","weekdaysShort","weekdaysMin"];Wb.length;)eb=Wb.pop(),Yb[eb+"o"]=d(Yb[eb],eb);for(;Xb.length;)eb=Xb.pop(),Yb[eb+eb]=c(Yb[eb],2);for(Yb.DDDD=c(Yb.DDD,3),h(e.prototype,{set:function(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(a){return this._months[a.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(a){return this._monthsShort[a.month()]},monthsParse:function(a){var b,c,d;for(this._monthsParse||(this._monthsParse=[]),b=0;12>b;b++)if(this._monthsParse[b]||(c=db.utc([2e3,b]),d="^"+this.months(c,"")+"|^"+this.monthsShort(c,""),this._monthsParse[b]=new RegExp(d.replace(".",""),"i")),this._monthsParse[b].test(a))return b},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(a){return this._weekdays[a.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(a){return this._weekdaysShort[a.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(a){return this._weekdaysMin[a.day()]},weekdaysParse:function(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=db([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b},_longDateFormat:{LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D YYYY",LLL:"MMMM D YYYY LT",LLLL:"dddd, MMMM D YYYY LT"},longDateFormat:function(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b},isPM:function(a){return"p"===(a+"").toLowerCase().charAt(0)},_meridiemParse:/[ap]\.?m?\.?/i,meridiem:function(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},calendar:function(a,b){var c=this._calendar[a];return"function"==typeof c?c.apply(b):c},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)},pastFuture:function(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)},ordinal:function(a){return this._ordinal.replace("%d",a)},_ordinal:"%d",preparse:function(a){return a},postformat:function(a){return a},week:function(a){return Y(a,this._week.dow,this._week.doy).week},_week:{dow:0,doy:6},_invalidDate:"Invalid date",invalidDate:function(){return this._invalidDate}}),db=function(c,d,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._i=c,g._f=d,g._l=e,g._strict=f,g._isUTC=!1,g._pf=b(),$(g)},db.utc=function(c,d,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._useUTC=!0,g._isUTC=!0,g._l=e,g._i=c,g._f=d,g._strict=f,g._pf=b(),$(g).utc()},db.unix=function(a){return db(1e3*a)},db.duration=function(a,b){var c,d,e,f=a,h=null;return db.isDuration(a)?f={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(f={},b?f[b]=a:f.milliseconds=a):(h=tb.exec(a))?(c="-"===h[1]?-1:1,f={y:0,d:s(h[kb])*c,h:s(h[lb])*c,m:s(h[mb])*c,s:s(h[nb])*c,ms:s(h[ob])*c}):(h=ub.exec(a))&&(c="-"===h[1]?-1:1,e=function(a){var b=a&&parseFloat(a.replace(",","."));return(isNaN(b)?0:b)*c},f={y:e(h[2]),M:e(h[3]),d:e(h[4]),h:e(h[5]),m:e(h[6]),s:e(h[7]),w:e(h[8])}),d=new g(f),db.isDuration(a)&&a.hasOwnProperty("_lang")&&(d._lang=a._lang),d},db.version=fb,db.defaultFormat=Nb,db.updateOffset=function(){},db.lang=function(a,b){var c;return a?(b?A(y(a),b):null===b?(B(a),a="en"):pb[a]||C(a),c=db.duration.fn._lang=db.fn._lang=C(a),c._abbr):db.fn._lang._abbr},db.langData=function(a){return a&&a._lang&&a._lang._abbr&&(a=a._lang._abbr),C(a)},db.isMoment=function(a){return a instanceof f||null!=a&&a.hasOwnProperty("_isAMomentObject")},db.isDuration=function(a){return a instanceof g},eb=Zb.length-1;eb>=0;--eb)r(Zb[eb]);for(db.normalizeUnits=function(a){return p(a)},db.invalid=function(a){var b=db.utc(0/0);return null!=a?h(b._pf,a):b._pf.userInvalidated=!0,b},db.parseZone=function(a){return db(a).parseZone()},h(db.fn=f.prototype,{clone:function(){return db(this)},valueOf:function(){return+this._d+6e4*(this._offset||0)},unix:function(){return Math.floor(+this/1e3)},toString:function(){return this.clone().lang("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._offset?new Date(+this):this._d},toISOString:function(){var a=db(this).utc();return 0<a.year()&&a.year()<=9999?F(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):F(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var a=this;return[a.year(),a.month(),a.date(),a.hours(),a.minutes(),a.seconds(),a.milliseconds()]},isValid:function(){return x(this)},isDSTShifted:function(){return this._a?this.isValid()&&o(this._a,(this._isUTC?db.utc(this._a):db(this._a)).toArray())>0:!1},parsingFlags:function(){return h({},this._pf)},invalidAt:function(){return this._pf.overflow},utc:function(){return this.zone(0)},local:function(){return this.zone(0),this._isUTC=!1,this},format:function(a){var b=F(this,a||db.defaultFormat);return this.lang().postformat(b)},add:function(a,b){var c;return c="string"==typeof a?db.duration(+b,a):db.duration(a,b),l(this,c,1),this},subtract:function(a,b){var c;return c="string"==typeof a?db.duration(+b,a):db.duration(a,b),l(this,c,-1),this},diff:function(a,b,c){var d,e,f=z(a,this),g=6e4*(this.zone()-f.zone());return b=p(b),"year"===b||"month"===b?(d=432e5*(this.daysInMonth()+f.daysInMonth()),e=12*(this.year()-f.year())+(this.month()-f.month()),e+=(this-db(this).startOf("month")-(f-db(f).startOf("month")))/d,e-=6e4*(this.zone()-db(this).startOf("month").zone()-(f.zone()-db(f).startOf("month").zone()))/d,"year"===b&&(e/=12)):(d=this-f,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-g)/864e5:"week"===b?(d-g)/6048e5:d),c?e:j(e)},from:function(a,b){return db.duration(this.diff(a)).lang(this.lang()._abbr).humanize(!b)},fromNow:function(a){return this.from(db(),a)},calendar:function(){var a=z(db(),this).startOf("day"),b=this.diff(a,"days",!0),c=-6>b?"sameElse":-1>b?"lastWeek":0>b?"lastDay":1>b?"sameDay":2>b?"nextDay":7>b?"nextWeek":"sameElse";return this.format(this.lang().calendar(c,this))},isLeapYear:function(){return v(this.year())},isDST:function(){return this.zone()<this.clone().month(0).zone()||this.zone()<this.clone().month(5).zone()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=V(a,this.lang()),this.add({d:a-b})):b},month:function(a){var b,c=this._isUTC?"UTC":"";return null!=a?"string"==typeof a&&(a=this.lang().monthsParse(a),"number"!=typeof a)?this:(b=this.date(),this.date(1),this._d["set"+c+"Month"](a),this.date(Math.min(b,this.daysInMonth())),db.updateOffset(this),this):this._d["get"+c+"Month"]()},startOf:function(a){switch(a=p(a)){case"year":this.month(0);case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a?this.weekday(0):"isoWeek"===a&&this.isoWeekday(1),this},endOf:function(a){return a=p(a),this.startOf(a).add("isoWeek"===a?"week":a,1).subtract("ms",1)},isAfter:function(a,b){return b="undefined"!=typeof b?b:"millisecond",+this.clone().startOf(b)>+db(a).startOf(b)},isBefore:function(a,b){return b="undefined"!=typeof b?b:"millisecond",+this.clone().startOf(b)<+db(a).startOf(b)},isSame:function(a,b){return b=b||"ms",+this.clone().startOf(b)===+z(a,this).startOf(b)},min:function(a){return a=db.apply(null,arguments),this>a?this:a},max:function(a){return a=db.apply(null,arguments),a>this?this:a},zone:function(a){var b=this._offset||0;return null==a?this._isUTC?b:this._d.getTimezoneOffset():("string"==typeof a&&(a=I(a)),Math.abs(a)<16&&(a=60*a),this._offset=a,this._isUTC=!0,b!==a&&l(this,db.duration(b-a,"m"),1,!0),this)},zoneAbbr:function(){return this._isUTC?"UTC":""},zoneName:function(){return this._isUTC?"Coordinated Universal Time":""},parseZone:function(){return this._tzm?this.zone(this._tzm):"string"==typeof this._i&&this.zone(this._i),this},hasAlignedHourOffset:function(a){return a=a?db(a).zone():0,(this.zone()-a)%60===0},daysInMonth:function(){return t(this.year(),this.month())},dayOfYear:function(a){var b=hb((db(this).startOf("day")-db(this).startOf("year"))/864e5)+1;return null==a?b:this.add("d",a-b)},quarter:function(){return Math.ceil((this.month()+1)/3)},weekYear:function(a){var b=Y(this,this.lang()._week.dow,this.lang()._week.doy).year;return null==a?b:this.add("y",a-b)},isoWeekYear:function(a){var b=Y(this,1,4).year;return null==a?b:this.add("y",a-b)},week:function(a){var b=this.lang().week(this);return null==a?b:this.add("d",7*(a-b))},isoWeek:function(a){var b=Y(this,1,4).week;return null==a?b:this.add("d",7*(a-b))},weekday:function(a){var b=(this.day()+7-this.lang()._week.dow)%7;return null==a?b:this.add("d",a-b)},isoWeekday:function(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)},get:function(a){return a=p(a),this[a]()},set:function(a,b){return a=p(a),"function"==typeof this[a]&&this[a](b),this},lang:function(b){return b===a?this._lang:(this._lang=C(b),this)}}),eb=0;eb<Rb.length;eb++)_(Rb[eb].toLowerCase().replace(/s$/,""),Rb[eb]);_("year","FullYear"),db.fn.days=db.fn.day,db.fn.months=db.fn.month,db.fn.weeks=db.fn.week,db.fn.isoWeeks=db.fn.isoWeek,db.fn.toJSON=db.fn.toISOString,h(db.duration.fn=g.prototype,{_bubble:function(){var a,b,c,d,e=this._milliseconds,f=this._days,g=this._months,h=this._data;h.milliseconds=e%1e3,a=j(e/1e3),h.seconds=a%60,b=j(a/60),h.minutes=b%60,c=j(b/60),h.hours=c%24,f+=j(c/24),h.days=f%30,g+=j(f/30),h.months=g%12,d=j(g/12),h.years=d},weeks:function(){return j(this.days()/7)},valueOf:function(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*s(this._months/12)},humanize:function(a){var b=+this,c=X(b,!a,this.lang());return a&&(c=this.lang().pastFuture(b,c)),this.lang().postformat(c)},add:function(a,b){var c=db.duration(a,b);return this._milliseconds+=c._milliseconds,this._days+=c._days,this._months+=c._months,this._bubble(),this},subtract:function(a,b){var c=db.duration(a,b);return this._milliseconds-=c._milliseconds,this._days-=c._days,this._months-=c._months,this._bubble(),this},get:function(a){return a=p(a),this[a.toLowerCase()+"s"]()},as:function(a){return a=p(a),this["as"+a.charAt(0).toUpperCase()+a.slice(1)+"s"]()},lang:db.fn.lang,toIsoString:function(){var a=Math.abs(this.years()),b=Math.abs(this.months()),c=Math.abs(this.days()),d=Math.abs(this.hours()),e=Math.abs(this.minutes()),f=Math.abs(this.seconds()+this.milliseconds()/1e3);return this.asSeconds()?(this.asSeconds()<0?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"}});for(eb in Sb)Sb.hasOwnProperty(eb)&&(bb(eb,Sb[eb]),ab(eb.toLowerCase()));bb("Weeks",6048e5),db.duration.fn.asMonths=function(){return(+this-31536e6*this.years())/2592e6+12*this.years()},db.lang("en",{ordinal:function(a){var b=a%10,c=1===s(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),rb?(module.exports=db,cb(!0)):"function"==typeof define&&define.amd?define("moment",function(b,c,d){return d.config&&d.config()&&d.config().noGlobal!==!0&&cb(d.config().noGlobal===a),db}):cb()}).call(this);
// moment.js language configuration
// language : canadian french (fr-ca)
// author : Jonathan Abourbih : https://github.com/jonbca

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    return moment.lang('fr-ca', {
        months : "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort : "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        weekdays : "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort : "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin : "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "YYYY-MM-DD",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY LT",
            LLLL : "dddd D MMMM YYYY LT"
        },
        calendar : {
            sameDay: "[Aujourd'hui ] LT",
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : "dans %s",
            past : "il y a %s",
            s : "quelques secondes",
            m : "une minute",
            mm : "%d minutes",
            h : "une heure",
            hh : "%d heures",
            d : "un jour",
            dd : "%d jours",
            M : "un mois",
            MM : "%d mois",
            y : "un an",
            yy : "%d ans"
        },
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        }
    });
}));

(function($){
    $.fn.removeClassByPrefix = function(prefix) {
        return this.each(function() {
            var regExp = new RegExp('\\b' + prefix + '.*?\\b', 'g');

            this.className = this.className.replace(regExp, '');
        });
    };
})(jQuery);
/* Copyright (c) 2010-2013 Marcus Westin */
(function(e){function o(){try{return r in e&&e[r]}catch(t){return!1}}var t={},n=e.document,r="localStorage",i="script",s;t.disabled=!1,t.set=function(e,t){},t.get=function(e){},t.remove=function(e){},t.clear=function(){},t.transact=function(e,n,r){var i=t.get(e);r==null&&(r=n,n=null),typeof i=="undefined"&&(i=n||{}),r(i),t.set(e,i)},t.getAll=function(){},t.forEach=function(){},t.serialize=function(e){return JSON.stringify(e)},t.deserialize=function(e){if(typeof e!="string")return undefined;try{return JSON.parse(e)}catch(t){return e||undefined}};if(o())s=e[r],t.set=function(e,n){return n===undefined?t.remove(e):(s.setItem(e,t.serialize(n)),n)},t.get=function(e){return t.deserialize(s.getItem(e))},t.remove=function(e){s.removeItem(e)},t.clear=function(){s.clear()},t.getAll=function(){var e={};return t.forEach(function(t,n){e[t]=n}),e},t.forEach=function(e){for(var n=0;n<s.length;n++){var r=s.key(n);e(r,t.get(r))}};else if(n.documentElement.addBehavior){var u,a;try{a=new ActiveXObject("htmlfile"),a.open(),a.write("<"+i+">document.w=window</"+i+'><iframe src="/favicon.ico"></iframe>'),a.close(),u=a.w.frames[0].document,s=u.createElement("div")}catch(f){s=n.createElement("div"),u=n.body}function l(e){return function(){var n=Array.prototype.slice.call(arguments,0);n.unshift(s),u.appendChild(s),s.addBehavior("#default#userData"),s.load(r);var i=e.apply(t,n);return u.removeChild(s),i}}var c=new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]","g");function h(e){return e.replace(/^d/,"___$&").replace(c,"___")}t.set=l(function(e,n,i){return n=h(n),i===undefined?t.remove(n):(e.setAttribute(n,t.serialize(i)),e.save(r),i)}),t.get=l(function(e,n){return n=h(n),t.deserialize(e.getAttribute(n))}),t.remove=l(function(e,t){t=h(t),e.removeAttribute(t),e.save(r)}),t.clear=l(function(e){var t=e.XMLDocument.documentElement.attributes;e.load(r);for(var n=0,i;i=t[n];n++)e.removeAttribute(i.name);e.save(r)}),t.getAll=function(e){var n={};return t.forEach(function(e,t){n[e]=t}),n},t.forEach=l(function(e,n){var r=e.XMLDocument.documentElement.attributes;for(var i=0,s;s=r[i];++i)n(s.name,t.deserialize(e.getAttribute(s.name)))})}try{var p="__storejs__";t.set(p,p),t.get(p)!=p&&(t.disabled=!0),t.remove(p)}catch(f){t.disabled=!0}t.enabled=!t.disabled,typeof module!="undefined"&&module.exports&&this.module!==module?module.exports=t:typeof define=="function"&&define.amd?define(t):e.store=t})(Function("return this")())
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.2
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/


/**
 * Instantiate fast-clicking listeners on the specified layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
function FastClick(layer, options) {
	'use strict';
	var oldOnClick;

	options = options || {};

	/**
	 * Whether a click is currently being tracked.
	 *
	 * @type boolean
	 */
	this.trackingClick = false;


	/**
	 * Timestamp for when click tracking started.
	 *
	 * @type number
	 */
	this.trackingClickStart = 0;


	/**
	 * The element being tracked for a click.
	 *
	 * @type EventTarget
	 */
	this.targetElement = null;


	/**
	 * X-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartX = 0;


	/**
	 * Y-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartY = 0;


	/**
	 * ID of the last touch, retrieved from Touch.identifier.
	 *
	 * @type number
	 */
	this.lastTouchIdentifier = 0;


	/**
	 * Touchmove boundary, beyond which a click will be cancelled.
	 *
	 * @type number
	 */
	this.touchBoundary = options.touchBoundary || 10;


	/**
	 * The FastClick layer.
	 *
	 * @type Element
	 */
	this.layer = layer;

	/**
	 * The minimum time between tap(touchstart and touchend) events
	 *
	 * @type number
	 */
	this.tapDelay = options.tapDelay || 200;

	if (FastClick.notNeeded(layer)) {
		return;
	}

	// Some old versions of Android don't have Function.prototype.bind
	function bind(method, context) {
		return function() { return method.apply(context, arguments); };
	}


	var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
	var context = this;
	for (var i = 0, l = methods.length; i < l; i++) {
		context[methods[i]] = bind(context[methods[i]], context);
	}

	// Set up event handlers as required
	if (deviceIsAndroid) {
		layer.addEventListener('mouseover', this.onMouse, true);
		layer.addEventListener('mousedown', this.onMouse, true);
		layer.addEventListener('mouseup', this.onMouse, true);
	}

	layer.addEventListener('click', this.onClick, true);
	layer.addEventListener('touchstart', this.onTouchStart, false);
	layer.addEventListener('touchmove', this.onTouchMove, false);
	layer.addEventListener('touchend', this.onTouchEnd, false);
	layer.addEventListener('touchcancel', this.onTouchCancel, false);

	// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
	// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
	// layer when they are cancelled.
	if (!Event.prototype.stopImmediatePropagation) {
		layer.removeEventListener = function(type, callback, capture) {
			var rmv = Node.prototype.removeEventListener;
			if (type === 'click') {
				rmv.call(layer, type, callback.hijacked || callback, capture);
			} else {
				rmv.call(layer, type, callback, capture);
			}
		};

		layer.addEventListener = function(type, callback, capture) {
			var adv = Node.prototype.addEventListener;
			if (type === 'click') {
				adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
					if (!event.propagationStopped) {
						callback(event);
					}
				}), capture);
			} else {
				adv.call(layer, type, callback, capture);
			}
		};
	}

	// If a handler is already declared in the element's onclick attribute, it will be fired before
	// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
	// adding it as listener.
	if (typeof layer.onclick === 'function') {

		// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
		// - the old one won't work if passed to addEventListener directly.
		oldOnClick = layer.onclick;
		layer.addEventListener('click', function(event) {
			oldOnClick(event);
		}, false);
		layer.onclick = null;
	}
}


/**
 * Android requires exceptions.
 *
 * @type boolean
 */
var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;


/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);


/**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);


/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {

	// Don't send a synthetic click to disabled inputs (issue #62)
	case 'button':
	case 'select':
	case 'textarea':
		if (target.disabled) {
			return true;
		}

		break;
	case 'input':

		// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
		if ((deviceIsIOS && target.type === 'file') || target.disabled) {
			return true;
		}

		break;
	case 'label':
	case 'video':
		return true;
	}

	return (/\bneedsclick\b/).test(target.className);
};


/**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {
	case 'textarea':
		return true;
	case 'select':
		return !deviceIsAndroid;
	case 'input':
		switch (target.type) {
		case 'button':
		case 'checkbox':
		case 'file':
		case 'image':
		case 'radio':
		case 'submit':
			return false;
		}

		// No point in attempting to focus disabled inputs
		return !target.disabled && !target.readOnly;
	default:
		return (/\bneedsfocus\b/).test(target.className);
	}
};


/**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
	'use strict';
	var clickEvent, touch;

	// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
	if (document.activeElement && document.activeElement !== targetElement) {
		document.activeElement.blur();
	}

	touch = event.changedTouches[0];

	// Synthesise a click event, with an extra attribute so it can be tracked
	clickEvent = document.createEvent('MouseEvents');
	clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	clickEvent.forwardedTouchEvent = true;
	targetElement.dispatchEvent(clickEvent);
};

FastClick.prototype.determineEventType = function(targetElement) {
	'use strict';

	//Issue #159: Android Chrome Select Box does not open with a synthetic click event
	if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
		return 'mousedown';
	}

	return 'click';
};


/**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
	'use strict';
	var length;

	// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
	if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
		length = targetElement.value.length;
		targetElement.setSelectionRange(length, length);
	} else {
		targetElement.focus();
	}
};


/**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
	'use strict';
	var scrollParent, parentElement;

	scrollParent = targetElement.fastClickScrollParent;

	// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
	// target element was moved to another parent.
	if (!scrollParent || !scrollParent.contains(targetElement)) {
		parentElement = targetElement;
		do {
			if (parentElement.scrollHeight > parentElement.offsetHeight) {
				scrollParent = parentElement;
				targetElement.fastClickScrollParent = parentElement;
				break;
			}

			parentElement = parentElement.parentElement;
		} while (parentElement);
	}

	// Always update the scroll top tracker if possible.
	if (scrollParent) {
		scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
	}
};


/**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	'use strict';

	// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
	if (eventTarget.nodeType === Node.TEXT_NODE) {
		return eventTarget.parentNode;
	}

	return eventTarget;
};


/**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
	'use strict';
	var targetElement, touch, selection;

	// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
	if (event.targetTouches.length > 1) {
		return true;
	}

	targetElement = this.getTargetElementFromEventTarget(event.target);
	touch = event.targetTouches[0];

	if (deviceIsIOS) {

		// Only trusted events will deselect text on iOS (issue #49)
		selection = window.getSelection();
		if (selection.rangeCount && !selection.isCollapsed) {
			return true;
		}

		if (!deviceIsIOS4) {

			// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
			// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
			// with the same identifier as the touch event that previously triggered the click that triggered the alert.
			// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
			// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
			if (touch.identifier === this.lastTouchIdentifier) {
				event.preventDefault();
				return false;
			}

			this.lastTouchIdentifier = touch.identifier;

			// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
			// 1) the user does a fling scroll on the scrollable layer
			// 2) the user stops the fling scroll with another tap
			// then the event.target of the last 'touchend' event will be the element that was under the user's finger
			// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
			// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
			this.updateScrollParent(targetElement);
		}
	}

	this.trackingClick = true;
	this.trackingClickStart = event.timeStamp;
	this.targetElement = targetElement;

	this.touchStartX = touch.pageX;
	this.touchStartY = touch.pageY;

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		event.preventDefault();
	}

	return true;
};


/**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
	'use strict';
	var touch = event.changedTouches[0], boundary = this.touchBoundary;

	if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
		return true;
	}

	return false;
};


/**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
	'use strict';
	if (!this.trackingClick) {
		return true;
	}

	// If the touch has moved, cancel the click tracking
	if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
		this.trackingClick = false;
		this.targetElement = null;
	}

	return true;
};


/**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
	'use strict';

	// Fast path for newer browsers supporting the HTML5 control attribute
	if (labelElement.control !== undefined) {
		return labelElement.control;
	}

	// All browsers under test that support touch events also support the HTML5 htmlFor attribute
	if (labelElement.htmlFor) {
		return document.getElementById(labelElement.htmlFor);
	}

	// If no for attribute exists, attempt to retrieve the first labellable descendant element
	// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
	return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
};


/**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
	'use strict';
	var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

	if (!this.trackingClick) {
		return true;
	}

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		this.cancelNextClick = true;
		return true;
	}

	// Reset to prevent wrong click cancel on input (issue #156).
	this.cancelNextClick = false;

	this.lastClickTime = event.timeStamp;

	trackingClickStart = this.trackingClickStart;
	this.trackingClick = false;
	this.trackingClickStart = 0;

	// On some iOS devices, the targetElement supplied with the event is invalid if the layer
	// is performing a transition or scroll, and has to be re-detected manually. Note that
	// for this to function correctly, it must be called *after* the event target is checked!
	// See issue #57; also filed as rdar://13048589 .
	if (deviceIsIOSWithBadTarget) {
		touch = event.changedTouches[0];

		// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
		targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
		targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
	}

	targetTagName = targetElement.tagName.toLowerCase();
	if (targetTagName === 'label') {
		forElement = this.findControl(targetElement);
		if (forElement) {
			this.focus(targetElement);
			if (deviceIsAndroid) {
				return false;
			}

			targetElement = forElement;
		}
	} else if (this.needsFocus(targetElement)) {

		// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
		// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
		if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
			this.targetElement = null;
			return false;
		}

		this.focus(targetElement);
		this.sendClick(targetElement, event);

		// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
		// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
		if (!deviceIsIOS || targetTagName !== 'select') {
			this.targetElement = null;
			event.preventDefault();
		}

		return false;
	}

	if (deviceIsIOS && !deviceIsIOS4) {

		// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
		// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
		scrollParent = targetElement.fastClickScrollParent;
		if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
			return true;
		}
	}

	// Prevent the actual click from going though - unless the target node is marked as requiring
	// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
	if (!this.needsClick(targetElement)) {
		event.preventDefault();
		this.sendClick(targetElement, event);
	}

	return false;
};


/**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
	'use strict';
	this.trackingClick = false;
	this.targetElement = null;
};


/**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
	'use strict';

	// If a target element was never set (because a touch event was never fired) allow the event
	if (!this.targetElement) {
		return true;
	}

	if (event.forwardedTouchEvent) {
		return true;
	}

	// Programmatically generated events targeting a specific element should be permitted
	if (!event.cancelable) {
		return true;
	}

	// Derive and check the target element to see whether the mouse event needs to be permitted;
	// unless explicitly enabled, prevent non-touch click events from triggering actions,
	// to prevent ghost/doubleclicks.
	if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

		// Prevent any user-added listeners declared on FastClick element from being fired.
		if (event.stopImmediatePropagation) {
			event.stopImmediatePropagation();
		} else {

			// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			event.propagationStopped = true;
		}

		// Cancel the event
		event.stopPropagation();
		event.preventDefault();

		return false;
	}

	// If the mouse event is permitted, return true for the action to go through.
	return true;
};


/**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
	'use strict';
	var permitted;

	// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
	if (this.trackingClick) {
		this.targetElement = null;
		this.trackingClick = false;
		return true;
	}

	// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
	if (event.target.type === 'submit' && event.detail === 0) {
		return true;
	}

	permitted = this.onMouse(event);

	// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
	if (!permitted) {
		this.targetElement = null;
	}

	// If clicks are permitted, return true for the action to go through.
	return permitted;
};


/**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
	'use strict';
	var layer = this.layer;

	if (deviceIsAndroid) {
		layer.removeEventListener('mouseover', this.onMouse, true);
		layer.removeEventListener('mousedown', this.onMouse, true);
		layer.removeEventListener('mouseup', this.onMouse, true);
	}

	layer.removeEventListener('click', this.onClick, true);
	layer.removeEventListener('touchstart', this.onTouchStart, false);
	layer.removeEventListener('touchmove', this.onTouchMove, false);
	layer.removeEventListener('touchend', this.onTouchEnd, false);
	layer.removeEventListener('touchcancel', this.onTouchCancel, false);
};


/**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
	'use strict';
	var metaViewport;
	var chromeVersion;

	// Devices that don't support touch don't need FastClick
	if (typeof window.ontouchstart === 'undefined') {
		return true;
	}

	// Chrome version - zero for other browsers
	chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

	if (chromeVersion) {

		if (deviceIsAndroid) {
			metaViewport = document.querySelector('meta[name=viewport]');

			if (metaViewport) {
				// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
				if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
					return true;
				}
				// Chrome 32 and above with width=device-width or less don't need FastClick
				if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
					return true;
				}
			}

		// Chrome desktop doesn't need FastClick (issue #15)
		} else {
			return true;
		}
	}

	// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
	if (layer.style.msTouchAction === 'none') {
		return true;
	}

	return false;
};


/**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
FastClick.attach = function(layer, options) {
	'use strict';
	return new FastClick(layer, options);
};


if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {

	// AMD. Register as an anonymous module.
	define(function() {
		'use strict';
		return FastClick;
	});
} else if (typeof module !== 'undefined' && module.exports) {
	module.exports = FastClick.attach;
	module.exports.FastClick = FastClick;
} else {
	window.FastClick = FastClick;
}

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

/*!
 * Response   Responsive design toolkit
 * @link      http://responsejs.com
 * @author    Ryan Van Etten (c) 2011-2012
 * @license   MIT
 * @version   0.7.7
 * @requires  jQuery 1.7+
 *            -or- ender build jeesh (ender.jit.su)
 *            -or- zepto 0.8+ (zeptojs.com)
 */

/*jslint browser: true, devel: true, node: true, passfail: false, bitwise: true, continue: true
, debug: true, eqeq: true, es5: true, forin: true, newcap: true, nomen: true, plusplus: true
, regexp: true, undef: true, sloppy: true, stupid: true, sub: true, vars: true, white: true
, indent: 4, maxerr: 180 */

(function(root, name, factory) {// github.com/umdjs/umd

    var dep = root['jQuery'] || root['Zepto'] || root['ender'] || root['elo'];
    if ( typeof module != 'undefined' && module['exports'] ) {
        module['exports'] = factory(dep); // common / ender 
    } else { root[name] = factory(dep); } // browser

    // see @link github.com/ryanve/response.js/pull/9
    // AMD @example `define(['jquery'], factory)`
    
}(this, 'Response', function($) {

    if ( typeof $ != 'function' ) {
        try {// Exit gracefully if dependency is missing:
            console.log('Response was unable to run due to missing dependency.');
        } catch (e) {}
    }

    // Combine local vars/funcs into one statement:    

    var Response
      , root = this
      , name = 'Response'
      , old = root[name]
      , initContentKey = 'init' + name  // key for storing initial content
      , win = window
      , doc = document
      , docElem = doc.documentElement
      , ready = $.domReady || $
      , $win = $(win) // cache selector
      , screen = win.screen
      , owns = {}.hasOwnProperty
      , slice = [].slice
      , concat = [].concat
      , nativeMap = [].map
      , isArray = Array.isArray || function(ukn) { 
            return ukn instanceof Array; 
        }

      , map = nativeMap ? function(ob, fn, scope) {
            return nativeMap.call(ob, fn, scope);
        } : function(ob, fn, scope) {
            var i, l = ob.length, ret = [];
            for (i = 0; i < l; i++) { 
                i in ob && (ret[i] = fn.call(scope, ob[i], i, ob)); 
            }
            return ret;
        }

      , defaultBreakpoints = {
            width: [0, 320, 481, 641, 961, 1025, 1281]  // width  | device-width  (ideal for 960 grids)
          , height: [0, 481]                            // height | device-height (maybe add 801 too)
          , ratio: [1, 1.5, 2]                          // device-pixel-ratio     (!omit trailing zeros!)
        }

        // these are defined later
      , Elemset, band, wave, device = {}
      , propTests = {}
      , isCustom = {}
      , sets = { all: [] }
      , suid = 1

        // responsejs.com/labs/dimensions/#device
        // device dims stay the same regardless of viewport size or rotation
      , screenW = screen.width   
      , screenH = screen.height  
      , screenMax = screenW > screenH ? screenW : screenH
      , screenMin = screenW + screenH - screenMax
      , deviceW = function() { return screenW; }
      , deviceH = function() { return screenH; }
      
        // cache expressions
      , regexFunkyPunc = /[^a-z0-9_\-\.]/gi
      , regexTrimPunc = /^[\W\s]+|[\W\s]+$|/g
      , regexCamels = /([a-z])([A-Z])/g
      , regexDashB4 = /-(.)/g
      , regexDataPrefix = /^data-(.+)$/
        
        // Local version of Object.create with polyfill that supports only the first arg.
        // It creates an empty object whose prototype is set to the specified proto param.
        // developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create
        // FYI there is a full polyfill @link github.com/kriskowal/es5-shim
        // This gets exposed as Response.object since 0.4.0

      , objectCreate = Object.create || function(proto) {
            /** @constructor */
            function Type() {}      // Function to output empty object.
            Type.prototype = proto; // Set prototype property to the proto.
            return new Type;        // Instantiate the new object.
        }

      , namespaceIt = function(eventName, customNamespace) {// namepace defaults to 'Response'
            customNamespace = customNamespace || name;
            return eventName.replace(regexTrimPunc, '') + '.' + customNamespace.replace(regexTrimPunc, '');
        }

      , event = {// Custom Events
            allLoaded: namespaceIt('allLoaded') // fires on lazy elemsets when all elems in a set have been loaded once
            //, update: namespaceIt('update')       // fires on each elem in a set each time that elem is updated
          , crossover: namespaceIt('crossover') // fires on window each time dynamic breakpoint bands is crossed
        }
        
        // Response.media (normalized matchMedia)
        // @example Response.media("(orientation:landscape)").matches
        // If both versions are undefined, .matches will equal undefined 
        // Also see: band / wave / device.band / device.wave / dpr
      , matchMedia = win.matchMedia || win.msMatchMedia
      , media = matchMedia || function() { return {}; }
    
        // @link responsejs.com/labs/dimensions/#viewport    
        // @link github.com/ryanve/response.js/issues/17
    
      , viewportW = (function(win, docElem, mM) {
            var client = docElem['clientWidth']
              , inner = win['innerWidth'];
            return ( mM && client < inner && true === mM('(min-width:' + inner + 'px)')['matches']
                ? function() { return win['innerWidth']; }
                : function() { return docElem['clientWidth']; }
            );
        }(win, docElem, matchMedia))
        
      , viewportH = (function(win, docElem, mM) {
            var client = docElem['clientHeight']
              , inner = win['innerHeight'];
            return ( mM && client < inner && true === mM('(min-height:' + inner + 'px)')['matches']
                ? function() { return win['innerHeight']; }
                : function() { return docElem['clientHeight']; }
            );
        }(win, docElem, matchMedia))

    ;
    
    function doError(msg) {
        // Error handling. (Throws exception.)
        // Use Ctrl+F to find specific @errors
        throw new TypeError(msg ? name + '.' + msg : name);
    }
    
    function isNumber(item) {// inlined @minification
        return typeof item == 'number' && item === item; // second part stuffs NaN
    }

    function ssvToArr(ukn) {
        // Convert space separated values to array. Always returns a compact array:
        return typeof ukn == 'string' ? sift(ukn.split(' ')) : isArray(ukn) ? sift(ukn) : [];
    }

    /**
     * Response.each()
     * @since    0.4.0
     * omits `in` check and supports scope since 0.6.2
     */
    function each(ob, callback, scope) {
        if ( null == ob ) { return ob; }
        var i = 0, len = ob.length;
        while ( i < len ) { 
            callback.call(scope || ob[i], ob[i], i++, ob); 
        }
        return ob; // chain
    }

    // revamped affix method reintroduced in version 0.4.0:
    // updated again in 0.6.2 to skip null|undef values
    function affix(arr, prefix, suffix) {
        // Return new array with prefix/suffix added to each value.
        // null|undefined values are not included in the new array
        var r = [], l = arr.length, i = 0, v;
        prefix = prefix || '';
        suffix = suffix || '';
        while ( i < l ) {
            v = arr[i++]; 
            null == v || r.push(prefix + v + suffix);
        }
        return r;
    }

    /**
     * @param  {Array|Object}          ob     is an array or collection to iterate over.
     * @param  {(Function|string|*)=}  fn     is a callback or typestring - callbacks receive (v, i, ob)
     * @param  {(Object|boolean|*)=}   scope  thisArg or invert
     */
    
    /**
     * Response.sift       Filter out array values that don't pass a callback,
     *                     or (if no callback provided) filter out falsey values.
     *                     Similar (but more capable that) jQuery.grep or the native [].filter
     *
     * @since   0.4.0      Updated in 0.6.2 to support scope and typestrings
     * @example Response.sift([5, 0, 'seven'], isFinite)    // [5, 0]
     * @example Response.sift([5, 0, '', undefined, null])  // [5]
     *
     */
    function sift(ob, fn, scope) {

        var l, u = 0, i = 0, v, ret = [], invert, isF = typeof fn == 'function';
        if ( !ob ) { return ret; }
        scope = (invert = true === scope) ? null : scope;

        for ( l = ob.length; i < l; i++ ) {
            v = ob[i]; // save reference to value in case `fn` mutates `ob[i]`
            // Use `=== !` to ensure that the comparison is bool-to-bool
            invert === !(isF ? fn.call(scope, v, i, ob) : fn ? typeof v === fn : v) && (ret[u++] = v);
        }
        return ret;
    }

    /**
     * Response.merge
     * @since 0.3.0
     * Generic method for merging objects and/or arrays.
     * Undefined values in `adds` are skipped.
     * When `adds` is array-like, this behaves similar to jQuery.merge(base, adds)
     * Otherwise it behaves similar to jQuery.extend(base, adds)
     * @param   {Object|Array|Function|*}  base
     * @param   {Object|Array|Function|*}  adds
     */
    function merge(base, adds) {
        var k, l;
        if ( !base || !adds ) { return base; }
        if ( typeof adds != 'function' && isNumber(l = adds.length) ) {
            for ( k = 0; k < l; k++ ) {
                void 0 === adds[k] || (base[k] = adds[k]);
            }
            base.length > k || (base.length = k); // non-arrays
        } else {
            for ( k in adds ) {
                owns.call(adds, k) && void 0 !== adds[k] && (base[k] = adds[k]);
            }
        }
        return base;
    }

    /**
     * Response.route()             Handler method for accepting args as arrays or singles, for 
     *                              callbacks. Returns self for chaining.
     *
     * @since   0.3.0               (scope support added in 0.6.2)
     *
     * @param   {*}         item    If `item` is an array or array-like object then `callback` gets called
     *                              on each member. Otherwise `callback` is called on the `item` itself.
     * @param   {Function}  fn      The function to call on item(s).
     * @param   {*=}        scope   thisArg (defaults to current item)
     */
    function route(item, fn, scope) {
        // If item is array-like then call the callback on each item. Otherwise call directly on item.
        if ( null == item ) { return item; } // Skip null|undefined
        if ( typeof item == 'object' && !item.nodeType && isNumber(item.length) ) { 
            each(item, fn, scope); 
        } else {
            fn.call(scope || item, item); 
        }
        return item; // chainable
    }

    /**
     * ranger()                Make a range comparison tester.
     * @param  {Function}  fn  gets a value to compare against
     * @return {Function}
     */        
    function ranger(fn) {
        /**
         * @param {string|number}    min
         * @param {(string|number)=} max
         */
        return function(min, max) {
            var n = fn();
            min = n >= (min || 0);
            return max ? min && n <= max : min;        
        };
    }

    /** 
     * Range comparison booleans
     * @link responsejs.com/#booleans
     */
    band = ranger(viewportW);      // Response.band
    wave = ranger(viewportH);      // Response.wave
    device.band = ranger(deviceW); // Response.device.band
    device.wave = ranger(deviceH); // Response.device.wave
    
    /**
     * Response.dpr(decimal)         Tests if a minimum device pixel ratio is active. 
     *                               Or (version added in 0.3.0) returns the device-pixel-ratio
     * @param    number    decimal   is the integer or float to test.
     * @return   boolean|number
     * @example  Response.dpr();     // get the device-pixel-ratio (or 0 if undetectable)
     * @example  Response.dpr(1.5);  // true when device-pixel-ratio is 1.5+
     * @example  Response.dpr(2);    // true when device-pixel-ratio is 2+
     */
    function dpr(decimal) {

        var dPR = win.devicePixelRatio;

        if ( null == decimal ) {//Return exact value or kinda iterate for approx:
            return dPR || (dpr(2) ? 2 : dpr(1.5) ? 1.5 : dpr(1) ? 1 : 0);
        }

        if ( !isFinite(decimal) ) {// Shh. Actually allows numeric strings too. ;)
            return false;
        }

        // Use window.devicePixelRatio if supported - supported by Webkit 
        // (Safari/Chrome/Android) and Presto 2.8+ (Opera) browsers.         

        if ( dPR && dPR > 0 ) {
            return dPR >= decimal; 
        }

        // Fallback to .matchMedia/.msMatchMedia. Supported by Gecko (FF6+) and more:
        // @link developer.mozilla.org/en/DOM/window.matchMedia
        // -webkit-min- and -o-min- omitted (Webkit/Opera supported above)
        // The generic min-device-pixel-ratio is expected to be added to the W3 spec.
        // Return false if neither method is available.

        decimal = 'only all and (min--moz-device-pixel-ratio:' + decimal + ')';
        if ( media(decimal).matches ) { return true; }
        return !!media(decimal.replace('-moz-', '')).matches;
    }


    /**
     * Response.camelize       Converts data-pulp-fiction to pulpFiction
     *                         via camelize @link github.com/ded/bonzo
     *                         Used in dataset methods.
     *
     * @example   Response.camelize('data-casa-blanca')  // casaBlanca
     */
    function camelize(s) {
        // Remove data- prefix and convert remaining dashed string to camelCase:
        return s.replace(regexDataPrefix, '$1').replace(regexDashB4, function(m, m1) {
            return m1.toUpperCase();
        });
    }

    /**
     * Response.datatize       Converts pulpFiction (or data-pulpFiction) to data-pulp-fiction
     *                         Adapted from decamelize @link github.com/ded/bonzo
     *                         Used in dataset methods.
     *
     * @example   Response.datatize('casaBlanca')  // data-casa-blanca
     */
    function datatize(s) {
        // Make sure there's no data- already in s for it to work right in IE8.
        return 'data-' + (s ? s.replace(regexDataPrefix, '$1').replace(regexCamels, '$1-$2').toLowerCase() : s);
    }

    /**
     * Response.render                Converts stringified primitives back to JavaScript.
     *                                Adapted from dataValue() @link github.com/ded/bonzo
     * @since   0.3.0
     *
     * @param   string|other    s     String to render back to its correct JavaScript value.
     *                                If s is not a string then it is returned unaffected. 
     * @return  converted data
     *
     */
    function render(s) {
        var n; // < undefined
        return ( !s || typeof s != 'string' ? s              // unchanged
                        : 'true' === s      ? true           // convert "true" to true
                        : 'false' === s     ? false          // convert "false" to false
                        : 'undefined' === s ? n              // convert "undefined" to undefined
                        : 'null' === s      ? null           // convert "null" to null
                        : (n = parseFloat(s)) === +n ? n     // convert "1000" to 1000
                        : s                                  // unchanged
        );
    }
    
    // Isolate native element:
    function getNative(e) {
        // stackoverflow.com/questions/9119823/safest-way-to-detect-native-dom-element
        // See @link jsperf.com/get-native
        // If e is a native element then return it. If not check if index 0 exists and is
        // a native elem. If so then return that. Otherwise return false.
        return !e ? false : e.nodeType === 1 ? e : e[0] && e[0].nodeType === 1 ? e[0] : false;
    }


    /**
     * .dataset()          Cross browser implementation of HTML5 dataset
     *                     The chainable syntax is disabled by default and can be 
     *                     enabled by calling Response.chain() (See Response.chain)
     *
     * @since 0.3.0
     * 
     * Chainable form:  $('div').dataset(key)               // get (from first matched element)
     *                  $('div').dataset([key])             // get and render (See Response.render)
     *                  $('div').dataset(key, value)        // set (sets all matched elems)
     *                  $('div').dataset({k1:val, k2:val})  // set multiple attrs at once (on all matched elems)
     *                  $('div').deletes(keys)              // delete attrs (space-separated string)
     * 
     * Non-chainable:   Response.dataset(elem, key)               // get (elem can be native or jQuery elem)
     *                  Response.dataset(elem, [key])             // get and render (See Response.render)
     *                  Response.dataset(elem, key, value)        // set
     *                  Response.dataset(elem, {k1:val, k2:val})  // set multiple attrs at once
     *                  Response.deletes(elem, keys)              // delete attrs (space-separated string)
     * 
     */
    function datasetChainable(key, value) {

        var numOfArgs = arguments.length
          , elem = getNative(this)
          , ret = {}
          , renderData = false
          , n;

        if ( numOfArgs ) {
                
            if ( isArray(key) ) {
                renderData = true;
                key = key[0];
            }
    
            if ( typeof key === 'string' ) {

                key = datatize(key);

                if ( 1 === numOfArgs ) {//GET
                    ret = elem.getAttribute(key);
                    return renderData ? render(ret) : ret;
                }

                if ( this === elem || 2 > (n = this.length || 1) ) {//SET single elem
                    elem.setAttribute(key, value);
                } else {//SET for group of selected elems
                    while( n-- ) {// n starts as # of elems in selector and stops at 0
                        if (n in this) {
                            datasetChainable.apply(this[n], arguments);
                        }
                    }
                }
            } else if ( key instanceof Object ) {//SET
                for (n in key) {
                    key.hasOwnProperty(n) && datasetChainable.call(this, n, key[n]);
                }
            }
                
            return this; // chain

        }//1 or more args

        // ** Zero args **
        // Return object containing all the data attributes.
        // Use the native dataset when available:
            
        if ( elem.dataset && DOMStringMap ) {
           return elem.dataset;
        }
            
        // adapted from Bonzo @link github.com/ded/bonzo/blob/master/bonzo.js
        each(elem.attributes, function(a) {
            if (a && (n = String(a.name).match(regexDataPrefix))) {
                ret[camelize(n[1])] = a.value;
            }
        });

        return ret; // plain object

    }
        
    /**
     * .deletes()
     * @since 0.3.0
     */
    function deletesChainable(keys) {
        if (this && typeof keys === 'string') {
            keys = ssvToArr(keys);
            route(this, function(el) {
                each(keys, function(key) {
                    if (key) {
                        el.removeAttribute(datatize(key));
                    }
                });
            });
        }
        return this;
    }

    /**
     * Response.dataset()        See datasetChainable above
     *                           This is the non-chainable version. It grabs the thisArg
     *                           and calls the chainable version
     *
     * @since 0.3.0
     */
    function dataset(elem, key, value) {
        return datasetChainable.apply(elem, slice.call(arguments, 1));
    }

    /**
     * Response.deletes(elem, keys)           Delete HTML5 data attributes (remove them from them DOM)
     * 
     * @since 0.3.0
     *                             Where native DOM dataset is supported you can do: `delete elem.dataset.foo`
     * 
     * @param   object   elem     is a native element or jQuery object e.g. document.body or $('body')
     * 
     * @param   string   keys     one or more space-separated data attribute keys (names) to delete (removed
     *                            from the DOM) Should be camelCased or lowercase.
     * 
     * @example  Response.deletes(document.body, 'casaBlanca movie'); // Removes data-casa-blanca and data-movie
     *                                                                // from the <body> element.
     * 
     * @example  Response.deletes($(div), 'casaBlanca movie')         // Removes data-casa-blanca and data-movie
     *                                                                // from all divs.
     */
    function deletes(elem, keys) {
        return deletesChainable.call(elem, keys);
    }
    
    function selectify(keys) {
        // Convert an array of data keys into a selector string
        // Converts ["a","b","c"] into "[data-a],[data-b],[data-c]"
        // Double-slash escapes periods so that attrs like data-density-1.5 will work
        // @link api.jquery.com/category/selectors/
        // @link github.com/jquery/sizzle/issues/76
        var k, r = [], i = 0, l = keys.length;
        while ( i < l ) {
            (k = keys[i++]) && r.push('[' + datatize(k.replace(regexTrimPunc, '').replace('.', '\\.')) + ']');
        }
        return r.join();
    }


    /**
     * Response.target()           Get the corresponding data attributes for an array of data keys.
     * @since    0.1.9
     * @param    array     keys    is the array of data keys whose attributes you want to select.
     * @return   object            jQuery selector
     * @example  Response.target(['a', 'b', 'c'])  //  $('[data-a],[data-b],[data-c]')
     * @example  Response.target('a b c'])         //  $('[data-a],[data-b],[data-c]')
     */
    function target(keys) {
        return $(selectify(ssvToArr(keys)));    
    }

    // Cross-browser versions of window.scrollX and window.scrollY
    // Compatibiliy notes @link developer.mozilla.org/en/DOM/window.scrollY
    // Performance tests @link jsperf.com/scrollx-cross-browser-compatible
    // Using native here b/c Zepto doesn't support .scrollLeft() /scrollTop()
    // In jQuery you can do $(window).scrollLeft() and $(window).scrollTop()

    /** 
     * Response.scrollX()     Cross-browser version of window.scrollX
     * @since   0.3.0
     * @return  integer
     */
    function scrollX() {
        return window.pageXOffset || docElem.scrollLeft; 
    }

    /** 
     * Response.scrollY()     Cross-browser version of window.scrollY
     * @since   0.3.0
     * @return  integer
     */
    function scrollY() { 
        return window.pageYOffset || docElem.scrollTop; 
    }

    /**
     * area methods inX/inY/inViewport
     * @since   0.3.0
     */
    function rectangle(el, verge) {
        // Local handler for area methods:
        // adapted from github.com/ryanve/dime
        // The native object is read-only so we 
        // have use a copy in order to modify it.
        var r = el.getBoundingClientRect ? el.getBoundingClientRect() : {};
        verge = typeof verge == 'number' ? verge || 0 : 0;
        return {
            top: (r.top || 0) - verge
          , left: (r.left || 0) - verge
          , bottom: (r.bottom || 0) + verge
          , right: (r.right || 0) + verge
        };
    }
         
    // The verge is the amount of pixels to act as a cushion around the viewport. It can be any 
    // integer. If verge is zero, then the inX/inY/inViewport methods are exact. If verge is set to 100, 
    // then those methods return true when for elements that are are in the viewport *or* near it, 
    // with *near* being defined as within 100 pixels outside the viewport edge. Elements immediately 
    // outside the viewport are 'on the verge' of being scrolled to.

    function inX(elem, verge) {
        var r = rectangle(getNative(elem), verge);
        return !!r && r.right >= 0 && r.left <= viewportW();
    }

    function inY(elem, verge) {
        var r = rectangle(getNative(elem), verge);
        return !!r && r.bottom >= 0 && r.top <= viewportH();
    }

    function inViewport(elem, verge) {
        // equiv to: inX(elem, verge) && inY(elem, verge)
        // But just manually do both to avoid calling rectangle() and getNative() twice.
        // It actually gzips smaller this way too:
        var r = rectangle(getNative(elem), verge);
        return !!r && r.bottom >= 0 && r.top <= viewportH() && r.right >= 0 && r.left <= viewportW();
    }
    
             
    function detectMode(elem) {

        // Detect whether elem should act in src or markup mode.
        // @param   elem      is a DOM element
        // @return  number
        // @link dev.w3.org/html5/spec-author-view/index.html#attributes-1
        // @link stackoverflow.com/q/8715689/770127
        // @link stackoverflow.com/a/4878963/770127
        // Normalize to lowercase to ensure compatibility across HTML/XHTML/XML.
        // These are the elems that can use src attr per the W3 spec:
            
        var srcElems = { img:1, input:1, source:3, embed:3, track:3, iframe:5, audio:5, video:5, script:5 }
          , modeID = srcElems[ elem.nodeName.toLowerCase() ] || -1;

        // -5 => markup mode for video/audio/iframe w/o src attr.
        // -1 => markup mode for any elem not in the array above.
        //  1 => src mode    for img/input (empty content model). Images.
        //  3 => src mode    for source/embed/track (empty content model). Media *or* time data.
        //  5 => src mode    for audio/video/iframe/script *with* src attr.
        //  If we at some point we need to differentiate <track> we'll use 4, but for now
        //  it's grouped with the other non-image empty content elems that use src.
        //  hasAttribute is not supported in IE7 so check elem.getAttribute('src')

        return 4 > modeID ? modeID : null != elem.getAttribute('src') ? 5 : -5;
    }

    /**
     * Response.store()
     * @since 0.1.9
     *
     * Store a data value on each elem targeted by a jQuery selector. We use this for storing an 
     * elem's orig (no-js) state. This gives us the ability to return the elem to its orig state.
     * The data it stores is either the src attr or the innerHTML based on result of detectMode().
     *
     * @param  {Object}  $elems  DOM element | jQuery object | nodeList | array of elements
     * @param  {string}  key     is the key to use to store the orig value w/ @link api.jquery.com/data/
     * @param  {string=} source  (@since 0.6.2) an optional attribute name to read data from
     *
     */
    function store($elems, key, source) {
    
        var valToStore;
        if ( !$elems || null == key) { doError('store'); }
        source = typeof source == 'string' && source;

        route($elems, function(el) {
            if ( source ) { valToStore = el.getAttribute(source); }
            else if ( 0 < detectMode(el) ) { valToStore = el.getAttribute('src'); }
            else { valToStore = el.innerHTML; }
            null == valToStore ? deletes(el, key) : dataset(el, key, valToStore); 
        });

        return Response;
    }

    /**
     * Response.access()               Access data-* values for element from an array of data-* keys. 
     * 
     * @since   0.1.9                 (added support for space-separated strings in 0.3.1)
     *
     * @param   object         elem   is a native or jQuery element whose values to access.
     * @param   array|string   keys   is an array or space-separated string of data keys whose 
     *                                values you want to access.
     *
     * @return  array                 of dataset values corresponding to each key. Since 0.4.0 if
     *                                the params are wrong then the return is an empty array.
     */
    function access(elem, keys) {
        // elem becomes thisArg for datasetChainable:
        var ret = [];
        elem && keys && each(ssvToArr(keys), function(k, i) {
            ret.push(dataset(elem, k));
        }, elem);
        return ret;
    }

    /**
     * Response.addTest
     *
     */
    function addTest(prop, fn) {
        if (typeof prop == 'string' && typeof fn == 'function') {
            propTests[prop] = fn;
            isCustom[prop] = 1;
        }
        return Response;
    }
        
    /*
     * Elemset   Prototype object for element sets used in Response.create
     *           Each element in the set inherits this as well, so some of the 
     *           methods apply to the set, while others apply to single elements.
     */
    Elemset = (function() {
    
        var crossover = event.crossover
          //, update = event.update
          , min = Math.min;

        // Techically data attributes names can contain uppercase in HTML, but, The DOM lowercases 
        // attributes, so they must be lowercase regardless when we target them in jQuery. Force them 
        // lowercase here to prevent issues. Removing all punc marks except for dashes, underscores,
        // and periods so that we don't have to worry about escaping anything crazy.
        // Rules @link dev.w3.org/html5/spec/Overview.html#custom-data-attribute
        // jQuery selectors @link api.jquery.com/category/selectors/ 
            
        function sanitize (key) {
            // Allow lowercase alphanumerics, dashes, underscores, and periods:
            return typeof key == 'string' ? key.toLowerCase().replace(regexFunkyPunc, '') : '';
        }

        return {
            $e: 0                     // object    jQuery object
          , mode: 0                   // integer   defined per element
          , breakpoints: null         // array     validated @ configure()
          , prefix: null              // string    validated @ configure()
          , prop: 'width'             // string    validated @ configure()
          , keys: []                  // array     defined @ configure()
          , dynamic: null             // boolean   defined @ configure()
          , custom: 0                 // boolean   see addTest()
          , values: []                // array     available values
          , fn: 0                     // callback  the test fn, defined @ configure()
          , verge: null               // integer   defaults to Math.min(screenMax, 500)
          , newValue: 0
          , currValue: 1
          , aka: null
          , lazy: null
          , i: 0                      // integer   the index of the current highest active breakpoint min
          , uid: null
              
          , reset: function() {// Reset / fire crossover events:
          
                var subjects = this.breakpoints
                  , i = subjects.length
                  , tempIndex = 0;
                
                // This is similar to the decideValue loop
                while( !tempIndex && i-- ) {
                    this.fn(subjects[i]) && (tempIndex = i);
                }

                // Fire the crossover event if crossover has occured:
                if (tempIndex !== this.i) {
                    $win.trigger(crossover) // fires for each set
                        .trigger(this.prop + crossover); // fires 
                    this.i = tempIndex || 0;
                }
            
                return this;           // chainable
            }

          , configure: function(options) {
          
                merge(this, options);
          
                var i, prefix, aliases, aliasKeys, isNumeric = true, arr, prop = this.prop;
                
                this.uid = suid++;

                this.verge = isFinite(this.verge) ? this.verge : min(screenMax, 500);
                    
                this.fn = propTests[prop] || doError('create @fn');

                // If we get to here then we know the prop is one one our supported props:
                // 'width', 'height', 'device-width', 'device-height', 'device-pixel-ratio'
                // device- props => NOT dynamic
                    
                if (typeof this.dynamic != 'boolean') {
                    this.dynamic = !!('device' !== prop.substring(0, 6));
                }
                
                this.custom = isCustom[prop];

                prefix = this.prefix ? sift(map(ssvToArr(this.prefix), sanitize)) : ['min-' + prop + '-'];
                aliases = 1 < prefix.length ? prefix.slice(1) : 0;
                this.prefix = prefix[0];
                
                arr = this.breakpoints;
                
                // Sort and validate (#valid8) custom breakpoints if supplied.
                // Must be done before keys are created so that the keys match:
                
                if ( isArray(arr) ) {// custom breakpoints
                            
                    each(arr, function(v) {
                        if ( !v && v !== 0 ) { throw 'invalid breakpoint'; } // null|undefined|''|NaN
                        isNumeric = isNumeric && isFinite(v);
                    });

                    arr = isNumeric ? arr.sort(function(a, b) {
                        return (a - b); // sort lowest to highest
                    }) : arr; 

                    arr.length || doError('create @breakpoints');
                    
                } else {// default breakpoints:
                    // The defaults are presorted so we can skip the need to sort when using the defaults. Omit
                    // trailing decimal zeros b/c for example if you put 1.0 as a devicePixelRatio breakpoint, 
                    // then the target would be data-pre1 (NOT data-pre1.0) so drop the zeros.
                    // If no breakpoints are supplied, then get the default breakpoints for the specified prop.
                    // Supported props: 'width', 'height', 'device-width', 'device-height', 'device-pixel-ratio'
                    arr = defaultBreakpoints[prop] || defaultBreakpoints[prop.split('-').pop()] || doError('create @prop'); 
                }

                // Remove breakpoints that are above the device's max dimension,
                // in order to reduce the number of iterations needed later.
                this.breakpoints = isNumeric ? sift(arr, function(n) { 
                    return n <= screenMax; 
                }) : arr;

                // Use the breakpoints array to create array of data keys:
                this.keys = affix(this.breakpoints, this.prefix);
                this.aka = null; // Reset to just in case a value was merged in.

                if ( aliases ) {// There may be one of more aliases:
                    aliasKeys = [];
                    i = aliases.length;
                    while ( i-- ) { aliasKeys.push(affix(this.breakpoints, aliases[i])); }
                    this.aka = aliasKeys; // this.aka is an array of arrays (one for each alias)
                    this.keys = concat.apply(this.keys, aliasKeys); // flatten aliases into this.keys
                }

                sets.all = sets.all.concat(sets[this.uid] = this.keys); // combined keys ===> sets.all
                
                return this; // chainable
            }

          , target: function() {// Stuff that can't happen until the DOM is ready:
                this.$e = $(selectify(sets[this.uid])); // Cache jQuery object for the set.
                store(this.$e, initContentKey);  // Store original (no-js) value to data key.
                this.keys.push(initContentKey);  // Add key onto end of keys array. (# keys now equals # breakpoints + 1)
                return this; // chainable
            }

            // The rest of the methods are designed for use with single elements.
            // They are for use in a cloned instances within a loop.

          , decideValue: function() {
                // Return the first value from the values array that passes the boolean
                // test callback. If none pass the test, then return the fallback value.
                // this.breakpoints.length === this.values.length + 1  
                // The extra member in the values array is the initContentKey value.
                var val = null
                  , subjects = this.breakpoints
                  , sL = subjects.length
                  , i = sL;

                while( val == null && i-- ) {
                    this.fn(subjects[i]) && (val = this.values[i]);
                }
                this.newValue = typeof val === 'string' ? val : this.values[sL];
                return this; // chainable
            }

          , prepareData: function(elem) {
             
                this.$e = $(elem);                // jQuery selector
                this.mode = detectMode(elem);     // Detect the mode of the element.
                this.values = access(this.$e, this.keys); // Access Response data- values for the element.
                    
                if (this.aka) {
                    var i = this.aka.length;
                    // If there are alias keys then there may be alias values. Merge the values from 
                    // all the aliases into the values array. The merge method only merges in truthy values
                    // and prevents falsey values from overwriting truthy ones. (See Response.merge)
                    while ( i-- ) {// loops down and stops at index 0
                        // Each of the this.aka arrays has the same length as the this.values
                        // array, so no new indexes will be added, just filled if there's truthy values.
                        this.values = merge(this.values, access(this.$e, this.aka[i]));
                    }
                }

                return this.decideValue();          // chainable
            }

          , updateDOM: function() {
                // Apply the method that performs the actual swap. When updateDOM called this.$e and this.e refer
                // to single elements. Only update the DOM when the new value is different than the current value.
                if (this.currValue === this.newValue) { return this; }
                this.currValue = this.newValue;
                if ( 0 < this.mode ) { 
                    this.$e[0].setAttribute('src', this.newValue); 
                } else if ( null == this.newValue ) { 
                    this.$e.empty && this.$e.empty(); 
                } else {
                    if (this.$e.html) {
                        this.$e.html(this.newValue); 
                    } else {
                        this.$e.empty && this.$e.empty();
                        this.$e[0].innerHTML = this.newValue;
                    }
                }
                // this.$e.trigger(update); // may add this event in future
                return this;
            }

        };//return
    }());//Elemset
    
    // The keys are the prop and the values are the method that tests that prop.
    // The props with dashes in them are added via array notation below.
    // Props marked as dynamic change when the viewport is resized:
    propTests['width'] = band;   // dynamic
    propTests['height'] = wave;  // dynamic
    propTests['device-width'] = device.band;
    propTests['device-height'] = device.wave;
    propTests['device-pixel-ratio'] = dpr;
    
    /**
     * Response.resize
     */
    function resize(fn) {
        $win.on('resize', fn);
        return Response; // chain
    }

    /**
     * Response.crossover
     *
     */
    
    function crossover(prop, fn) {
        var temp, eventToFire, eventCrossover = event.crossover;
        if (typeof prop == 'function') {// support args in reverse
            temp = fn;
            fn = prop;
            prop = temp;
        }
        eventToFire = prop ? ('' + prop + eventCrossover) : eventCrossover;
        $win.on(eventToFire, fn);
        return Response; // chain
    }

    /**
     * Response.action        A facade for calling functions on both the ready and resize events.
     *
     * @link     http://responsejs.com/#action
     * @since    0.1.3
     * @param    callback|array  action  is the callback name or array of callback names to call.
     *
     * @example  Response.action(myFunc1);            // call myFunc1() on ready/resize
     * @example  Response.action([myFunc1, myFunc2]); // call myFunc1(), myFunc2() ...
     */
    function action(fnOrArr) {
        route(fnOrArr, function(fn) {
            ready(fn);
            resize(fn);
        });
        return Response; // chain
    }
    
    /**
     * Response.create()              Create their own Response attribute sets, with custom 
     *                                breakpoints and data-* names.
     * @since    0.1.9
     *
     * @param    object|array   args   is an options object or an array of options objects.
     *
     * @link     http://responsejs.com/#create
     *
     * @example  Ideally this method is only called once:
     *           To create a single set,  use the form:  Response.create(object);
     *           To create multiple sets, use the form:  Response.create([object1, object2]); 
     */

    function create(args) {

        route(args, function(options) {

            typeof options == 'object' || doError('create @args');

            var elemset = objectCreate(Elemset).configure(options)
              , lowestNonZeroBP
              , verge = elemset.verge
              , breakpoints = elemset.breakpoints
              , scrollName = namespaceIt('scroll')
              , resizeName = namespaceIt('resize')
            ;

            if ( !breakpoints.length ) { return; }    // Quit if there are zero breakpoints.

            // Identify the lowest nonzero breakpoint. (They're already sorted low to high by now.)
            lowestNonZeroBP = breakpoints[0] || breakpoints[1] || false;
        
            ready(function() {                  // Ready. Yea mofo.

                var allLoaded = event.allLoaded
                  , lazy = !!elemset.lazy;

                // Target elements containing this set's Response data attributes and chain into the 
                // loop that occurs on ready. The selector is cached to elemset.$e for later use.

                each(elemset.target().$e, function(el, i) {
                    elemset[i] = objectCreate(elemset).prepareData(el);// Inherit from elemset
                    if (!lazy || inViewport(elemset[i].$e, verge)) {
                        // If not lazy update all the elems in the set. If
                        // lazy, only update elems in the current viewport.
                        elemset[i].updateDOM(); 
                    }
                });

                function resizeHandler() {   // Only runs for dynamic props.
                    elemset.reset();
                    each(elemset.$e, function(el, i) {// Reset and then loop thru the set.
                        elemset[i].decideValue().updateDOM(); // Grab elem object from cache and update all.
                    }).trigger(allLoaded);
                }

                // device-* props are static and only need to be tested once. The others are
                // dynamic, meaning they need to be tested on resize. Also if a device so small
                // that it doesn't support the lowestNonZeroBP then we don't need to listen for 
                // resize events b/c we know the device can't resize beyond that breakpoint.

                if (elemset.dynamic && (elemset.custom || lowestNonZeroBP < screenMax)) {
                   resize(resizeHandler, resizeName);
                }

                // We don't have to re-decide the content on scrolls because neither the viewport or device
                // properties change from a scroll. This setup minimizes the operations binded to the scroll 
                // event. Once everything in the set has been swapped once, the scroll handler is deactivated
                // through the use of a custom event.

                if ( !lazy ) { return; }

                function scrollHandler() {
                    each(elemset.$e, function(el, i) {
                        if (inViewport(elemset[i].$e, verge)) {
                            elemset[i].updateDOM();
                        }
                    });
                }

                $win.on(scrollName, scrollHandler);
                elemset.$e.one(allLoaded, function() {
                    $win.off(scrollName, scrollHandler);
                });

            });//ready
        });//route
        return Response; // chain
    }//create
    
    function noConflict(callback) {
        if ( root[name] === Response ) { root[name] = old; }
        if (typeof callback == 'function') { callback.call(root, Response); }
        return Response;
    }

    // Handler for adding inx/inY/inViewport to $.fn (or another prototype).
    function exposeAreaFilters(engine, proto, force) {
        each(['inX', 'inY', 'inViewport'], function(methodName) {
            (force || !proto[methodName]) && (proto[methodName] = function(verge, invert) {
                return engine(sift(this, function(el) {
                    return !!el && !invert === Response[methodName](el, verge); 
                }));
            });
        });
    }

    /**
     * Response.bridge
     * Bridges applicable methods into the specified host (e.g. jQuery)
     * @param {Function} host
     * @param {boolean=} force
     */
    function bridge(host, force) {

        if ( typeof host == 'function' && host.fn ) {

            // Expose .dataset() and .deletes() to jQuery:
            if (force || void 0 === host.fn.dataset) { 
                host.fn.dataset = datasetChainable; 
            }
            if (force || void 0 === host.fn.deletes) { 
                host.fn.deletes = deletesChainable; 
            }
            
            // Expose .inX() .inY() .inViewport()
            exposeAreaFilters(host, host.fn, force);
        }

        return Response;
    }
    
    /**
     * Response.chain
     * @since 0.3.0
     * @depreciated  ( Use Response.bridge instead. ) 
     */
    function chain (host, force) {
        host = arguments.length ? host : $;
        return bridge(host, force);
    }
    
    Response = { // Expose these as props/methods on Response:
        deviceMin: function() { return screenMin; }
      , deviceMax: function() { return screenMax; }
      //, sets: function(prop) {// must be uid
      //    return $(selectify(sets[prop] || sets.all));
      //}
      , noConflict: noConflict
      , chain: chain
      , bridge: bridge
      , create: create
      , addTest: addTest
      , datatize: datatize
      , camelize: camelize
      , render: render
      , store: store
      , access: access
      , target: target
      , object: objectCreate
      , crossover: crossover
      , action: action
      , resize: resize
      , ready: ready
      , affix: affix
      , sift: sift
      , dpr: dpr
      , deletes: deletes
      , scrollX: scrollX
      , scrollY: scrollY
      , deviceW: deviceW
      , deviceH: deviceH
      , device: device
      , inX: inX
      , inY: inY
      , route: route
      , merge: merge
      , media: media
      , wave: wave
      , band: band
      , map: map
      , each: each
      , inViewport: inViewport
      , dataset: dataset
      , viewportH: viewportH
      , viewportW: viewportW
    };// Response

    // Initialize
    ready(function() {
        var nativeJSONParse, customData = dataset(doc.body, 'responsejs');
        if ( customData ) {
            nativeJSONParse = !!win.JSON && JSON.parse;
            if ( nativeJSONParse ) {
                customData = nativeJSONParse(customData); 
            } else if ( $.parseJSON ) { 
                customData = $.parseJSON(customData); 
            }
            customData && customData.create && create(customData.create);
        }
        // Remove .no-responsejs class from html tag (if it's there) and add .responsejs
        docElem.className = docElem.className.replace(/(^|\s)(no-)?responsejs(\s|$)/, '$1$3') + ' responsejs ';
    });

    return Response;

}));
/*! Picturefill - Responsive Images that work today. (and mimic the proposed Picture element with span elements). Author: Scott Jehl, Filament Group, 2012 | License: MIT/GPLv2 */

(function( w ){

	// Enable strict mode
	"use strict";

	w.picturefill = function() {
		var ps = w.document.getElementsByTagName( "span" );

		// Loop the pictures
		for( var i = 0, il = ps.length; i < il; i++ ){
			if( ps[ i ].getAttribute( "data-picture" ) !== null ){

				var sources = ps[ i ].getElementsByTagName( "span" ),
					matches = [];

				// See if which sources match
				for( var j = 0, jl = sources.length; j < jl; j++ ){
					var media = sources[ j ].getAttribute( "data-media" );
					// if there's no media specified, OR w.matchMedia is supported 
					if( !media || ( w.matchMedia && w.matchMedia( media ).matches ) ){
						matches.push( sources[ j ] );
					}
				}

			// Find any existing img element in the picture element
			var picImg = ps[ i ].getElementsByTagName( "img" )[ 0 ];

			if( matches.length ){
				var matchedEl = matches.pop();
				if( !picImg ){
					picImg = w.document.createElement( "img" );
					picImg.alt = ps[ i ].getAttribute( "data-alt" );
				}

				picImg.src =  matchedEl.getAttribute( "data-src" );
				matchedEl.appendChild( picImg );
			}
			else if( picImg ){
				picImg.parentNode.removeChild( picImg );
			}
		}
		}
	};

	// Run on resize and domready (w.load as a fallback)
	if( w.addEventListener ){
		w.addEventListener( "resize", w.picturefill, false );
		w.addEventListener( "DOMContentLoaded", function(){
			w.picturefill();
			// Run once only
			w.removeEventListener( "load", w.picturefill, false );
		}, false );
		w.addEventListener( "load", w.picturefill, false );
	}
	else if( w.attachEvent ){
		w.attachEvent( "onload", w.picturefill );
	}

}( this ));
/*
 *	jQuery dotdotdot 1.7.2
 *
 *	Copyright (c) Fred Heusschen
 *	www.frebsite.nl
 *
 *	Plugin website:
 *	dotdotdot.frebsite.nl
 *
 *	Licensed under the MIT license.
 *	http://en.wikipedia.org/wiki/MIT_License
 */

(function( $, undef )
{
	if ( $.fn.dotdotdot )
	{
		return;
	}

	$.fn.dotdotdot = function( o )
	{
		if ( this.length == 0 )
		{
			$.fn.dotdotdot.debug( 'No element found for "' + this.selector + '".' );
			return this;
		}
		if ( this.length > 1 )
		{
			return this.each(
				function()
				{
					$(this).dotdotdot( o );
				}
			);
		}


		var $dot = this;

		if ( $dot.data( 'dotdotdot' ) )
		{
			$dot.trigger( 'destroy.dot' );
		}

		$dot.data( 'dotdotdot-style', $dot.attr( 'style' ) || '' );
		$dot.css( 'word-wrap', 'break-word' );
		if ($dot.css( 'white-space' ) === 'nowrap')
		{
			$dot.css( 'white-space', 'normal' );
		}

		$dot.bind_events = function()
		{
			$dot.bind(
				'update.dot',
				function( e, c )
				{
					e.preventDefault();
					e.stopPropagation();

					opts.maxHeight = ( typeof opts.height == 'number' )
						? opts.height
						: getTrueInnerHeight( $dot );

					opts.maxHeight += opts.tolerance;

					if ( typeof c != 'undefined' )
					{
						if ( typeof c == 'string' || c instanceof HTMLElement )
						{
							c = $('<div />').append( c ).contents();
						}
						if ( c instanceof $ )
						{
							orgContent = c;
						}
					}

					$inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
					$inr.contents()
						.detach()
						.end()
						.append( orgContent.clone( true ) )
						.find( 'br' )
						.replaceWith( '  <br />  ' )
						.end()
						.css({
							'height'	: 'auto',
							'width'		: 'auto',
							'border'	: 'none',
							'padding'	: 0,
							'margin'	: 0
						});

					var after = false,
						trunc = false;

					if ( conf.afterElement )
					{
						after = conf.afterElement.clone( true );
						after.show();
						conf.afterElement.detach();
					}

					if ( test( $inr, opts ) )
					{
						if ( opts.wrap == 'children' )
						{
							trunc = children( $inr, opts, after );
						}
						else
						{
							trunc = ellipsis( $inr, $dot, $inr, opts, after );
						}
					}
					$inr.replaceWith( $inr.contents() );
					$inr = null;

					if ( $.isFunction( opts.callback ) )
					{
						opts.callback.call( $dot[ 0 ], trunc, orgContent );
					}

					conf.isTruncated = trunc;
					return trunc;
				}

			).bind(
				'isTruncated.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], conf.isTruncated );
					}
					return conf.isTruncated;
				}

			).bind(
				'originalContent.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], orgContent );
					}
					return orgContent;
				}

			).bind(
				'destroy.dot',
				function( e )
				{
					e.preventDefault();
					e.stopPropagation();

					$dot.unwatch()
						.unbind_events()
						.contents()
						.detach()
						.end()
						.append( orgContent )
						.attr( 'style', $dot.data( 'dotdotdot-style' ) || '' )
						.data( 'dotdotdot', false );
				}
			);
			return $dot;
		};	//	/bind_events

		$dot.unbind_events = function()
		{
			$dot.unbind('.dot');
			return $dot;
		};	//	/unbind_events

		$dot.watch = function()
		{
			$dot.unwatch();
			if ( opts.watch == 'window' )
			{
				var $window = $(window),
					_wWidth = $window.width(),
					_wHeight = $window.height();

				$window.bind(
					'resize.dot' + conf.dotId,
					function()
					{
						if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
						{
							_wWidth = $window.width();
							_wHeight = $window.height();

							if ( watchInt )
							{
								clearInterval( watchInt );
							}
							watchInt = setTimeout(
								function()
								{
									$dot.trigger( 'update.dot' );
								}, 100
							);
						}
					}
				);
			}
			else
			{
				watchOrg = getSizes( $dot );
				watchInt = setInterval(
					function()
					{
						if ( $dot.is( ':visible' ) )
						{
							var watchNew = getSizes( $dot );
							if ( watchOrg.width  != watchNew.width ||
								watchOrg.height != watchNew.height )
							{
								$dot.trigger( 'update.dot' );
								watchOrg = watchNew;
							}
						}
					}, 500
				);
			}
			return $dot;
		};
		$dot.unwatch = function()
		{
			$(window).unbind( 'resize.dot' + conf.dotId );
			if ( watchInt )
			{
				clearInterval( watchInt );
			}
			return $dot;
		};

		var	orgContent	= $dot.contents(),
			opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
			conf		= {},
			watchOrg	= {},
			watchInt	= null,
			$inr		= null;


		if ( !( opts.lastCharacter.remove instanceof Array ) )
		{
			opts.lastCharacter.remove = $.fn.dotdotdot.defaultArrays.lastCharacter.remove;
		}
		if ( !( opts.lastCharacter.noEllipsis instanceof Array ) )
		{
			opts.lastCharacter.noEllipsis = $.fn.dotdotdot.defaultArrays.lastCharacter.noEllipsis;
		}


		conf.afterElement	= getElement( opts.after, $dot );
		conf.isTruncated	= false;
		conf.dotId			= dotId++;


		$dot.data( 'dotdotdot', true )
			.bind_events()
			.trigger( 'update.dot' );

		if ( opts.watch )
		{
			$dot.watch();
		}

		return $dot;
	};


	//	public
	$.fn.dotdotdot.defaults = {
		'ellipsis'			: '... ',
		'wrap'				: 'word',
		'fallbackToLetter'	: true,
		'lastCharacter'		: {},
		'tolerance'			: 0,
		'callback'			: null,
		'after'				: null,
		'height'			: null,
		'watch'				: false,
		'windowResizeFix'	: true
	};
	$.fn.dotdotdot.defaultArrays = {
		'lastCharacter'		: {
			'remove'			: [ ' ', '\u3000', ',', ';', '.', '!', '?' ],
			'noEllipsis'		: []
		}
	};
	$.fn.dotdotdot.debug = function( msg ) {};


	//	private
	var dotId = 1;

	function children( $elem, o, after )
	{
		var $elements 	= $elem.children(),
			isTruncated	= false;

		$elem.empty();

		for ( var a = 0, l = $elements.length; a < l; a++ )
		{
			var $e = $elements.eq( a );
			$elem.append( $e );
			if ( after )
			{
				$elem.append( after );
			}
			if ( test( $elem, o ) )
			{
				$e.remove();
				isTruncated = true;
				break;
			}
			else
			{
				if ( after )
				{
					after.detach();
				}
			}
		}
		return isTruncated;
	}
	function ellipsis( $elem, $d, $i, o, after )
	{
		var isTruncated	= false;

		//	Don't put the ellipsis directly inside these elements
		var notx = 'a table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, blockquote, select, optgroup, option, textarea, script, style';

		//	Don't remove these elements even if they are after the ellipsis
		var noty = 'script, .dotdotdot-keep';

		$elem
			.contents()
			.detach()
			.each(
			function()
			{

				var e	= this,
					$e	= $(e);

				if ( typeof e == 'undefined' || ( e.nodeType == 3 && $.trim( e.data ).length == 0 ) )
				{
					return true;
				}
				else if ( $e.is( noty ) )
				{
					$elem.append( $e );
				}
				else if ( isTruncated )
				{
					return true;
				}
				else
				{
					$elem.append( $e );
					if ( after && !$e.is( o.after ) && !$e.find( o.after ).length  )
					{
						$elem[ $elem.is( notx ) ? 'after' : 'append' ]( after );
					}
					if ( test( $i, o ) )
					{
						if ( e.nodeType == 3 ) // node is TEXT
						{
							isTruncated = ellipsisElement( $e, $d, $i, o, after );
						}
						else
						{
							isTruncated = ellipsis( $e, $d, $i, o, after );
						}

						if ( !isTruncated )
						{
							$e.detach();
							isTruncated = true;
						}
					}

					if ( !isTruncated )
					{
						if ( after )
						{
							after.detach();
						}
					}
				}
			}
		);

		return isTruncated;
	}
	function ellipsisElement( $e, $d, $i, o, after )
	{
		var e = $e[ 0 ];

		if ( !e )
		{
			return false;
		}

		var txt			= getTextContent( e ),
			space		= ( txt.indexOf(' ') !== -1 ) ? ' ' : '\u3000',
			separator	= ( o.wrap == 'letter' ) ? '' : space,
			textArr		= txt.split( separator ),
			position 	= -1,
			midPos		= -1,
			startPos	= 0,
			endPos		= textArr.length - 1;


		//	Only one word
		if ( o.fallbackToLetter && startPos == 0 && endPos == 0 )
		{
			separator	= '';
			textArr		= txt.split( separator );
			endPos		= textArr.length - 1;
		}

		while ( startPos <= endPos && !( startPos == 0 && endPos == 0 ) )
		{
			var m = Math.floor( ( startPos + endPos ) / 2 );
			if ( m == midPos )
			{
				break;
			}
			midPos = m;

			setTextContent( e, textArr.slice( 0, midPos + 1 ).join( separator ) + o.ellipsis );

			if ( !test( $i, o ) )
			{
				position = midPos;
				startPos = midPos;
			}
			else
			{
				endPos = midPos;

				//	Fallback to letter
				if (o.fallbackToLetter && startPos == 0 && endPos == 0 )
				{
					separator	= '';
					textArr		= textArr[ 0 ].split( separator );
					position	= -1;
					midPos		= -1;
					startPos	= 0;
					endPos		= textArr.length - 1;
				}
			}
		}

		if ( position != -1 && !( textArr.length == 1 && textArr[ 0 ].length == 0 ) )
		{
			txt = addEllipsis( textArr.slice( 0, position + 1 ).join( separator ), o );
			setTextContent( e, txt );
		}
		else
		{
			var $w = $e.parent();
			$e.detach();

			var afterLength = ( after && after.closest($w).length ) ? after.length : 0;

			if ( $w.contents().length > afterLength )
			{
				e = findLastTextNode( $w.contents().eq( -1 - afterLength ), $d );
			}
			else
			{
				e = findLastTextNode( $w, $d, true );
				if ( !afterLength )
				{
					$w.detach();
				}
			}
			if ( e )
			{
				txt = addEllipsis( getTextContent( e ), o );
				setTextContent( e, txt );
				if ( afterLength && after )
				{
					$(e).parent().append( after );
				}
			}
		}

		return true;
	}
	function test( $i, o )
	{
		return $i.innerHeight() > o.maxHeight;
	}
	function addEllipsis( txt, o )
	{
		while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
		{
			txt = txt.slice( 0, -1 );
		}
		if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
		{
			txt += o.ellipsis;
		}
		return txt;
	}
	function getSizes( $d )
	{
		return {
			'width'	: $d.innerWidth(),
			'height': $d.innerHeight()
		};
	}
	function setTextContent( e, content )
	{
		if ( e.innerText )
		{
			e.innerText = content;
		}
		else if ( e.nodeValue )
		{
			e.nodeValue = content;
		}
		else if (e.textContent)
		{
			e.textContent = content;
		}

	}
	function getTextContent( e )
	{
		if ( e.innerText )
		{
			return e.innerText;
		}
		else if ( e.nodeValue )
		{
			return e.nodeValue;
		}
		else if ( e.textContent )
		{
			return e.textContent;
		}
		else
		{
			return "";
		}
	}
	function getPrevNode( n )
	{
		do
		{
			n = n.previousSibling;
		}
		while ( n && n.nodeType !== 1 && n.nodeType !== 3 );

		return n;
	}
	function findLastTextNode( $el, $top, excludeCurrent )
	{
		var e = $el && $el[ 0 ], p;
		if ( e )
		{
			if ( !excludeCurrent )
			{
				if ( e.nodeType === 3 )
				{
					return e;
				}
				if ( $.trim( $el.text() ) )
				{
					return findLastTextNode( $el.contents().last(), $top );
				}
			}
			p = getPrevNode( e );
			while ( !p )
			{
				$el = $el.parent();
				if ( $el.is( $top ) || !$el.length )
				{
					return false;
				}
				p = getPrevNode( $el[0] );
			}
			if ( p )
			{
				return findLastTextNode( $(p), $top );
			}
		}
		return false;
	}
	function getElement( e, $i )
	{
		if ( !e )
		{
			return false;
		}
		if ( typeof e === 'string' )
		{
			e = $(e, $i);
			return ( e.length )
				? e
				: false;
		}
		return !e.jquery
			? false
			: e;
	}
	function getTrueInnerHeight( $el )
	{
		var h = $el.innerHeight(),
			a = [ 'paddingTop', 'paddingBottom' ];

		for ( var z = 0, l = a.length; z < l; z++ )
		{
			var m = parseInt( $el.css( a[ z ] ), 10 );
			if ( isNaN( m ) )
			{
				m = 0;
			}
			h -= m;
		}
		return h;
	}


	//	override jQuery.html
	var _orgHtml = $.fn.html;
	$.fn.html = function( str )
	{
		if ( str != undef && !$.isFunction( str ) && this.data( 'dotdotdot' ) )
		{
			return this.trigger( 'update', [ str ] );
		}
		return _orgHtml.apply( this, arguments );
	};


	//	override jQuery.text
	var _orgText = $.fn.text;
	$.fn.text = function( str )
	{
		if ( str != undef && !$.isFunction( str ) && this.data( 'dotdotdot' ) )
		{
			str = $( '<div />' ).text( str ).html();
			return this.trigger( 'update', [ str ] );
		}
		return _orgText.apply( this, arguments );
	};


})( jQuery );

/*
 * jQuery FlexSlider v2.2.0
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
;
(function ($) {

  //FlexSlider: Object Instance
  $.flexslider = function(el, options) {
    var slider = $(el);

    // making variables public
    slider.vars = $.extend({}, $.flexslider.defaults, options);

    var namespace = slider.vars.namespace,
        msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,
        touch = (( "ontouchstart" in window ) || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,
        // depricating this idea, as devices are being released with both of these events
        //eventType = (touch) ? "touchend" : "click",
        eventType = "click touchend MSPointerUp",
        watchedEvent = "",
        watchedEventClearTimer,
        vertical = slider.vars.direction === "vertical",
        reverse = slider.vars.reverse,
        carousel = (slider.vars.itemWidth > 0),
        fade = slider.vars.animation === "fade",
        asNav = slider.vars.asNavFor !== "",
        methods = {},
        focused = true;

    // Store a reference to the slider object
    $.data(el, "flexslider", slider);

    // Private slider methods
    methods = {
      init: function() {
        slider.animating = false;
        // Get current slide and make sure it is a number
        slider.currentSlide = parseInt( ( slider.vars.startAt ? slider.vars.startAt : 0) );
        if ( isNaN( slider.currentSlide ) ) slider.currentSlide = 0;
        slider.animatingTo = slider.currentSlide;
        slider.atEnd = (slider.currentSlide === 0 || slider.currentSlide === slider.last);
        slider.containerSelector = slider.vars.selector.substr(0,slider.vars.selector.search(' '));
        slider.slides = $(slider.vars.selector, slider);
        slider.container = $(slider.containerSelector, slider);
        slider.count = slider.slides.length;
        // SYNC:
        slider.syncExists = $(slider.vars.sync).length > 0;
        // SLIDE:
        if (slider.vars.animation === "slide") slider.vars.animation = "swing";
        slider.prop = (vertical) ? "top" : "marginLeft";
        slider.args = {};
        // SLIDESHOW:
        slider.manualPause = false;
        slider.stopped = false;
        //PAUSE WHEN INVISIBLE
        slider.started = false;
        slider.startTimeout = null;
        // TOUCH/USECSS:
        slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && (function() {
          var obj = document.createElement('div'),
              props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
          for (var i in props) {
            if ( obj.style[ props[i] ] !== undefined ) {
              slider.pfx = props[i].replace('Perspective','').toLowerCase();
              slider.prop = "-" + slider.pfx + "-transform";
              return true;
            }
          }
          return false;
        }());
        // CONTROLSCONTAINER:
        if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer);
        // MANUAL:
        if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls);

        // RANDOMIZE:
        if (slider.vars.randomize) {
          slider.slides.sort(function() { return (Math.round(Math.random())-0.5); });
          slider.container.empty().append(slider.slides);
        }

        slider.doMath();

        // INIT
        slider.setup("init");

        // CONTROLNAV:
        if (slider.vars.controlNav) methods.controlNav.setup();

        // DIRECTIONNAV:
        if (slider.vars.directionNav) methods.directionNav.setup();

        // KEYBOARD:
        if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
          $(document).bind('keyup', function(event) {
            var keycode = event.keyCode;
            if (!slider.animating && (keycode === 39 || keycode === 37)) {
              var target = (keycode === 39) ? slider.getTarget('next') :
                           (keycode === 37) ? slider.getTarget('prev') : false;
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }
          });
        }
        // MOUSEWHEEL:
        if (slider.vars.mousewheel) {
          slider.bind('mousewheel', function(event, delta, deltaX, deltaY) {
            event.preventDefault();
            var target = (delta < 0) ? slider.getTarget('next') : slider.getTarget('prev');
            slider.flexAnimate(target, slider.vars.pauseOnAction);
          });
        }

        // PAUSEPLAY
        if (slider.vars.pausePlay) methods.pausePlay.setup();

        //PAUSE WHEN INVISIBLE
        if (slider.vars.slideshow && slider.vars.pauseInvisible) methods.pauseInvisible.init();

        // SLIDSESHOW
        if (slider.vars.slideshow) {
          if (slider.vars.pauseOnHover) {
            slider.hover(function() {
              if (!slider.manualPlay && !slider.manualPause) slider.pause();
            }, function() {
              if (!slider.manualPause && !slider.manualPlay && !slider.stopped) slider.play();
            });
          }
          // initialize animation
          //If we're visible, or we don't use PageVisibility API
          if(!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
            (slider.vars.initDelay > 0) ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();
          }
        }

        // ASNAV:
        if (asNav) methods.asNav.setup();

        // TOUCH
        if (touch && slider.vars.touch) methods.touch();

        // FADE&&SMOOTHHEIGHT || SLIDE:
        if (!fade || (fade && slider.vars.smoothHeight)) $(window).bind("resize orientationchange focus", methods.resize);

        slider.find("img").attr("draggable", "false");

        // API: start() Callback
        setTimeout(function(){
          slider.vars.start(slider);
        }, 200);
      },
      asNav: {
        setup: function() {
          slider.asNav = true;
          slider.animatingTo = Math.floor(slider.currentSlide/slider.move);
          slider.currentItem = slider.currentSlide;
          slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");
          if(!msGesture){
              slider.slides.click(function(e){
                e.preventDefault();
                var $slide = $(this),
                    target = $slide.index();
                var posFromLeft = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container
                if( posFromLeft <= 0 && $slide.hasClass( namespace + 'active-slide' ) ) {
                  slider.flexAnimate(slider.getTarget("prev"), true);
                } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + "active-slide")) {
                  slider.direction = (slider.currentItem < target) ? "next" : "prev";
                  slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                }
              });
          }else{
              el._slider = slider;
              slider.slides.each(function (){
                  var that = this;
                  that._gesture = new MSGesture();
                  that._gesture.target = that;
                  that.addEventListener("MSPointerDown", function (e){
                      e.preventDefault();
                      if(e.currentTarget._gesture)
                          e.currentTarget._gesture.addPointer(e.pointerId);
                  }, false);
                  that.addEventListener("MSGestureTap", function (e){
                      e.preventDefault();
                      var $slide = $(this),
                          target = $slide.index();
                      if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {
                          slider.direction = (slider.currentItem < target) ? "next" : "prev";
                          slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                      }
                  });
              });
          }
        }
      },
      controlNav: {
        setup: function() {
          if (!slider.manualControls) {
            methods.controlNav.setupPaging();
          } else { // MANUALCONTROLS:
            methods.controlNav.setupManual();
          }
        },
        setupPaging: function() {
          var type = (slider.vars.controlNav === "thumbnails") ? 'control-thumbs' : 'control-paging',
              j = 1,
              item,
              slide;

          slider.controlNavScaffold = $('<ol class="'+ namespace + 'control-nav ' + namespace + type + '"></ol>');

          if (slider.pagingCount > 1) {
            for (var i = 0; i < slider.pagingCount; i++) {
              slide = slider.slides.eq(i);
              item = (slider.vars.controlNav === "thumbnails") ? '<img src="' + slide.attr( 'data-thumb' ) + '"/>' : '<a>' + j + '</a>';
              if ( 'thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions ) {
                var captn = slide.attr( 'data-thumbcaption' );
                if ( '' != captn && undefined != captn ) item += '<span class="' + namespace + 'caption">' + captn + '</span>';
              }
              slider.controlNavScaffold.append('<li>' + item + '</li>');
              j++;
            }
          }

          // CONTROLSCONTAINER:
          (slider.controlsContainer) ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
          methods.controlNav.set();

          methods.controlNav.active();

          slider.controlNavScaffold.delegate('a, img', eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                slider.direction = (target > slider.currentSlide) ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();

          });
        },
        setupManual: function() {
          slider.controlNav = slider.manualControls;
          methods.controlNav.active();

          slider.controlNav.bind(eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                (target > slider.currentSlide) ? slider.direction = "next" : slider.direction = "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        set: function() {
          var selector = (slider.vars.controlNav === "thumbnails") ? 'img' : 'a';
          slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, (slider.controlsContainer) ? slider.controlsContainer : slider);
        },
        active: function() {
          slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
        },
        update: function(action, pos) {
          if (slider.pagingCount > 1 && action === "add") {
            slider.controlNavScaffold.append($('<li><a>' + slider.count + '</a></li>'));
          } else if (slider.pagingCount === 1) {
            slider.controlNavScaffold.find('li').remove();
          } else {
            slider.controlNav.eq(pos).closest('li').remove();
          }
          methods.controlNav.set();
          (slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length) ? slider.update(pos, action) : methods.controlNav.active();
        }
      },
      directionNav: {
        setup: function() {
          var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + '</a></li></ul>');

          // CONTROLSCONTAINER:
          if (slider.controlsContainer) {
            $(slider.controlsContainer).append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
          } else {
            slider.append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
          }

          methods.directionNav.update();

          slider.directionNav.bind(eventType, function(event) {
            event.preventDefault();
            var target;

            if (watchedEvent === "" || watchedEvent === event.type) {
              target = ($(this).hasClass(namespace + 'next')) ? slider.getTarget('next') : slider.getTarget('prev');
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function() {
          var disabledClass = namespace + 'disabled';
          if (slider.pagingCount === 1) {
            slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');
          } else if (!slider.vars.animationLoop) {
            if (slider.animatingTo === 0) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "prev").addClass(disabledClass).attr('tabindex', '-1');
            } else if (slider.animatingTo === slider.last) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "next").addClass(disabledClass).attr('tabindex', '-1');
            } else {
              slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
            }
          } else {
            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        }
      },
      pausePlay: {
        setup: function() {
          var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a></a></div>');

          // CONTROLSCONTAINER:
          if (slider.controlsContainer) {
            slider.controlsContainer.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
          } else {
            slider.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
          }

          methods.pausePlay.update((slider.vars.slideshow) ? namespace + 'pause' : namespace + 'play');

          slider.pausePlay.bind(eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              if ($(this).hasClass(namespace + 'pause')) {
                slider.manualPause = true;
                slider.manualPlay = false;
                slider.pause();
              } else {
                slider.manualPause = false;
                slider.manualPlay = true;
                slider.play();
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function(state) {
          (state === "play") ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);
        }
      },
      touch: function() {
        var startX,
          startY,
          offset,
          cwidth,
          dx,
          startT,
          scrolling = false,
          localX = 0,
          localY = 0,
          accDx = 0;

        if(!msGesture){
            el.addEventListener('touchstart', onTouchStart, false);

            function onTouchStart(e) {
              if (slider.animating) {
                e.preventDefault();
              } else if ( ( window.navigator.msPointerEnabled ) || e.touches.length === 1 ) {
                slider.pause();
                // CAROUSEL:
                cwidth = (vertical) ? slider.h : slider. w;
                startT = Number(new Date());
                // CAROUSEL:

                // Local vars for X and Y points.
                localX = e.touches[0].pageX;
                localY = e.touches[0].pageY;

                offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                         (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                         (carousel && slider.currentSlide === slider.last) ? slider.limit :
                         (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                         (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                startX = (vertical) ? localY : localX;
                startY = (vertical) ? localX : localY;

                el.addEventListener('touchmove', onTouchMove, false);
                el.addEventListener('touchend', onTouchEnd, false);
              }
            }

            function onTouchMove(e) {
              // Local vars for X and Y points.

              localX = e.touches[0].pageX;
              localY = e.touches[0].pageY;

              dx = (vertical) ? startX - localY : startX - localX;
              scrolling = (vertical) ? (Math.abs(dx) < Math.abs(localX - startY)) : (Math.abs(dx) < Math.abs(localY - startY));

              var fxms = 500;

              if ( ! scrolling || Number( new Date() ) - startT > fxms ) {
                e.preventDefault();
                if (!fade && slider.transitions) {
                  if (!slider.vars.animationLoop) {
                    dx = dx/((slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0) ? (Math.abs(dx)/cwidth+2) : 1);
                  }
                  slider.setProps(offset + dx, "setTouch");
                }
              }
            }

            function onTouchEnd(e) {
              // finish the touch by undoing the touch session
              el.removeEventListener('touchmove', onTouchMove, false);

              if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                var updateDx = (reverse) ? -dx : dx,
                    target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth/2)) {
                  slider.flexAnimate(target, slider.vars.pauseOnAction);
                } else {
                  if (!fade) slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
              el.removeEventListener('touchend', onTouchEnd, false);

              startX = null;
              startY = null;
              dx = null;
              offset = null;
            }
        }else{
            el.style.msTouchAction = "none";
            el._gesture = new MSGesture();
            el._gesture.target = el;
            el.addEventListener("MSPointerDown", onMSPointerDown, false);
            el._slider = slider;
            el.addEventListener("MSGestureChange", onMSGestureChange, false);
            el.addEventListener("MSGestureEnd", onMSGestureEnd, false);

            function onMSPointerDown(e){
                e.stopPropagation();
                if (slider.animating) {
                    e.preventDefault();
                }else{
                    slider.pause();
                    el._gesture.addPointer(e.pointerId);
                    accDx = 0;
                    cwidth = (vertical) ? slider.h : slider. w;
                    startT = Number(new Date());
                    // CAROUSEL:

                    offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                        (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                            (carousel && slider.currentSlide === slider.last) ? slider.limit :
                                (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                                    (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                }
            }

            function onMSGestureChange(e) {
                e.stopPropagation();
                var slider = e.target._slider;
                if(!slider){
                    return;
                }
                var transX = -e.translationX,
                    transY = -e.translationY;

                //Accumulate translations.
                accDx = accDx + ((vertical) ? transY : transX);
                dx = accDx;
                scrolling = (vertical) ? (Math.abs(accDx) < Math.abs(-transX)) : (Math.abs(accDx) < Math.abs(-transY));

                if(e.detail === e.MSGESTURE_FLAG_INERTIA){
                    setImmediate(function (){
                        el._gesture.stop();
                    });

                    return;
                }

                if (!scrolling || Number(new Date()) - startT > 500) {
                    e.preventDefault();
                    if (!fade && slider.transitions) {
                        if (!slider.vars.animationLoop) {
                            dx = accDx / ((slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0) ? (Math.abs(accDx) / cwidth + 2) : 1);
                        }
                        slider.setProps(offset + dx, "setTouch");
                    }
                }
            }

            function onMSGestureEnd(e) {
                e.stopPropagation();
                var slider = e.target._slider;
                if(!slider){
                    return;
                }
                if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                    var updateDx = (reverse) ? -dx : dx,
                        target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                    if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth/2)) {
                        slider.flexAnimate(target, slider.vars.pauseOnAction);
                    } else {
                        if (!fade) slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                    }
                }

                startX = null;
                startY = null;
                dx = null;
                offset = null;
                accDx = 0;
            }
        }
      },
      resize: function() {
        if (!slider.animating && slider.is(':visible')) {
          if (!carousel) slider.doMath();

          if (fade) {
            // SMOOTH HEIGHT:
            methods.smoothHeight();
          } else if (carousel) { //CAROUSEL:
            slider.slides.width(slider.computedW);
            slider.update(slider.pagingCount);
            slider.setProps();
          }
          else if (vertical) { //VERTICAL:
            slider.viewport.height(slider.h);
            slider.setProps(slider.h, "setTotal");
          } else {
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) methods.smoothHeight();
            slider.newSlides.width(slider.computedW);
            slider.setProps(slider.computedW, "setTotal");
          }
        }
      },
      smoothHeight: function(dur) {
        if (!vertical || fade) {
          var $obj = (fade) ? slider : slider.viewport;
          (dur) ? $obj.animate({"height": slider.slides.eq(slider.animatingTo).height()}, dur) : $obj.height(slider.slides.eq(slider.animatingTo).height());
        }
      },
      sync: function(action) {
        var $obj = $(slider.vars.sync).data("flexslider"),
            target = slider.animatingTo;

        switch (action) {
          case "animate": $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true); break;
          case "play": if (!$obj.playing && !$obj.asNav) { $obj.play(); } break;
          case "pause": $obj.pause(); break;
        }
      },
      pauseInvisible: {
        visProp: null,
        init: function() {
          var prefixes = ['webkit','moz','ms','o'];

          if ('hidden' in document) return 'hidden';
          for (var i = 0; i < prefixes.length; i++) {
            if ((prefixes[i] + 'Hidden') in document) 
            methods.pauseInvisible.visProp = prefixes[i] + 'Hidden';
          }
          if (methods.pauseInvisible.visProp) {
            var evtname = methods.pauseInvisible.visProp.replace(/[H|h]idden/,'') + 'visibilitychange';
            document.addEventListener(evtname, function() {
              if (methods.pauseInvisible.isHidden()) {
                if(slider.startTimeout) clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible
                else slider.pause(); //Or just pause
              }
              else {
                if(slider.started) slider.play(); //Initiated before, just play
                else (slider.vars.initDelay > 0) ? setTimeout(slider.play, slider.vars.initDelay) : slider.play(); //Didn't init before: simply init or wait for it
              }
            });
          }       
        },
        isHidden: function() {
          return document[methods.pauseInvisible.visProp] || false;
        }
      },
      setToClearWatchedEvent: function() {
        clearTimeout(watchedEventClearTimer);
        watchedEventClearTimer = setTimeout(function() {
          watchedEvent = "";
        }, 3000);
      }
    }

    // public methods
    slider.flexAnimate = function(target, pause, override, withSync, fromNav) {
      if (!slider.vars.animationLoop && target !== slider.currentSlide) {
        slider.direction = (target > slider.currentSlide) ? "next" : "prev";
      }

      if (asNav && slider.pagingCount === 1) slider.direction = (slider.currentItem < target) ? "next" : "prev";

      if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
        if (asNav && withSync) {
          var master = $(slider.vars.asNavFor).data('flexslider');
          slider.atEnd = target === 0 || target === slider.count - 1;
          master.flexAnimate(target, true, false, true, fromNav);
          slider.direction = (slider.currentItem < target) ? "next" : "prev";
          master.direction = slider.direction;

          if (Math.ceil((target + 1)/slider.visible) - 1 !== slider.currentSlide && target !== 0) {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            target = Math.floor(target/slider.visible);
          } else {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            return false;
          }
        }

        slider.animating = true;
        slider.animatingTo = target;

        // SLIDESHOW:
        if (pause) slider.pause();

        // API: before() animation Callback
        slider.vars.before(slider);

        // SYNC:
        if (slider.syncExists && !fromNav) methods.sync("animate");

        // CONTROLNAV
        if (slider.vars.controlNav) methods.controlNav.active();

        // !CAROUSEL:
        // CANDIDATE: slide active class (for add/remove slide)
        if (!carousel) slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');

        // INFINITE LOOP:
        // CANDIDATE: atEnd
        slider.atEnd = target === 0 || target === slider.last;

        // DIRECTIONNAV:
        if (slider.vars.directionNav) methods.directionNav.update();

        if (target === slider.last) {
          // API: end() of cycle Callback
          slider.vars.end(slider);
          // SLIDESHOW && !INFINITE LOOP:
          if (!slider.vars.animationLoop) slider.pause();
        }

        // SLIDE:
        if (!fade) {
          var dimension = (vertical) ? slider.slides.filter(':first').height() : slider.computedW,
              margin, slideString, calcNext;

          // INFINITE LOOP / REVERSE:
          if (carousel) {
            //margin = (slider.vars.itemWidth > slider.w) ? slider.vars.itemMargin * 2 : slider.vars.itemMargin;
            margin = slider.vars.itemMargin;
            calcNext = ((slider.itemW + margin) * slider.move) * slider.animatingTo;
            slideString = (calcNext > slider.limit && slider.visible !== 1) ? slider.limit : calcNext;
          } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
            slideString = (reverse) ? (slider.count + slider.cloneOffset) * dimension : 0;
          } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
            slideString = (reverse) ? 0 : (slider.count + 1) * dimension;
          } else {
            slideString = (reverse) ? ((slider.count - 1) - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
          }
          slider.setProps(slideString, "", slider.vars.animationSpeed);
          if (slider.transitions) {
            if (!slider.vars.animationLoop || !slider.atEnd) {
              slider.animating = false;
              slider.currentSlide = slider.animatingTo;
            }
            slider.container.unbind("webkitTransitionEnd transitionend");
            slider.container.bind("webkitTransitionEnd transitionend", function() {
              slider.wrapup(dimension);
            });
          } else {
            slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function(){
              slider.wrapup(dimension);
            });
          }
        } else { // FADE:
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeOut(slider.vars.animationSpeed, slider.vars.easing);
            //slider.slides.eq(target).fadeIn(slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

            slider.slides.eq(slider.currentSlide).css({"zIndex": 1}).animate({"opacity": 0}, slider.vars.animationSpeed, slider.vars.easing);
            slider.slides.eq(target).css({"zIndex": 2}).animate({"opacity": 1}, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

          } else {
            slider.slides.eq(slider.currentSlide).css({ "opacity": 0, "zIndex": 1 });
            slider.slides.eq(target).css({ "opacity": 1, "zIndex": 2 });
            slider.wrapup(dimension);
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) methods.smoothHeight(slider.vars.animationSpeed);
      }
    }
    slider.wrapup = function(dimension) {
      // SLIDE:
      if (!fade && !carousel) {
        if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpEnd");
        } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpStart");
        }
      }
      slider.animating = false;
      slider.currentSlide = slider.animatingTo;
      // API: after() animation Callback
      slider.vars.after(slider);
    }

    // SLIDESHOW:
    slider.animateSlides = function() {
      if (!slider.animating && focused ) slider.flexAnimate(slider.getTarget("next"));
    }
    // SLIDESHOW:
    slider.pause = function() {
      clearInterval(slider.animatedSlides);
      slider.animatedSlides = null;
      slider.playing = false;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) methods.pausePlay.update("play");
      // SYNC:
      if (slider.syncExists) methods.sync("pause");
    }
    // SLIDESHOW:
    slider.play = function() {
      if (slider.playing) clearInterval(slider.animatedSlides);
      slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
      slider.started = slider.playing = true;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) methods.pausePlay.update("pause");
      // SYNC:
      if (slider.syncExists) methods.sync("play");
    }
    // STOP:
    slider.stop = function () {
      slider.pause();
      slider.stopped = true;
    }
    slider.canAdvance = function(target, fromNav) {
      // ASNAV:
      var last = (asNav) ? slider.pagingCount - 1 : slider.last;
      return (fromNav) ? true :
             (asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev") ? true :
             (asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next") ? false :
             (target === slider.currentSlide && !asNav) ? false :
             (slider.vars.animationLoop) ? true :
             (slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next") ? false :
             (slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next") ? false :
             true;
    }
    slider.getTarget = function(dir) {
      slider.direction = dir;
      if (dir === "next") {
        return (slider.currentSlide === slider.last) ? 0 : slider.currentSlide + 1;
      } else {
        return (slider.currentSlide === 0) ? slider.last : slider.currentSlide - 1;
      }
    }

    // SLIDE:
    slider.setProps = function(pos, special, dur) {
      var target = (function() {
        var posCheck = (pos) ? pos : ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo,
            posCalc = (function() {
              if (carousel) {
                return (special === "setTouch") ? pos :
                       (reverse && slider.animatingTo === slider.last) ? 0 :
                       (reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                       (slider.animatingTo === slider.last) ? slider.limit : posCheck;
              } else {
                switch (special) {
                  case "setTotal": return (reverse) ? ((slider.count - 1) - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;
                  case "setTouch": return (reverse) ? pos : pos;
                  case "jumpEnd": return (reverse) ? pos : slider.count * pos;
                  case "jumpStart": return (reverse) ? slider.count * pos : pos;
                  default: return pos;
                }
              }
            }());

            return (posCalc * -1) + "px";
          }());

      if (slider.transitions) {
        target = (vertical) ? "translate3d(0," + target + ",0)" : "translate3d(" + target + ",0,0)";
        dur = (dur !== undefined) ? (dur/1000) + "s" : "0s";
        slider.container.css("-" + slider.pfx + "-transition-duration", dur);
      }

      slider.args[slider.prop] = target;
      if (slider.transitions || dur === undefined) slider.container.css(slider.args);
    }

    slider.setup = function(type) {
      // SLIDE:
      if (!fade) {
        var sliderOffset, arr;

        if (type === "init") {
          slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({"overflow": "hidden", "position": "relative"}).appendTo(slider).append(slider.container);
          // INFINITE LOOP:
          slider.cloneCount = 0;
          slider.cloneOffset = 0;
          // REVERSE:
          if (reverse) {
            arr = $.makeArray(slider.slides).reverse();
            slider.slides = $(arr);
            slider.container.empty().append(slider.slides);
          }
        }
        // INFINITE LOOP && !CAROUSEL:
        if (slider.vars.animationLoop && !carousel) {
          slider.cloneCount = 2;
          slider.cloneOffset = 1;
          // clear out old clones
          if (type !== "init") slider.container.find('.clone').remove();
          slider.container.append(slider.slides.first().clone().addClass('clone').attr('aria-hidden', 'true')).prepend(slider.slides.last().clone().addClass('clone').attr('aria-hidden', 'true'));
        }
        slider.newSlides = $(slider.vars.selector, slider);

        sliderOffset = (reverse) ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset;
        // VERTICAL:
        if (vertical && !carousel) {
          slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
          setTimeout(function(){
            slider.newSlides.css({"display": "block"});
            slider.doMath();
            slider.viewport.height(slider.h);
            slider.setProps(sliderOffset * slider.h, "init");
          }, (type === "init") ? 100 : 0);
        } else {
          slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
          slider.setProps(sliderOffset * slider.computedW, "init");
          setTimeout(function(){
            slider.doMath();
            slider.newSlides.css({"width": slider.computedW, "float": "left", "display": "block"});
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) methods.smoothHeight();
          }, (type === "init") ? 100 : 0);
        }
      } else { // FADE:
        slider.slides.css({"width": "100%", "float": "left", "marginRight": "-100%", "position": "relative"});
        if (type === "init") {
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
            slider.slides.css({ "opacity": 0, "display": "block", "zIndex": 1 }).eq(slider.currentSlide).css({"zIndex": 2}).animate({"opacity": 1},slider.vars.animationSpeed,slider.vars.easing);
          } else {
            slider.slides.css({ "opacity": 0, "display": "block", "webkitTransition": "opacity " + slider.vars.animationSpeed / 1000 + "s ease", "zIndex": 1 }).eq(slider.currentSlide).css({ "opacity": 1, "zIndex": 2});
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) methods.smoothHeight();
      }
      // !CAROUSEL:
      // CANDIDATE: active slide
      if (!carousel) slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");
    }


    slider.doMath = function() {
      var slide = slider.slides.first(),
          slideMargin = slider.vars.itemMargin,
          minItems = slider.vars.minItems,
          maxItems = slider.vars.maxItems;

      slider.w = (slider.viewport===undefined) ? slider.width() : slider.viewport.width();
      slider.h = slide.height();
      slider.boxPadding = slide.outerWidth() - slide.width();

      // CAROUSEL:
      if (carousel) {
        slider.itemT = slider.vars.itemWidth + slideMargin;
        slider.minW = (minItems) ? minItems * slider.itemT : slider.w;
        slider.maxW = (maxItems) ? (maxItems * slider.itemT) - slideMargin : slider.w;
        slider.itemW = (slider.minW > slider.w) ? (slider.w - (slideMargin * (minItems - 1)))/minItems :
                       (slider.maxW < slider.w) ? (slider.w - (slideMargin * (maxItems - 1)))/maxItems :
                       (slider.vars.itemWidth > slider.w) ? slider.w : slider.vars.itemWidth;

        slider.visible = Math.floor(slider.w/(slider.itemW));
        slider.move = (slider.vars.move > 0 && slider.vars.move < slider.visible ) ? slider.vars.move : slider.visible;
        slider.pagingCount = Math.ceil(((slider.count - slider.visible)/slider.move) + 1);
        slider.last =  slider.pagingCount - 1;
        slider.limit = (slider.pagingCount === 1) ? 0 :
                       (slider.vars.itemWidth > slider.w) ? (slider.itemW * (slider.count - 1)) + (slideMargin * (slider.count - 1)) : ((slider.itemW + slideMargin) * slider.count) - slider.w - slideMargin;
      } else {
        slider.itemW = slider.w;
        slider.pagingCount = slider.count;
        slider.last = slider.count - 1;
      }
      slider.computedW = slider.itemW - slider.boxPadding;
    }


    slider.update = function(pos, action) {
      slider.doMath();

      // update currentSlide and slider.animatingTo if necessary
      if (!carousel) {
        if (pos < slider.currentSlide) {
          slider.currentSlide += 1;
        } else if (pos <= slider.currentSlide && pos !== 0) {
          slider.currentSlide -= 1;
        }
        slider.animatingTo = slider.currentSlide;
      }

      // update controlNav
      if (slider.vars.controlNav && !slider.manualControls) {
        if ((action === "add" && !carousel) || slider.pagingCount > slider.controlNav.length) {
          methods.controlNav.update("add");
        } else if ((action === "remove" && !carousel) || slider.pagingCount < slider.controlNav.length) {
          if (carousel && slider.currentSlide > slider.last) {
            slider.currentSlide -= 1;
            slider.animatingTo -= 1;
          }
          methods.controlNav.update("remove", slider.last);
        }
      }
      // update directionNav
      if (slider.vars.directionNav) methods.directionNav.update();

    }

    slider.addSlide = function(obj, pos) {
      var $obj = $(obj);

      slider.count += 1;
      slider.last = slider.count - 1;

      // append new slide
      if (vertical && reverse) {
        (pos !== undefined) ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
      } else {
        (pos !== undefined) ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.update(pos, "add");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      //FlexSlider: added() Callback
      slider.vars.added(slider);
    }
    slider.removeSlide = function(obj) {
      var pos = (isNaN(obj)) ? slider.slides.index($(obj)) : obj;

      // update count
      slider.count -= 1;
      slider.last = slider.count - 1;

      // remove slide
      if (isNaN(obj)) {
        $(obj, slider.slides).remove();
      } else {
        (vertical && reverse) ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.doMath();
      slider.update(pos, "remove");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      // FlexSlider: removed() Callback
      slider.vars.removed(slider);
    }

    //FlexSlider: Initialize
    methods.init();
  }

  // Ensure the slider isn't focussed if the window loses focus.
  $( window ).blur( function ( e ) {
    focused = false;
  }).focus( function ( e ) {
    focused = true;
  });

  //FlexSlider: Default Settings
  $.flexslider.defaults = {
    namespace: "flex-",             //{NEW} String: Prefix string attached to the class of every element generated by the plugin
    selector: ".slides > li",       //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
    animation: "fade",              //String: Select your animation type, "fade" or "slide"
    easing: "swing",                //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
    direction: "horizontal",        //String: Select the sliding direction, "horizontal" or "vertical"
    reverse: false,                 //{NEW} Boolean: Reverse the animation direction
    animationLoop: true,            //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
    smoothHeight: false,            //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
    startAt: 0,                     //Integer: The slide that the slider should start on. Array notation (0 = first slide)
    slideshow: true,                //Boolean: Animate slider automatically
    slideshowSpeed: 7000,           //Integer: Set the speed of the slideshow cycling, in milliseconds
    animationSpeed: 600,            //Integer: Set the speed of animations, in milliseconds
    initDelay: 0,                   //{NEW} Integer: Set an initialization delay, in milliseconds
    randomize: false,               //Boolean: Randomize slide order
    thumbCaptions: false,           //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.

    // Usability features
    pauseOnAction: true,            //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
    pauseOnHover: false,            //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
    pauseInvisible: true,   		//{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
    useCSS: true,                   //{NEW} Boolean: Slider will use CSS3 transitions if available
    touch: true,                    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
    video: false,                   //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches

    // Primary Controls
    controlNav: true,               //Boolean: Create navigation for paging control of each clide? Note: Leave true for manualControls usage
    directionNav: true,             //Boolean: Create navigation for previous/next navigation? (true/false)
    prevText: "Previous",           //String: Set the text for the "previous" directionNav item
    nextText: "Next",               //String: Set the text for the "next" directionNav item

    // Secondary Navigation
    keyboard: true,                 //Boolean: Allow slider navigating via keyboard left/right keys
    multipleKeyboard: false,        //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
    mousewheel: false,              //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
    pausePlay: false,               //Boolean: Create pause/play dynamic element
    pauseText: "Pause",             //String: Set the text for the "pause" pausePlay item
    playText: "Play",               //String: Set the text for the "play" pausePlay item

    // Special properties
    controlsContainer: "",          //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
    manualControls: "",             //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
    sync: "",                       //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
    asNavFor: "",                   //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider

    // Carousel Options
    itemWidth: 0,                   //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
    itemMargin: 0,                  //{NEW} Integer: Margin between carousel items.
    minItems: 1,                    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
    maxItems: 0,                    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
    move: 0,                        //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
    allowOneSlide: true,           //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide

    // Callback API
    start: function(){},            //Callback: function(slider) - Fires when the slider loads the first slide
    before: function(){},           //Callback: function(slider) - Fires asynchronously with each slider animation
    after: function(){},            //Callback: function(slider) - Fires after each slider animation completes
    end: function(){},              //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
    added: function(){},            //{NEW} Callback: function(slider) - Fires after a slide is added
    removed: function(){}           //{NEW} Callback: function(slider) - Fires after a slide is removed
  }


  //FlexSlider: Plugin Function
  $.fn.flexslider = function(options) {
    if (options === undefined) options = {};

    if (typeof options === "object") {
      return this.each(function() {
        var $this = $(this),
            selector = (options.selector) ? options.selector : ".slides > li",
            $slides = $this.find(selector);

      if ( ( $slides.length === 1 && options.allowOneSlide === true ) || $slides.length === 0 ) {
          $slides.fadeIn(400);
          if (options.start) options.start($this);
        } else if ($this.data('flexslider') === undefined) {
          new $.flexslider(this, options);
        }
      });
    } else {
      // Helper strings to quickly perform functions on the slider
      var $slider = $(this).data('flexslider');
      switch (options) {
        case "play": $slider.play(); break;
        case "pause": $slider.pause(); break;
        case "stop": $slider.stop(); break;
        case "next": $slider.flexAnimate($slider.getTarget("next"), true); break;
        case "prev":
        case "previous": $slider.flexAnimate($slider.getTarget("prev"), true); break;
        default: if (typeof options === "number") $slider.flexAnimate(options, true);
      }
    }
  }
})(jQuery);

// Sticky positioning - constrains an element to be positioned inside the
// intersection of its container box, and the viewport.
Modernizr.addTest('csspositionsticky', function () {

    var prop = 'position:';
    var value = 'sticky';
    var el = document.createElement('modernizr');
    var mStyle = el.style;

    mStyle.cssText = prop + Modernizr._prefixes.join(value + ';' + prop).slice(0, -prop.length);

    return mStyle.position.indexOf(value) !== -1;
});

/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (arguments.length > 1 && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setTime(+t + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) === undefined) {
			return false;
		}

		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));
/**
 * Copyright (c) 2010 Maxim Vasiliev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @author Maxim Vasiliev
 * Date: 09.09.2010
 * Time: 19:02:33
 */


(function (root, factory)
{
	if (typeof define === 'function' && define.amd)
	{
		// AMD. Register as an anonymous module.
		define(factory);
	}
	else
	{
		// Browser globals
		root.form2js = factory();
	}
}(this, function ()
{
	"use strict";

	/**
	 * Returns form values represented as Javascript object
	 * "name" attribute defines structure of resulting object
	 *
	 * @param rootNode {Element|String} root form element (or it's id) or array of root elements
	 * @param delimiter {String} structure parts delimiter defaults to '.'
	 * @param skipEmpty {Boolean} should skip empty text values, defaults to true
	 * @param nodeCallback {Function} custom function to get node value
	 * @param useIdIfEmptyName {Boolean} if true value of id attribute of field will be used if name of field is empty
	 */
	function form2js(rootNode, delimiter, skipEmpty, nodeCallback, useIdIfEmptyName)
	{
		if (typeof skipEmpty == 'undefined' || skipEmpty == null) skipEmpty = true;
		if (typeof delimiter == 'undefined' || delimiter == null) delimiter = '.';
		if (arguments.length < 5) useIdIfEmptyName = false;

		rootNode = typeof rootNode == 'string' ? document.getElementById(rootNode) : rootNode;

		var formValues = [],
			currNode,
			i = 0;

		/* If rootNode is array - combine values */
		if (rootNode.constructor == Array || (typeof NodeList != "undefined" && rootNode.constructor == NodeList))
		{
			while(currNode = rootNode[i++])
			{
				formValues = formValues.concat(getFormValues(currNode, nodeCallback, useIdIfEmptyName));
			}
		}
		else
		{
			formValues = getFormValues(rootNode, nodeCallback, useIdIfEmptyName);
		}

		return processNameValues(formValues, skipEmpty, delimiter);
	}

	/**
	 * Processes collection of { name: 'name', value: 'value' } objects.
	 * @param nameValues
	 * @param skipEmpty if true skips elements with value == '' or value == null
	 * @param delimiter
	 */
	function processNameValues(nameValues, skipEmpty, delimiter)
	{
		var result = {},
			arrays = {},
			i, j, k, l,
			value,
			nameParts,
			currResult,
			arrNameFull,
			arrName,
			arrIdx,
			namePart,
			name,
			_nameParts;

		for (i = 0; i < nameValues.length; i++)
		{
			value = nameValues[i].value;

			if (skipEmpty && (value === '' || value === null)) continue;

			name = nameValues[i].name;
			_nameParts = name.split(delimiter);
			nameParts = [];
			currResult = result;
			arrNameFull = '';

			for(j = 0; j < _nameParts.length; j++)
			{
				namePart = _nameParts[j].split('][');
				if (namePart.length > 1)
				{
					for(k = 0; k < namePart.length; k++)
					{
						if (k == 0)
						{
							namePart[k] = namePart[k] + ']';
						}
						else if (k == namePart.length - 1)
						{
							namePart[k] = '[' + namePart[k];
						}
						else
						{
							namePart[k] = '[' + namePart[k] + ']';
						}

						arrIdx = namePart[k].match(/([a-z_]+)?\[([a-z_][a-z0-9_]+?)\]/i);
						if (arrIdx)
						{
							for(l = 1; l < arrIdx.length; l++)
							{
								if (arrIdx[l]) nameParts.push(arrIdx[l]);
							}
						}
						else{
							nameParts.push(namePart[k]);
						}
					}
				}
				else
					nameParts = nameParts.concat(namePart);
			}

			for (j = 0; j < nameParts.length; j++)
			{
				namePart = nameParts[j];

				if (namePart.indexOf('[]') > -1 && j == nameParts.length - 1)
				{
					arrName = namePart.substr(0, namePart.indexOf('['));
					arrNameFull += arrName;

					if (!currResult[arrName]) currResult[arrName] = [];
					currResult[arrName].push(value);
				}
				else if (namePart.indexOf('[') > -1)
				{
					arrName = namePart.substr(0, namePart.indexOf('['));
					arrIdx = namePart.replace(/(^([a-z_]+)?\[)|(\]$)/gi, '');

					/* Unique array name */
					arrNameFull += '_' + arrName + '_' + arrIdx;

					/*
					 * Because arrIdx in field name can be not zero-based and step can be
					 * other than 1, we can't use them in target array directly.
					 * Instead we're making a hash where key is arrIdx and value is a reference to
					 * added array element
					 */

					if (!arrays[arrNameFull]) arrays[arrNameFull] = {};
					if (arrName != '' && !currResult[arrName]) currResult[arrName] = [];

					if (j == nameParts.length - 1)
					{
						if (arrName == '')
						{
							currResult.push(value);
							arrays[arrNameFull][arrIdx] = currResult[currResult.length - 1];
						}
						else
						{
							currResult[arrName].push(value);
							arrays[arrNameFull][arrIdx] = currResult[arrName][currResult[arrName].length - 1];
						}
					}
					else
					{
						if (!arrays[arrNameFull][arrIdx])
						{
							if ((/^[a-z_]+\[?/i).test(nameParts[j+1])) currResult[arrName].push({});
							else currResult[arrName].push([]);

							arrays[arrNameFull][arrIdx] = currResult[arrName][currResult[arrName].length - 1];
						}
					}

					currResult = arrays[arrNameFull][arrIdx];
				}
				else
				{
					arrNameFull += namePart;

					if (j < nameParts.length - 1) /* Not the last part of name - means object */
					{
						if (!currResult[namePart]) currResult[namePart] = {};
						currResult = currResult[namePart];
					}
					else
					{
						currResult[namePart] = value;
					}
				}
			}
		}

		return result;
	}

    function getFormValues(rootNode, nodeCallback, useIdIfEmptyName)
    {
        var result = extractNodeValues(rootNode, nodeCallback, useIdIfEmptyName);
        return result.length > 0 ? result : getSubFormValues(rootNode, nodeCallback, useIdIfEmptyName);
    }

    function getSubFormValues(rootNode, nodeCallback, useIdIfEmptyName)
	{
		var result = [],
			currentNode = rootNode.firstChild;
		
		while (currentNode)
		{
			result = result.concat(extractNodeValues(currentNode, nodeCallback, useIdIfEmptyName));
			currentNode = currentNode.nextSibling;
		}

		return result;
	}

    function extractNodeValues(node, nodeCallback, useIdIfEmptyName) {
        var callbackResult, fieldValue, result, fieldName = getFieldName(node, useIdIfEmptyName);

        callbackResult = nodeCallback && nodeCallback(node);

        if (callbackResult && callbackResult.name) {
            result = [callbackResult];
        }
        else if (fieldName != '' && node.nodeName.match(/INPUT|TEXTAREA/i)) {
            fieldValue = getFieldValue(node);
			result = [ { name: fieldName, value: fieldValue} ];
        }
        else if (fieldName != '' && node.nodeName.match(/SELECT/i)) {
	        fieldValue = getFieldValue(node);
	        result = [ { name: fieldName.replace(/\[\]$/, ''), value: fieldValue } ];
        }
        else {
            result = getSubFormValues(node, nodeCallback, useIdIfEmptyName);
        }

        return result;
    }

	function getFieldName(node, useIdIfEmptyName)
	{
		if (node.name && node.name != '') return node.name;
		else if (useIdIfEmptyName && node.id && node.id != '') return node.id;
		else return '';
	}


	function getFieldValue(fieldNode)
	{
		if (fieldNode.disabled) return null;
		
		switch (fieldNode.nodeName) {
			case 'INPUT':
			case 'TEXTAREA':
				switch (fieldNode.type.toLowerCase()) {
					case 'radio':
			if (fieldNode.checked && fieldNode.value === "false") return false;
					case 'checkbox':
                        if (fieldNode.checked && fieldNode.value === "true") return true;
                        if (!fieldNode.checked && fieldNode.value === "true") return false;
			if (fieldNode.checked) return fieldNode.value;
						break;

					case 'button':
					case 'reset':
					case 'submit':
					case 'image':
						return '';
						break;

					default:
						return fieldNode.value;
						break;
				}
				break;

			case 'SELECT':
				return getSelectedOptionValue(fieldNode);
				break;

			default:
				break;
		}

		return null;
	}

	function getSelectedOptionValue(selectNode)
	{
		var multiple = selectNode.multiple,
			result = [],
			options,
			i, l;

		if (!multiple) return selectNode.value;

		for (options = selectNode.getElementsByTagName("option"), i = 0, l = options.length; i < l; i++)
		{
			if (options[i].selected) result.push(options[i].value);
		}

		return result;
	}

	return form2js;

}));

/**
 * Copyright (c) 2010 Maxim Vasiliev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @author Maxim Vasiliev
 * Date: 29.06.11
 * Time: 20:09
 */

(function($){

	/**
	 * jQuery wrapper for form2object()
	 * Extracts data from child inputs into javascript object
	 */
	$.fn.toObject = function(options)
	{
		var result = [],
			settings = {
				mode: 'first', // what to convert: 'all' or 'first' matched node
				delimiter: ".",
				skipEmpty: true,
				nodeCallback: null,
				useIdIfEmptyName: false
			};

		if (options)
		{
			$.extend(settings, options);
		}

		switch(settings.mode)
		{
			case 'first':
				return form2js(this.get(0), settings.delimiter, settings.skipEmpty, settings.nodeCallback, settings.useIdIfEmptyName);
				break;
			case 'all':
				this.each(function(){
					result.push(form2js(this, settings.delimiter, settings.skipEmpty, settings.nodeCallback, settings.useIdIfEmptyName));
				});
				return result;
				break;
			case 'combine':
				return form2js(Array.prototype.slice.call(this), settings.delimiter, settings.skipEmpty, settings.nodeCallback, settings.useIdIfEmptyName);
				break;
		}
	}

})(jQuery);
/*!
 * jQuery BBQ: Back Button & Query Library - v1.3pre - 8/26/2010
 * http://benalman.com/projects/jquery-bbq-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery BBQ: Back Button & Query Library
//
// *Version: 1.3pre, Last updated: 8/26/2010*
// 
// Project Home - http://benalman.com/projects/jquery-bbq-plugin/
// GitHub       - http://github.com/cowboy/jquery-bbq/
// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js
// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (2.2kb gzipped)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/
// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/
// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/
// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/
// 
// About: Release History
// 
// 1.3pre - (8/26/2010) Integrated <jQuery hashchange event> v1.3, which adds
//         document.title and document.domain support in IE6/7, BlackBerry
//         support, better Iframe hiding for accessibility reasons, and the new
//         <jQuery.fn.hashchange> "shortcut" method. Added the
//         <jQuery.param.sorted> method which reduces the possibility of
//         extraneous hashchange event triggering. Added the
//         <jQuery.param.fragment.ajaxCrawlable> method which can be used to
//         enable Google "AJAX Crawlable mode."
// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from
//         <jQuery hashchange event> in BBQ, which was the main reason for the
//         previous release!
// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a
//         Safari bug, the event can now be bound before DOM ready, and IE6/7
//         page should no longer scroll when the event is first bound. Also
//         added the <jQuery.param.fragment.noEscape> method, and reworked the
//         <hashchange event (BBQ)> internal "add" method to be compatible with
//         changes made to the jQuery 1.4.2 special events API.
// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an
//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.
// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>
//         functionality into a separate plugin for users who want just the
//         basic event & back button support, without all the extra awesomeness
//         that BBQ provides. This plugin will be included as part of jQuery BBQ,
//         but also be available separately. See <jQuery hashchange event>
//         plugin for more information. Also added the <jQuery.bbq.removeState>
//         method and added additional <jQuery.deparam> examples.
// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and
//         location.hash would report incorrectly if the hash contained the ?
//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>
//         will no longer parse params out of a URL that doesn't contain ? or #,
//         respectively.
// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused
//         a "This page contains both secure and nonsecure items." warning when
//         used on an https:// page.
// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both "IE7" and "IE8
//         Compatibility View" modes erroneously report that the browser
//         supports the native window.onhashchange event, a slightly more
//         robust test needed to be added.
// 1.0   - (10/2/2009) Initial release

(function($,window){
  '$:nomunge'; // Used by YUI compressor.
  
  // Some convenient shortcuts.
  var undefined,
    aps = Array.prototype.slice,
    decode = decodeURIComponent,
    
    // Method / object references.
    jq_param = $.param,
    jq_param_sorted,
    jq_param_fragment,
    jq_deparam,
    jq_deparam_fragment,
    jq_bbq = $.bbq = $.bbq || {},
    jq_bbq_pushState,
    jq_bbq_getState,
    jq_elemUrlAttr,
    special = $.event.special,
    
    // Reused strings.
    str_hashchange = 'hashchange',
    str_querystring = 'querystring',
    str_fragment = 'fragment',
    str_elemUrlAttr = 'elemUrlAttr',
    str_href = 'href',
    str_src = 'src',
    
    // Reused RegExp.
    re_params_querystring = /^.*\?|#.*$/g,
    re_params_fragment,
    re_fragment,
    re_no_escape,
    
    ajax_crawlable,
    fragment_prefix,
    
    // Used by jQuery.elemUrlAttr.
    elemUrlAttr_cache = {};
  
  // A few commonly used bits, broken out to help reduce minified file size.
  
  function is_string( arg ) {
    return typeof arg === 'string';
  };
  
  // Why write the same function twice? Let's curry! Mmmm, curry..
  
  function curry( func ) {
    var args = aps.call( arguments, 1 );
    
    return function() {
      return func.apply( this, args.concat( aps.call( arguments ) ) );
    };
  };
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    return url.replace( re_fragment, '$2' );
  };
  
  // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!
  function get_querystring( url ) {
    return url.replace( /(?:^[^?#]*\?([^#]*).*$)?.*/, '$1' );
  };
  
  // Section: Param (to string)
  // 
  // Method: jQuery.param.querystring
  // 
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.href.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location.href is used.
  // 
  // Returns:
  // 
  //  (String) The parsed query string, with any leading "?" removed.
  //
  
  // Method: jQuery.param.querystring (build url)
  // 
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) A URL with a urlencoded query string in the format '?a=b&c=d&e=f'.
  
  // Method: jQuery.param.fragment
  // 
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.href.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location.href is used.
  // 
  // Returns:
  // 
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.
  
  // Method: jQuery.param.fragment (build url)
  // 
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) A URL with a urlencoded fragment (hash) in the format '#a=b&c=d&e=f'.
  
  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {
    var result,
      qs,
      matches,
      url_params,
      hash;
    
    if ( params !== undefined ) {
      // Build URL by merging params into url string.
      
      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match( is_fragment ? re_fragment : /^([^#?]*)\??([^#]*)(#?.*)/ );
      
      // Get the hash if in 'querystring' mode, and it exists.
      hash = matches[3] || '';
      
      if ( merge_mode === 2 && is_string( params ) ) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace( is_fragment ? re_params_fragment : re_params_querystring, '' );
        
      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam( matches[2] );
        
        params = is_string( params )
          
          // Convert passed params string into object.
          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )
          
          // Passed params object.
          : params;
        
        qs = merge_mode === 2 ? params                              // passed params replace url params
          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params
          : $.extend( {}, url_params, params );                     // passed params override url params
        
        // Convert params object into a sorted params string.
        qs = jq_param_sorted( qs );
        
        // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.
        if ( is_fragment ) {
          qs = qs.replace( re_no_escape, decode );
        }
      }
      
      // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.
      result = matches[1] + ( is_fragment ? fragment_prefix : qs || !matches[1] ? '?' : '' ) + qs + hash;
      
    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.href.
      result = get_func( url !== undefined ? url : location.href );
    }
    
    return result;
  };
  
  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );
  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );
  
  // Method: jQuery.param.sorted
  // 
  // Returns a params string equivalent to that returned by the internal
  // jQuery.param method, but sorted, which makes it suitable for use as a
  // cache key.
  // 
  // For example, in most browsers jQuery.param({z:1,a:2}) returns "z=1&a=2"
  // and jQuery.param({a:2,z:1}) returns "a=2&z=1". Even though both the
  // objects being serialized and the resulting params strings are equivalent,
  // if these params strings were set into the location.hash fragment
  // sequentially, the hashchange event would be triggered unnecessarily, since
  // the strings are different (even though the data described by them is the
  // same). By sorting the params string, unecessary hashchange event triggering
  // can be avoided.
  // 
  // Usage:
  // 
  // > jQuery.param.sorted( obj [, traditional ] );
  // 
  // Arguments:
  // 
  //  obj - (Object) An object to be serialized.
  //  traditional - (Boolean) Params deep/shallow serialization mode. See the
  //    documentation at http://api.jquery.com/jQuery.param/ for more detail.
  // 
  // Returns:
  // 
  //  (String) A sorted params string.
  
  jq_param.sorted = jq_param_sorted = function( a, traditional ) {
    var arr = [],
      obj = {};
    
    $.each( jq_param( a, false ).split( '&' ), function(i,v){
      var key = v.replace( /(?:%5B|=).*$/, '' ),
        key_obj = obj[ key ];
      
      if ( !key_obj ) {
        key_obj = obj[ key ] = [];
        arr.push( key );
      }
      
      key_obj.push( v );
    });
    
    return $.map( arr.sort(), function(v){
      return obj[ v ];
    }).join( '&' );
  };
  
  // Method: jQuery.param.fragment.noEscape
  // 
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  // 
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment.noEscape( [ chars ] );
  // 
  // Arguments:
  // 
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  // 
  // Returns:
  // 
  //  Nothing.
  
  jq_param_fragment.noEscape = function( chars ) {
    chars = chars || '';
    var arr = $.map( chars.split(''), encodeURIComponent );
    re_no_escape = new RegExp( arr.join('|'), 'g' );
  };
  
  // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.
  jq_param_fragment.noEscape( ',/' );
  
  // Method: jQuery.param.fragment.ajaxCrawlable
  // 
  // TODO: DESCRIBE
  // 
  // Usage:
  // 
  // > jQuery.param.fragment.ajaxCrawlable( [ state ] );
  // 
  // Arguments:
  // 
  //  state - (Boolean) TODO: DESCRIBE
  // 
  // Returns:
  // 
  //  (Boolean) The current ajaxCrawlable state.
  
  jq_param_fragment.ajaxCrawlable = function( state ) {
    if ( state !== undefined ) {
      if ( state ) {
        re_params_fragment = /^.*(?:#!|#)/;
        re_fragment = /^([^#]*)(?:#!|#)?(.*)$/;
        fragment_prefix = '#!';
      } else {
        re_params_fragment = /^.*#/;
        re_fragment = /^([^#]*)#?(.*)$/;
        fragment_prefix = '#';
      }
      ajax_crawlable = !!state;
    }
    
    return ajax_crawlable;
  };
  
  jq_param_fragment.ajaxCrawlable( 0 );
  
  // Section: Deparam (from string)
  // 
  // Method: jQuery.deparam
  // 
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  // 
  // Usage:
  // 
  // > jQuery.deparam( params [, coerce ] );
  // 
  // Arguments:
  // 
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  $.deparam = jq_deparam = function( params, coerce ) {
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };
    
    // Iterate over all name=value pairs.
    $.each( params.replace( /\+/g, ' ' ).split( '&' ), function(j,v){
      var param = v.split( '=' ),
        key = decode( param[0] ),
        val,
        cur = obj,
        i = 0,
        
        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
        // into its component parts.
        keys = key.split( '][' ),
        keys_last = keys.length - 1;
      
      // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.
      if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
        // Remove the trailing ] from the last keys part.
        keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );
        
        // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.
        keys = keys.shift().split('[').concat( keys );
        
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      }
      
      // Are we dealing with a name=value pair, or just a name?
      if ( param.length === 2 ) {
        val = decode( param[1] );
        
        // Coerce values.
        if ( coerce ) {
          val = val && !isNaN(val)            ? +val              // number
            : val === 'undefined'             ? undefined         // undefined
            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
            : val;                                                // string
        }
        
        if ( keys_last ) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is 
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for ( ; i <= keys_last; i++ ) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last
              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
              : val;
          }
          
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          
          if ( $.isArray( obj[key] ) ) {
            // val is already an array, so push on the next value.
            obj[key].push( val );
            
          } else if ( obj[key] !== undefined ) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [ obj[key], val ];
            
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
        
      } else if ( key ) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce
          ? undefined
          : '';
      }
    });
    
    return obj;
  };
  
  // Method: jQuery.deparam.querystring
  // 
  // Parse the query string from a URL or the current window.location.href,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current
  //    window.location.href is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  // Method: jQuery.deparam.fragment
  // 
  // Parse the fragment (hash) from a URL or the current window.location.href,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location.href
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {
    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();
    } else {
      url_or_params = is_string( url_or_params )
        ? url_or_params.replace( is_fragment ? re_params_fragment : re_params_querystring, '' )
        : url_or_params;
    }
    
    return jq_deparam( url_or_params, coerce );
  };
  
  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );
  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );
  
  // Section: Element manipulation
  // 
  // Method: jQuery.elemUrlAttr
  // 
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  // 
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  // 
  // Default Tag-Attribute List:
  // 
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  // 
  // Usage:
  // 
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  // 
  // Arguments:
  // 
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  // 
  // Returns:
  // 
  //  (Object) An object containing all stored tag-attribute values.
  
  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.
  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {
    return $.extend( elemUrlAttr_cache, obj );
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });
  
  jq_elemUrlAttr = $[ str_elemUrlAttr ];
  
  // Method: jQuery.fn.querystring
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  // Method: jQuery.fn.fragment
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  function jq_fn_sub( mode, force_attr, params, merge_mode ) {
    if ( !is_string( params ) && typeof params !== 'object' ) {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }
    
    return this.each(function(){
      var that = $(this),
        
        // Get attribute specified, or default specified via $.elemUrlAttr.
        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',
        
        // Get URL value.
        url = attr && that.attr( attr ) || '';
      
      // Update attribute with new URL.
      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );
    });
    
  };
  
  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );
  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );
  
  // Section: History, hashchange event
  // 
  // Method: jQuery.bbq.pushState
  // 
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  // 
  // Arguments:
  // 
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  // 
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.
  
  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {
    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }
    
    var has_args = params !== undefined,
      // Merge params into window.location using $.param.fragment.
      url = jq_param_fragment( location.href,
        has_args ? params : {}, has_args ? merge_mode : 2 );
    
    // Set new window.location.href. Note that Safari 3 & Chrome barf on
    // location.hash = '#' so the entire URL is set.
    location.href = url;
  };
  
  // Method: jQuery.bbq.getState
  // 
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  // 
  // Usage:
  // 
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  // 
  // Returns:
  // 
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.
  
  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {
    return key === undefined || typeof key === 'boolean'
      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here
      : jq_deparam_fragment( coerce )[ key ];
  };
  
  // Method: jQuery.bbq.removeState
  // 
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  // 
  // Arguments:
  // 
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  
  jq_bbq.removeState = function( arr ) {
    var state = {};
    
    // If one or more arguments is passed..
    if ( arr !== undefined ) {
      
      // Get the current state.
      state = jq_bbq_getState();
      
      // For each passed key, delete the corresponding property from the current
      // state.
      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){
        delete state[ v ];
      });
    }
    
    // Set the state, completely overriding any existing state.
    jq_bbq_pushState( state, 2 );
  };
  
  // Event: hashchange event (BBQ)
  // 
  // Usage in jQuery 1.4 and newer:
  // 
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  // 
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  // 
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Usage in jQuery 1.3.2:
  // 
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.
  
  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {
    
    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function( handleObj ) {
      var old_handler;
      
      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[ str_fragment ] = jq_param_fragment();
        
        // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.
        e.getState = function( key, coerce ) {
          return key === undefined || typeof key === 'boolean'
            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here
            : jq_deparam( hash, coerce )[ key ];
        };
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  });
  
})(jQuery,this);

/*!
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.3, Last updated: 7/21/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and
// robust, there are a few unfortunate browser bugs surrounding expected
// hashchange event-based behaviors, independent of any JavaScript
// window.onhashchange abstraction. See the following examples for more
// information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// Also note that should a browser natively support the window.onhashchange 
// event, but not report that it does, the fallback polling loop will be used.
// 
// About: Release History
// 
// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
//         "removable" for mobile-only development. Added IE6/7 document.title
//         support. Attempted to make Iframe as hidden as possible by using
//         techniques from http://www.paciellogroup.com/blog/?p=604. Added 
//         support for the "shortcut" format $(window).hashchange( fn ) and
//         $(window).hashchange() like jQuery provides for built-in events.
//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
//         file to address access denied issues when setting document.domain in
//         IE6/7.
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Reused string.
  var str_hashchange = 'hashchange',
    
    // Method / object references.
    doc = document,
    fake_onhashchange,
    special = $.event.special,
    
    // Does the browser support window.onhashchange? Note that IE8 running in
    // IE7 compatibility mode reports true for 'onhashchange' in window, even
    // though the event isn't supported, so also test document.documentMode.
    doc_mode = doc.documentMode,
    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || location.href;
    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Method: jQuery.fn.hashchange
  // 
  // Bind a handler to the window.onhashchange event or trigger all bound
  // window.onhashchange event handlers. This behavior is consistent with
  // jQuery's built-in event handlers.
  // 
  // Usage:
  // 
  // > jQuery(window).hashchange( [ handler ] );
  // 
  // Arguments:
  // 
  //  handler - (Function) Optional handler to be bound to the hashchange
  //    event. This is a "shortcut" for the more verbose form:
  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
  //    all bound window.onhashchange event handlers will be triggered. This
  //    is a shortcut for the more verbose
  //    jQuery(window).trigger( 'hashchange' ). These forms are described in
  //    the <hashchange event> section.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements.
  
  // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
  // $(elem).hashchange() for triggering, like jQuery does for built-in events.
  $.fn[ str_hashchange ] = function( fn ) {
    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
  };
  
  // Property: jQuery.fn.hashchange.delay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 50.
  
  // Property: jQuery.fn.hashchange.domain
  // 
  // If you're setting document.domain in your JavaScript, and you want hash
  // history to work in IE6/7, not only must this property be set, but you must
  // also set document.domain BEFORE jQuery is loaded into the page. This
  // property is only applicable if you are supporting IE6/7 (or IE8 operating
  // in "IE7 compatibility" mode).
  // 
  // In addition, the <jQuery.fn.hashchange.src> property must be set to the
  // path of the included "document-domain.html" file, which can be renamed or
  // modified if necessary (note that the document.domain specified must be the
  // same in both your main JavaScript as well as in this file).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.domain = document.domain;
  
  // Property: jQuery.fn.hashchange.src
  // 
  // If, for some reason, you need to specify an Iframe src file (for example,
  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
  // do so using this property. Note that when using this property, history
  // won't be recorded in IE6/7 until the Iframe src file loads. This property
  // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
  // compatibility" mode).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.src = 'path/to/file.html';
  
  $.fn[ str_hashchange ].delay = 50;
  /*
  $.fn[ str_hashchange ].domain = null;
  $.fn[ str_hashchange ].src = null;
  */
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // HTML5 window.onhashchange event is used, otherwise a polling loop is
  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
  // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
  // compatibility" mode), a hidden Iframe is created to allow the back button
  // and hash-based history to work.
  // 
  // Usage as described in <jQuery.fn.hashchange>:
  // 
  // > // Bind an event handler.
  // > jQuery(window).hashchange( function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).hashchange();
  // 
  // A more verbose usage that allows for event namespacing:
  // 
  // > // Bind an event handler.
  // > jQuery(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).trigger( 'hashchange' );
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one handler
  //   is actually bound to the 'hashchange' event.
  // * If you need the bound handler(s) to execute immediately, in cases where
  //   a location.hash exists on page load, via bookmark or page refresh for
  //   example, use jQuery(window).hashchange() or the more verbose 
  //   jQuery(window).trigger( 'hashchange' ).
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a DOM ready handler.
  
  // Override existing $.event.special.hashchange methods (allowing this plugin
  // to be defined after jQuery BBQ in BBQ's source code).
  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      
      // Remember the initial hash so it doesn't get triggered immediately.
      last_hash = get_fragment(),
      
      fn_retval = function(val){ return val; },
      history_set = fn_retval,
      history_get = fn_retval;
    
    // Start the polling loop.
    self.start = function() {
      timeout_id || poll();
    };
    
    // Stop the polling loop.
    self.stop = function() {
      timeout_id && clearTimeout( timeout_id );
      timeout_id = undefined;
    };
    
    // This polling loop checks every $.fn.hashchange.delay milliseconds to see
    // if location.hash has changed, and triggers the 'hashchange' event on
    // window when necessary.
    function poll() {
      var hash = get_fragment(),
        history_hash = history_get( last_hash );
      
      if ( hash !== last_hash ) {
        history_set( last_hash = hash, history_hash );
        
        $(window).trigger( str_hashchange );
        
      } else if ( history_hash !== last_hash ) {
        location.href = location.href.replace( /#.*/, '' ) + history_hash;
      }
      
      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
    };
    
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    $.browser.msie && !supports_onhashchange && (function(){
      // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
      // when running in "IE7 compatibility" mode.
      
      var iframe,
        iframe_src;
      
      // When the event is bound and polling starts in IE 6/7, create a hidden
      // Iframe for history handling.
      self.start = function(){
        if ( !iframe ) {
          iframe_src = $.fn[ str_hashchange ].src;
          iframe_src = iframe_src && iframe_src + get_fragment();
          
          // Create hidden Iframe. Attempt to make Iframe as hidden as possible
          // by using techniques from http://www.paciellogroup.com/blog/?p=604.
          iframe = $('<iframe tabindex="-1" title="empty"/>').hide()
            
            // When Iframe has completely loaded, initialize the history and
            // start polling.
            .one( 'load', function(){
              iframe_src || history_set( get_fragment() );
              poll();
            })
            
            // Load Iframe src if specified, otherwise nothing.
            .attr( 'src', iframe_src || 'javascript:0' )
            
            // Append Iframe after the end of the body to prevent unnecessary
            // initial page scrolling (yes, this works).
            .insertAfter( 'body' )[0].contentWindow;
          
          // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with "Unspecified error" the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.
          doc.onpropertychange = function(){
            try {
              if ( event.propertyName === 'title' ) {
                iframe.document.title = doc.title;
              }
            } catch(e) {}
          };
          
        }
      };
      
      // Override the "stop" method since an IE6/7 Iframe was created. Even
      // if there are no longer any bound event handlers, the polling loop
      // is still necessary for back/next to work at all!
      self.stop = fn_retval;
      
      // Get history by looking at the hidden Iframe's location.hash.
      history_get = function() {
        return get_fragment( iframe.location.href );
      };
      
      // Set a new history item by opening and then closing the Iframe
      // document, *then* setting its location.hash. If document.domain has
      // been set, update that as well.
      history_set = function( hash, history_hash ) {
        var iframe_doc = iframe.document,
          domain = $.fn[ str_hashchange ].domain;
        
        if ( hash !== history_hash ) {
          // Update Iframe with any initial `document.title` that might be set.
          iframe_doc.title = doc.title;
          
          // Opening the Iframe's document after it has been closed is what
          // actually adds a history entry.
          iframe_doc.open();
          
          // Set document.domain for the Iframe document as well, if necessary.
          domain && iframe_doc.write( '<script>document.domain="' + domain + '"</script>' );
          
          iframe_doc.close();
          
          // Update the Iframe's hash, for great justice.
          iframe.location.hash = hash;
        }
      };
      
    })();
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    return self;
  })();
  
})(jQuery,this);

/*!
 * jQuery Validation Plugin v1.12.0
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2014 Jrn Zaefferer
 * Released under the MIT license
 */
(function($) {

$.extend($.fn, {
	// http://jqueryvalidation.org/validate/
	//http://jqueryvalidation.org/documentation/
	validate: function( options ) {

		// if nothing is selected, return nothing; can't chain anyway
		if ( !this.length ) {
			if ( options && options.debug && window.console ) {
				console.warn( "Nothing selected, can't validate, returning nothing." );
			}
			return;
		}

		// check if a validator for this form was already created
		var validator = $.data( this[0], "validator" );
		if ( validator ) {
			return validator;
		}

		// Add novalidate tag if HTML5.
		this.attr( "novalidate", "novalidate" );

		validator = new $.validator( options, this[0] );
		$.data( this[0], "validator", validator );

		if ( validator.settings.onsubmit ) {

			this.validateDelegate( ":submit", "click", function( event ) {
				if ( validator.settings.submitHandler ) {
					validator.submitButton = event.target;
				}
				// allow suppressing validation by adding a cancel class to the submit button
				if ( $(event.target).hasClass("cancel") ) {
					validator.cancelSubmit = true;
				}

				// allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
				if ( $(event.target).attr("formnovalidate") !== undefined ) {
					validator.cancelSubmit = true;
				}
			});

			// validate the form on submit
			this.submit( function( event ) {
				if ( validator.settings.debug ) {
					// prevent form submit to be able to see console output
					event.preventDefault();
				}
				function handle() {
					var hidden;
					if ( validator.settings.submitHandler ) {
						if ( validator.submitButton ) {
							// insert a hidden input as a replacement for the missing submit button
							hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val( $(validator.submitButton).val() ).appendTo(validator.currentForm);
						}
						validator.settings.submitHandler.call( validator, validator.currentForm, event );
						if ( validator.submitButton ) {
							// and clean up afterwards; thanks to no-block-scope, hidden can be referenced
							hidden.remove();
						}
						return false;
					}
					return true;
				}

				// prevent submit for invalid forms or custom submit handlers
				if ( validator.cancelSubmit ) {
					validator.cancelSubmit = false;
					return handle();
				}
				if ( validator.form() ) {
					if ( validator.pendingRequest ) {
						validator.formSubmitted = true;
						return false;
					}
					return handle();
				} else {
					validator.focusInvalid();
					return false;
				}
			});
		}

		return validator;
	},
	// http://jqueryvalidation.org/valid/
	valid: function() {
		var valid, validator;

		if ( $(this[0]).is("form")) {
			valid = this.validate().form();
		} else {
			valid = true;
			validator = $(this[0].form).validate();
			this.each(function() {
				valid = validator.element(this) && valid;
			});
		}
		return valid;
	},
	// attributes: space separated list of attributes to retrieve and remove
	removeAttrs: function( attributes ) {
		var result = {},
			$element = this;
		$.each(attributes.split(/\s/), function( index, value ) {
			result[value] = $element.attr(value);
			$element.removeAttr(value);
		});
		return result;
	},
	// http://jqueryvalidation.org/rules/
	rules: function( command, argument ) {
		var element = this[0],
			settings, staticRules, existingRules, data, param, filtered;

		if ( command ) {
			settings = $.data(element.form, "validator").settings;
			staticRules = settings.rules;
			existingRules = $.validator.staticRules(element);
			switch (command) {
			case "add":
				$.extend(existingRules, $.validator.normalizeRule(argument));
				// remove messages from rules, but allow them to be set separately
				delete existingRules.messages;
				staticRules[element.name] = existingRules;
				if ( argument.messages ) {
					settings.messages[element.name] = $.extend( settings.messages[element.name], argument.messages );
				}
				break;
			case "remove":
				if ( !argument ) {
					delete staticRules[element.name];
					return existingRules;
				}
				filtered = {};
				$.each(argument.split(/\s/), function( index, method ) {
					filtered[method] = existingRules[method];
					delete existingRules[method];
					if ( method === "required" ) {
						$(element).removeAttr("aria-required");
					}
				});
				return filtered;
			}
		}

		data = $.validator.normalizeRules(
		$.extend(
			{},
			$.validator.classRules(element),
			$.validator.attributeRules(element),
			$.validator.dataRules(element),
			$.validator.staticRules(element)
		), element);

		// make sure required is at front
		if ( data.required ) {
			param = data.required;
			delete data.required;
			data = $.extend({ required: param }, data );
			$(element).attr( "aria-required", "true" );
		}

		// make sure remote is at back
		if ( data.remote ) {
			param = data.remote;
			delete data.remote;
			data = $.extend( data, { remote: param });
		}

		return data;
	}
});

// Custom selectors
$.extend($.expr[":"], {
	// http://jqueryvalidation.org/blank-selector/
	blank: function( a ) { return !$.trim("" + $(a).val()); },
	// http://jqueryvalidation.org/filled-selector/
	filled: function( a ) { return !!$.trim("" + $(a).val()); },
	// http://jqueryvalidation.org/unchecked-selector/
	unchecked: function( a ) { return !$(a).prop("checked"); }
});

// constructor for validator
$.validator = function( options, form ) {
	this.settings = $.extend( true, {}, $.validator.defaults, options );
	this.currentForm = form;
	this.init();
};

// http://jqueryvalidation.org/jQuery.validator.format/
$.validator.format = function( source, params ) {
	if ( arguments.length === 1 ) {
		return function() {
			var args = $.makeArray(arguments);
			args.unshift(source);
			return $.validator.format.apply( this, args );
		};
	}
	if ( arguments.length > 2 && params.constructor !== Array  ) {
		params = $.makeArray(arguments).slice(1);
	}
	if ( params.constructor !== Array ) {
		params = [ params ];
	}
	$.each(params, function( i, n ) {
		source = source.replace( new RegExp("\\{" + i + "\\}", "g"), function() {
			return n;
		});
	});
	return source;
};

$.extend($.validator, {

	defaults: {
		messages: {},
		groups: {},
		rules: {},
		errorClass: "error",
		validClass: "valid",
		errorElement: "label",
		focusInvalid: true,
		errorContainer: $([]),
		errorLabelContainer: $([]),
		onsubmit: true,
		ignore: ":hidden",
		ignoreTitle: false,
		onfocusin: function( element ) {
			this.lastActive = element;

			// hide error label and remove error class on focus if enabled
			if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {
				if ( this.settings.unhighlight ) {
					this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
				}
				this.addWrapper(this.errorsFor(element)).hide();
			}
		},
		onfocusout: function( element ) {
			if ( !this.checkable(element) && (element.name in this.submitted || !this.optional(element)) ) {
				this.element(element);
			}
		},
		onkeyup: function( element, event ) {
			if ( event.which === 9 && this.elementValue(element) === "" ) {
				return;
			} else if ( element.name in this.submitted || element === this.lastElement ) {
				this.element(element);
			}
		},
		onclick: function( element ) {
			// click on selects, radiobuttons and checkboxes
			if ( element.name in this.submitted ) {
				this.element(element);

			// or option elements, check parent select in that case
			} else if ( element.parentNode.name in this.submitted ) {
				this.element(element.parentNode);
			}
		},
		highlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName(element.name).addClass(errorClass).removeClass(validClass);
			} else {
				$(element).addClass(errorClass).removeClass(validClass);
			}
		},
		unhighlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName(element.name).removeClass(errorClass).addClass(validClass);
			} else {
				$(element).removeClass(errorClass).addClass(validClass);
			}
		}
	},

	// http://jqueryvalidation.org/jQuery.validator.setDefaults/
	setDefaults: function( settings ) {
		$.extend( $.validator.defaults, settings );
	},

	messages: {
		required: "This field is required.",
		remote: "Please fix this field.",
		email: "Please enter a valid email address.",
		url: "Please enter a valid URL.",
		date: "Please enter a valid date.",
		dateISO: "Please enter a valid date (ISO).",
		number: "Please enter a valid number.",
		digits: "Please enter only digits.",
		creditcard: "Please enter a valid credit card number.",
		equalTo: "Please enter the same value again.",
		maxlength: $.validator.format("Please enter no more than {0} characters."),
		minlength: $.validator.format("Please enter at least {0} characters."),
		rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
		range: $.validator.format("Please enter a value between {0} and {1}."),
		max: $.validator.format("Please enter a value less than or equal to {0}."),
		min: $.validator.format("Please enter a value greater than or equal to {0}.")
	},

	autoCreateRanges: false,

	prototype: {

		init: function() {
			this.labelContainer = $(this.settings.errorLabelContainer);
			this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
			this.containers = $(this.settings.errorContainer).add( this.settings.errorLabelContainer );
			this.submitted = {};
			this.valueCache = {};
			this.pendingRequest = 0;
			this.pending = {};
			this.invalid = {};
			this.reset();

			var groups = (this.groups = {}),
				rules;
			$.each(this.settings.groups, function( key, value ) {
				if ( typeof value === "string" ) {
					value = value.split(/\s/);
				}
				$.each(value, function( index, name ) {
					groups[name] = key;
				});
			});
			rules = this.settings.rules;
			$.each(rules, function( key, value ) {
				rules[key] = $.validator.normalizeRule(value);
			});

			function delegate(event) {
				var validator = $.data(this[0].form, "validator"),
					eventType = "on" + event.type.replace(/^validate/, ""),
					settings = validator.settings;
				if ( settings[eventType] && !this.is( settings.ignore ) ) {
					settings[eventType].call(validator, this[0], event);
				}
			}
			$(this.currentForm)
				.validateDelegate(":text, [type='password'], [type='file'], select, textarea, " +
					"[type='number'], [type='search'] ,[type='tel'], [type='url'], " +
					"[type='email'], [type='datetime'], [type='date'], [type='month'], " +
					"[type='week'], [type='time'], [type='datetime-local'], " +
					"[type='range'], [type='color'] ",
					"focusin focusout keyup", delegate)
				.validateDelegate("[type='radio'], [type='checkbox'], select, option", "click", delegate);

			if ( this.settings.invalidHandler ) {
				$(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
			}

			// Add aria-required to any Static/Data/Class required fields before first validation
			// Screen readers require this attribute to be present before the initial submission http://www.w3.org/TR/WCAG-TECHS/ARIA2.html
			$(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true");
		},

		// http://jqueryvalidation.org/Validator.form/
		form: function() {
			this.checkForm();
			$.extend(this.submitted, this.errorMap);
			this.invalid = $.extend({}, this.errorMap);
			if ( !this.valid() ) {
				$(this.currentForm).triggerHandler("invalid-form", [ this ]);
			}
			this.showErrors();
			return this.valid();
		},

		checkForm: function() {
			this.prepareForm();
			for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) {
				this.check( elements[i] );
			}
			return this.valid();
		},

		// http://jqueryvalidation.org/Validator.element/
		element: function( element ) {
			var cleanElement = this.clean( element ),
				checkElement = this.validationTargetFor( cleanElement ),
				result = true;

			this.lastElement = checkElement;

			if ( checkElement === undefined ) {
				delete this.invalid[ cleanElement.name ];
			} else {
				this.prepareElement( checkElement );
				this.currentElements = $( checkElement );

				result = this.check( checkElement ) !== false;
				if (result) {
					delete this.invalid[checkElement.name];
				} else {
					this.invalid[checkElement.name] = true;
				}
			}
			// Add aria-invalid status for screen readers
			$( element ).attr( "aria-invalid", !result );

			if ( !this.numberOfInvalids() ) {
				// Hide error containers on last error
				this.toHide = this.toHide.add( this.containers );
			}
			this.showErrors();
			return result;
		},

		// http://jqueryvalidation.org/Validator.showErrors/
		showErrors: function( errors ) {
			if ( errors ) {
				// add items to error list and map
				$.extend( this.errorMap, errors );
				this.errorList = [];
				for ( var name in errors ) {
					this.errorList.push({
						message: errors[name],
						element: this.findByName(name)[0]
					});
				}
				// remove items from success list
				this.successList = $.grep( this.successList, function( element ) {
					return !(element.name in errors);
				});
			}
			if ( this.settings.showErrors ) {
				this.settings.showErrors.call( this, this.errorMap, this.errorList );
			} else {
				this.defaultShowErrors();
			}
		},

		// http://jqueryvalidation.org/Validator.resetForm/
		resetForm: function() {
			if ( $.fn.resetForm ) {
				$(this.currentForm).resetForm();
			}
			this.submitted = {};
			this.lastElement = null;
			this.prepareForm();
			this.hideErrors();
			this.elements()
					.removeClass( this.settings.errorClass )
					.removeData( "previousValue" )
					.removeAttr( "aria-invalid" );
		},

		numberOfInvalids: function() {
			return this.objectLength(this.invalid);
		},

		objectLength: function( obj ) {
			/* jshint unused: false */
			var count = 0,
				i;
			for ( i in obj ) {
				count++;
			}
			return count;
		},

		hideErrors: function() {
			this.addWrapper( this.toHide ).hide();
		},

		valid: function() {
			return this.size() === 0;
		},

		size: function() {
			return this.errorList.length;
		},

		focusInvalid: function() {
			if ( this.settings.focusInvalid ) {
				try {
					$(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
					.filter(":visible")
					.focus()
					// manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
					.trigger("focusin");
				} catch(e) {
					// ignore IE throwing errors when focusing hidden elements
				}
			}
		},

		findLastActive: function() {
			var lastActive = this.lastActive;
			return lastActive && $.grep(this.errorList, function( n ) {
				return n.element.name === lastActive.name;
			}).length === 1 && lastActive;
		},

		elements: function() {
			var validator = this,
				rulesCache = {};

			// select all valid inputs inside the form (no submit or reset buttons)
			return $(this.currentForm)
			.find("input, select, textarea")
			.not(":submit, :reset, :image, [disabled]")
			.not( this.settings.ignore )
			.filter(function() {
				if ( !this.name && validator.settings.debug && window.console ) {
					console.error( "%o has no name assigned", this);
				}

				// select only the first element for each name, and only those with rules specified
				if ( this.name in rulesCache || !validator.objectLength($(this).rules()) ) {
					return false;
				}

				rulesCache[this.name] = true;
				return true;
			});
		},

		clean: function( selector ) {
			return $(selector)[0];
		},

		errors: function() {
			var errorClass = this.settings.errorClass.split(" ").join(".");
			return $(this.settings.errorElement + "." + errorClass, this.errorContext);
		},

		reset: function() {
			this.successList = [];
			this.errorList = [];
			this.errorMap = {};
			this.toShow = $([]);
			this.toHide = $([]);
			this.currentElements = $([]);
		},

		prepareForm: function() {
			this.reset();
			this.toHide = this.errors().add( this.containers );
		},

		prepareElement: function( element ) {
			this.reset();
			this.toHide = this.errorsFor(element);
		},

		elementValue: function( element ) {
			var val,
				$element = $(element),
				type = $element.attr("type");

			if ( type === "radio" || type === "checkbox" ) {
				return $("input[name='" + $element.attr("name") + "']:checked").val();
			}

			val = $element.val();
			if ( typeof val === "string" ) {
				return val.replace(/\r/g, "");
			}
			return val;
		},

		check: function( element ) {
			element = this.validationTargetFor( this.clean( element ) );

			var rules = $(element).rules(),
				rulesCount = $.map( rules, function(n, i) {
					return i;
				}).length,
				dependencyMismatch = false,
				val = this.elementValue(element),
				result, method, rule;

			for (method in rules ) {
				rule = { method: method, parameters: rules[method] };
				try {

					result = $.validator.methods[method].call( this, val, element, rule.parameters );

					// if a method indicates that the field is optional and therefore valid,
					// don't mark it as valid when there are no other rules
					if ( result === "dependency-mismatch" && rulesCount === 1 ) {
						dependencyMismatch = true;
						continue;
					}
					dependencyMismatch = false;

					if ( result === "pending" ) {
						this.toHide = this.toHide.not( this.errorsFor(element) );
						return;
					}

					if ( !result ) {
						this.formatAndAdd( element, rule );
						return false;
					}
				} catch(e) {
					if ( this.settings.debug && window.console ) {
						console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
					}
					throw e;
				}
			}
			if ( dependencyMismatch ) {
				return;
			}
			if ( this.objectLength(rules) ) {
				this.successList.push(element);
			}
			return true;
		},

		// return the custom message for the given element and validation method
		// specified in the element's HTML5 data attribute
		// return the generic message if present and no method specific message is present
		customDataMessage: function( element, method ) {
			return $( element ).data( "msg" + method[ 0 ].toUpperCase() +
				method.substring( 1 ).toLowerCase() ) || $( element ).data("msg");
		},

		// return the custom message for the given element name and validation method
		customMessage: function( name, method ) {
			var m = this.settings.messages[name];
			return m && (m.constructor === String ? m : m[method]);
		},

		// return the first defined argument, allowing empty strings
		findDefined: function() {
			for (var i = 0; i < arguments.length; i++) {
				if ( arguments[i] !== undefined ) {
					return arguments[i];
				}
			}
			return undefined;
		},

		defaultMessage: function( element, method ) {
			return this.findDefined(
				this.customMessage( element.name, method ),
				this.customDataMessage( element, method ),
				// title is never undefined, so handle empty string as undefined
				!this.settings.ignoreTitle && element.title || undefined,
				$.validator.messages[method],
				"<strong>Warning: No message defined for " + element.name + "</strong>"
			);
		},

		formatAndAdd: function( element, rule ) {
			var message = this.defaultMessage( element, rule.method ),
				theregex = /\$?\{(\d+)\}/g;
			if ( typeof message === "function" ) {
				message = message.call(this, rule.parameters, element);
			} else if (theregex.test(message)) {
				message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);
			}
			this.errorList.push({
				message: message,
				element: element,
				method: rule.method
			});

			this.errorMap[element.name] = message;
			this.submitted[element.name] = message;
		},

		addWrapper: function( toToggle ) {
			if ( this.settings.wrapper ) {
				toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
			}
			return toToggle;
		},

		defaultShowErrors: function() {
			var i, elements, error;
			for ( i = 0; this.errorList[i]; i++ ) {
				error = this.errorList[i];
				if ( this.settings.highlight ) {
					this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
				}
				this.showLabel( error.element, error.message );
			}
			if ( this.errorList.length ) {
				this.toShow = this.toShow.add( this.containers );
			}
			if ( this.settings.success ) {
				for ( i = 0; this.successList[i]; i++ ) {
					this.showLabel( this.successList[i] );
				}
			}
			if ( this.settings.unhighlight ) {
				for ( i = 0, elements = this.validElements(); elements[i]; i++ ) {
					this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );
				}
			}
			this.toHide = this.toHide.not( this.toShow );
			this.hideErrors();
			this.addWrapper( this.toShow ).show();
		},

		validElements: function() {
			return this.currentElements.not(this.invalidElements());
		},

		invalidElements: function() {
			return $(this.errorList).map(function() {
				return this.element;
			});
		},

		showLabel: function( element, message ) {
			var label = this.errorsFor( element );
			if ( label.length ) {
				// refresh error/success class
				label.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );
				// replace message on existing label
				label.html(message);
			} else {
				// create label
				label = $("<" + this.settings.errorElement + ">")
					.attr("for", this.idOrName(element))
					.addClass(this.settings.errorClass)
					.html(message || "");
				if ( this.settings.wrapper ) {
					// make sure the element is visible, even in IE
					// actually showing the wrapped element is handled elsewhere
					label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
				}
				if ( !this.labelContainer.append(label).length ) {
					if ( this.settings.errorPlacement ) {
						this.settings.errorPlacement(label, $(element) );
					} else {
						label.insertAfter(element);
					}
				}
			}
			if ( !message && this.settings.success ) {
				label.text("");
				if ( typeof this.settings.success === "string" ) {
					label.addClass( this.settings.success );
				} else {
					this.settings.success( label, element );
				}
			}
			this.toShow = this.toShow.add(label);
		},

		errorsFor: function( element ) {
			var name = this.idOrName(element);
			return this.errors().filter(function() {
				return $(this).attr("for") === name;
			});
		},

		idOrName: function( element ) {
			return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
		},

		validationTargetFor: function( element ) {
			// if radio/checkbox, validate first element in group instead
			if ( this.checkable(element) ) {
				element = this.findByName( element.name ).not(this.settings.ignore)[0];
			}
			return element;
		},

		checkable: function( element ) {
			return (/radio|checkbox/i).test(element.type);
		},

		findByName: function( name ) {
			return $(this.currentForm).find("[name='" + name + "']");
		},

		getLength: function( value, element ) {
			switch ( element.nodeName.toLowerCase() ) {
			case "select":
				return $("option:selected", element).length;
			case "input":
				if ( this.checkable( element) ) {
					return this.findByName(element.name).filter(":checked").length;
				}
			}
			return value.length;
		},

		depend: function( param, element ) {
			return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
		},

		dependTypes: {
			"boolean": function( param ) {
				return param;
			},
			"string": function( param, element ) {
				return !!$(param, element.form).length;
			},
			"function": function( param, element ) {
				return param(element);
			}
		},

		optional: function( element ) {
			var val = this.elementValue(element);
			return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
		},

		startRequest: function( element ) {
			if ( !this.pending[element.name] ) {
				this.pendingRequest++;
				this.pending[element.name] = true;
			}
		},

		stopRequest: function( element, valid ) {
			this.pendingRequest--;
			// sometimes synchronization fails, make sure pendingRequest is never < 0
			if ( this.pendingRequest < 0 ) {
				this.pendingRequest = 0;
			}
			delete this.pending[element.name];
			if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
				$(this.currentForm).submit();
				this.formSubmitted = false;
			} else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
				$(this.currentForm).triggerHandler("invalid-form", [ this ]);
				this.formSubmitted = false;
			}
		},

		previousValue: function( element ) {
			return $.data(element, "previousValue") || $.data(element, "previousValue", {
				old: null,
				valid: true,
				message: this.defaultMessage( element, "remote" )
			});
		}

	},

	classRuleSettings: {
		required: { required: true },
		email: { email: true },
		url: { url: true },
		date: { date: true },
		dateISO: { dateISO: true },
		number: { number: true },
		digits: { digits: true },
		creditcard: { creditcard: true }
	},

	addClassRules: function( className, rules ) {
		if ( className.constructor === String ) {
			this.classRuleSettings[className] = rules;
		} else {
			$.extend(this.classRuleSettings, className);
		}
	},

	classRules: function( element ) {
		var rules = {},
			classes = $(element).attr("class");

		if ( classes ) {
			$.each(classes.split(" "), function() {
				if ( this in $.validator.classRuleSettings ) {
					$.extend(rules, $.validator.classRuleSettings[this]);
				}
			});
		}
		return rules;
	},

	attributeRules: function( element ) {
		var rules = {},
			$element = $(element),
			type = element.getAttribute("type"),
			method, value;

		for (method in $.validator.methods) {

			// support for <input required> in both html5 and older browsers
			if ( method === "required" ) {
				value = element.getAttribute(method);
				// Some browsers return an empty string for the required attribute
				// and non-HTML5 browsers might have required="" markup
				if ( value === "" ) {
					value = true;
				}
				// force non-HTML5 browsers to return bool
				value = !!value;
			} else {
				value = $element.attr(method);
			}

			// convert the value to a number for number inputs, and for text for backwards compability
			// allows type="date" and others to be compared as strings
			if ( /min|max/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
				value = Number(value);
			}

			if ( value || value === 0 ) {
				rules[method] = value;
			} else if ( type === method && type !== "range" ) {
				// exception: the jquery validate 'range' method
				// does not test for the html5 'range' type
				rules[method] = true;
			}
		}

		// maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs
		if ( rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength) ) {
			delete rules.maxlength;
		}

		return rules;
	},

	dataRules: function( element ) {
		var method, value,
			rules = {}, $element = $( element );
		for ( method in $.validator.methods ) {
			value = $element.data( "rule" + method[ 0 ].toUpperCase() + method.substring( 1 ).toLowerCase() );
			if ( value !== undefined ) {
				rules[ method ] = value;
			}
		}
		return rules;
	},

	staticRules: function( element ) {
		var rules = {},
			validator = $.data(element.form, "validator");

		if ( validator.settings.rules ) {
			rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
		}
		return rules;
	},

	normalizeRules: function( rules, element ) {
		// handle dependency check
		$.each(rules, function( prop, val ) {
			// ignore rule when param is explicitly false, eg. required:false
			if ( val === false ) {
				delete rules[prop];
				return;
			}
			if ( val.param || val.depends ) {
				var keepRule = true;
				switch (typeof val.depends) {
				case "string":
					keepRule = !!$(val.depends, element.form).length;
					break;
				case "function":
					keepRule = val.depends.call(element, element);
					break;
				}
				if ( keepRule ) {
					rules[prop] = val.param !== undefined ? val.param : true;
				} else {
					delete rules[prop];
				}
			}
		});

		// evaluate parameters
		$.each(rules, function( rule, parameter ) {
			rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
		});

		// clean number parameters
		$.each([ "minlength", "maxlength" ], function() {
			if ( rules[this] ) {
				rules[this] = Number(rules[this]);
			}
		});
		$.each([ "rangelength", "range" ], function() {
			var parts;
			if ( rules[this] ) {
				if ( $.isArray(rules[this]) ) {
					rules[this] = [ Number(rules[this][0]), Number(rules[this][1]) ];
				} else if ( typeof rules[this] === "string" ) {
					parts = rules[this].split(/[\s,]+/);
					rules[this] = [ Number(parts[0]), Number(parts[1]) ];
				}
			}
		});

		if ( $.validator.autoCreateRanges ) {
			// auto-create ranges
			if ( rules.min && rules.max ) {
				rules.range = [ rules.min, rules.max ];
				delete rules.min;
				delete rules.max;
			}
			if ( rules.minlength && rules.maxlength ) {
				rules.rangelength = [ rules.minlength, rules.maxlength ];
				delete rules.minlength;
				delete rules.maxlength;
			}
		}

		return rules;
	},

	// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
	normalizeRule: function( data ) {
		if ( typeof data === "string" ) {
			var transformed = {};
			$.each(data.split(/\s/), function() {
				transformed[this] = true;
			});
			data = transformed;
		}
		return data;
	},

	// http://jqueryvalidation.org/jQuery.validator.addMethod/
	addMethod: function( name, method, message ) {
		$.validator.methods[name] = method;
		$.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
		if ( method.length < 3 ) {
			$.validator.addClassRules(name, $.validator.normalizeRule(name));
		}
	},

	methods: {

		// http://jqueryvalidation.org/required-method/
		required: function( value, element, param ) {
			// check if dependency is met
			if ( !this.depend(param, element) ) {
				return "dependency-mismatch";
			}
			if ( element.nodeName.toLowerCase() === "select" ) {
				// could be an array for select-multiple or a string, both are fine this way
				var val = $(element).val();
				return val && val.length > 0;
			}
			if ( this.checkable(element) ) {
				return this.getLength(value, element) > 0;
			}
			return $.trim(value).length > 0;
		},

		// http://jqueryvalidation.org/email-method/
		email: function( value, element ) {
			// From http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state-%28type=email%29
			// Retrieved 2014-01-14
			// If you have a problem with this implementation, report a bug against the above spec
			// Or use custom methods to implement your own email validation
			return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
		},

		// http://jqueryvalidation.org/url-method/
		url: function( value, element ) {
			// contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
			return this.optional(element) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
		},

		// http://jqueryvalidation.org/date-method/
		date: function( value, element ) {
			return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
		},

		// http://jqueryvalidation.org/dateISO-method/
		dateISO: function( value, element ) {
			return this.optional(element) || /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(value);
		},

		// http://jqueryvalidation.org/number-method/
		number: function( value, element ) {
			return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
		},

		// http://jqueryvalidation.org/digits-method/
		digits: function( value, element ) {
			return this.optional(element) || /^\d+$/.test(value);
		},

		// http://jqueryvalidation.org/creditcard-method/
		// based on http://en.wikipedia.org/wiki/Luhn/
		creditcard: function( value, element ) {
			if ( this.optional(element) ) {
				return "dependency-mismatch";
			}
			// accept only spaces, digits and dashes
			if ( /[^0-9 \-]+/.test(value) ) {
				return false;
			}
			var nCheck = 0,
				nDigit = 0,
				bEven = false,
				n, cDigit;

			value = value.replace(/\D/g, "");

			// Basing min and max length on
			// http://developer.ean.com/general_info/Valid_Credit_Card_Types
			if ( value.length < 13 || value.length > 19 ) {
				return false;
			}

			for ( n = value.length - 1; n >= 0; n--) {
				cDigit = value.charAt(n);
				nDigit = parseInt(cDigit, 10);
				if ( bEven ) {
					if ( (nDigit *= 2) > 9 ) {
						nDigit -= 9;
					}
				}
				nCheck += nDigit;
				bEven = !bEven;
			}

			return (nCheck % 10) === 0;
		},

		// http://jqueryvalidation.org/minlength-method/
		minlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);
			return this.optional(element) || length >= param;
		},

		// http://jqueryvalidation.org/maxlength-method/
		maxlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);
			return this.optional(element) || length <= param;
		},

		// http://jqueryvalidation.org/rangelength-method/
		rangelength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);
			return this.optional(element) || ( length >= param[0] && length <= param[1] );
		},

		// http://jqueryvalidation.org/min-method/
		min: function( value, element, param ) {
			return this.optional(element) || value >= param;
		},

		// http://jqueryvalidation.org/max-method/
		max: function( value, element, param ) {
			return this.optional(element) || value <= param;
		},

		// http://jqueryvalidation.org/range-method/
		range: function( value, element, param ) {
			return this.optional(element) || ( value >= param[0] && value <= param[1] );
		},

		// http://jqueryvalidation.org/equalTo-method/
		equalTo: function( value, element, param ) {
			// bind to the blur event of the target in order to revalidate whenever the target field is updated
			// TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
			var target = $(param);
			if ( this.settings.onfocusout ) {
				target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
					$(element).valid();
				});
			}
			return value === target.val();
		},

		// http://jqueryvalidation.org/remote-method/
		remote: function( value, element, param ) {
			if ( this.optional(element) ) {
				return "dependency-mismatch";
			}

			var previous = this.previousValue(element),
				validator, data;

			if (!this.settings.messages[element.name] ) {
				this.settings.messages[element.name] = {};
			}
			previous.originalMessage = this.settings.messages[element.name].remote;
			this.settings.messages[element.name].remote = previous.message;

			param = typeof param === "string" && { url: param } || param;

			if ( previous.old === value ) {
				return previous.valid;
			}

			previous.old = value;
			validator = this;
			this.startRequest(element);
			data = {};
			data[element.name] = value;
			$.ajax($.extend(true, {
				url: param,
				mode: "abort",
				port: "validate" + element.name,
				dataType: "json",
				data: data,
				context: validator.currentForm,
				success: function( response ) {
					var valid = response === true || response === "true",
						errors, message, submitted;

					validator.settings.messages[element.name].remote = previous.originalMessage;
					if ( valid ) {
						submitted = validator.formSubmitted;
						validator.prepareElement(element);
						validator.formSubmitted = submitted;
						validator.successList.push(element);
						delete validator.invalid[element.name];
						validator.showErrors();
					} else {
						errors = {};
						message = response || validator.defaultMessage( element, "remote" );
						errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
						validator.invalid[element.name] = true;
						validator.showErrors(errors);
					}
					previous.valid = valid;
					validator.stopRequest(element, valid);
				}
			}, param));
			return "pending";
		}

	}

});

$.format = function deprecated() {
	throw "$.format has been deprecated. Please use $.validator.format instead.";
};

}(jQuery));

// ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()
(function($) {
	var pendingRequests = {},
		ajax;
	// Use a prefilter if available (1.5+)
	if ( $.ajaxPrefilter ) {
		$.ajaxPrefilter(function( settings, _, xhr ) {
			var port = settings.port;
			if ( settings.mode === "abort" ) {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				pendingRequests[port] = xhr;
			}
		});
	} else {
		// Proxy ajax
		ajax = $.ajax;
		$.ajax = function( settings ) {
			var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
				port = ( "port" in settings ? settings : $.ajaxSettings ).port;
			if ( mode === "abort" ) {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				pendingRequests[port] = ajax.apply(this, arguments);
				return pendingRequests[port];
			}
			return ajax.apply(this, arguments);
		};
	}
}(jQuery));

// provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
// handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target
(function($) {
	$.extend($.fn, {
		validateDelegate: function( delegate, type, handler ) {
			return this.bind(type, function( event ) {
				var target = $(event.target);
				if ( target.is(delegate) ) {
					return handler.apply(target, arguments);
				}
			});
		}
	});
}(jQuery));

jQuery.validator.addMethod('notEqualTo', function(value, element, param) {
    return this.optional(element) || value !== $(element).closest('form').find(param).val();
}, 'Password must be different than Email.');

jQuery.validator.addMethod('notEqualToText', function(value, element, param) {
    return this.optional(element) || value !== param;
}, 'No equal.');

jQuery.validator.addMethod('equalToText', function(value, element, param) {
    return value === param;
});

jQuery.validator.addMethod('equalToIgnoreCase', function(value, element, param) {
    return this.optional(element) || value.toLowerCase() === $(element).closest('form').find(param).val().toLowerCase();
});

jQuery.validator.addMethod('spcEmail', function(value, element) {
    // RegExp differs from Hybris. We need to allow customer to enter spaces before or after email address
    if (this.optional(element) || /((^[A-Za-z0-9]+)|(^\s*([A-Za-z0-9]{1})[A-Za-z0-9\._%\+-]{0,62})([A-Za-z0-9]{1}))@([A-Za-z0-9]{1,63}\.|[A-Za-z0-9]{1}[A-Za-z0-9-]{0,61}[A-Za-z0-9]{1}\.)+([A-Za-z0-9]){2,63}\s*$/.test(value)) {
        var extension = value.split('.').pop();

        // Check if extension is not all-numeric
        return isNaN(Number(extension));
    }

    return false;

}, 'Invalid Email format.');

jQuery.validator.addMethod('spcASCII', function(value, element) {
    return this.optional(element) || value.split('').every(function(character) {
        return character.charCodeAt(0) <= 128;
    });
}, 'Sorry, only alphanumeric and special symbols allowed.');

jQuery.validator.addMethod('spcPassword', function(value, element) {
    return this.optional(element) || /^[A-Za-z0-9\`!?$%\^*()_\-+={\[}\]:;@'~#\|,\.\/&<>]+$/.test(value);
}, 'Password can only contain letters, numbers, and these special characters - `!?$?%^*()_-+={[}]:;@\'~#|,.?/&amp;&lt;&gt;)');

jQuery.validator.addMethod('equalToIgnoreCase', function(value, element, param) {
    return this.optional(element) || (value.toLowerCase() === $(param).val().toLowerCase());
}, 'Please enter the same value again.');

// Validation rule for Samsung galaxy note & Samsung galaxy s3 on Chrome because of disabled masked input plugin
(function($) {
    var userAgent = navigator.userAgent;
    var isSamsung = (/gt-p5210/i.test(userAgent) || /gt-i9300/i.test(userAgent)) && /chrome/i.test(userAgent);
    var regExp = isSamsung ? /^[ ]*\d{10}[ ]*$/ : /^(\d{3}-\d{3}-\d{4})$/;

    $.validator.addMethod('spcPhone', function(value, element) {
        return this.optional(element) || regExp.test(value);
    }, 'Please enter all 10 digits of the phone number.');
})(jQuery);

jQuery.validator.addMethod('spcPostalCode', function(value, element) {
    return this.optional(element) || /^[ ]*(\w{1}\d{1}\w{1} \d{1}\w{1}\d{1})[ ]*$/.test(value);
}, 'Please enter postal code in this format: X9X 9X9');

jQuery.validator.addMethod('notEqualToParamIgnoreCase', function(value, element, param) {
    return (value.toLowerCase() !== param.toLowerCase());
}, 'Please enter another value.');

jQuery.validator.addMethod('spcRequiredAndEqualToValue', function(value, element, selector) {
    if ($(selector).val() === element.name.replace('phones.', '')) {
        return value.length > 0;
    } else {
        return true;
    }

}, 'This field is required.');

jQuery.validator.addMethod('spcNumbersAndLetters', function(value, element) {
    return this.optional(element) || /^[ ]*[A-Za-z0-9]+[ ]*$/.test(value);
}, 'You can only use letters and/or the numbers');

jQuery.validator.addMethod('spcName', function(value, element) {
    return this.optional(element) || /^([\s\\\'-]*[A-Za-z]+[\s\\\'-]*)*$/.test(value);
}, 'You can only use letters, spaces and/or the symbols \' \\-');

jQuery.validator.addMethod('spcAddress', function(value, element) {
    return this.optional(element) || /^[A-Za-z0-9\'`\/#;,.()\-\s]+$/.test(value);
}, 'You can only use letters, numbers, and/or the symbols \' / # ; , . () - ');

jQuery.validator.addMethod('spcPoBox', function(value, element) {
    return this.optional(element) || !/po box|post office box/i.test(value);
}, 'This order cannot be shipped to a Po Box. Please provide a street address.');

/*
 jQuery Masked Input Plugin
 Copyright (c) 2007 - 2015 Josh Bush (digitalbush.com)
 Licensed under the MIT license (http://digitalbush.com/projects/masked-input-plugin/#license)
 Version: 1.4.1
 */
!function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : factory("object" == typeof exports ? require("jquery") : jQuery);
}(function($) {
    var caretTimeoutId, ua = navigator.userAgent, iPhone = /iphone/i.test(ua), chrome = /chrome/i.test(ua), android = /android/i.test(ua);
    $.mask = {
        definitions: {
            "9": "[0-9]",
            a: "[A-Za-z]",
            "*": "[A-Za-z0-9]"
        },
        autoclear: !0,
        dataName: "rawMaskFn",
        placeholder: "_"
    }, $.fn.extend({
        caret: function(begin, end) {
            var range;
            if (0 !== this.length && !this.is(":hidden")) return "number" == typeof begin ? (end = "number" == typeof end ? end : begin,
                this.each(function() {
                    this.setSelectionRange ? this.setSelectionRange(begin, end) : this.createTextRange && (range = this.createTextRange(),
                        range.collapse(!0), range.moveEnd("character", end), range.moveStart("character", begin),
                        range.select());
                })) : (this[0].setSelectionRange ? (begin = this[0].selectionStart, end = this[0].selectionEnd) : document.selection && document.selection.createRange && (range = document.selection.createRange(),
                begin = 0 - range.duplicate().moveStart("character", -1e5), end = begin + range.text.length),
            {
                begin: begin,
                end: end
            });
        },
        unmask: function() {
            return this.trigger("unmask");
        },
        mask: function(mask, settings) {
            var input, defs, tests, partialPosition, firstNonMaskPos, lastRequiredNonMaskPos, len, oldVal;
            if (!mask && this.length > 0) {
                input = $(this[0]);
                var fn = input.data($.mask.dataName);
                return fn ? fn() : void 0;
            }
            return settings = $.extend({
                autoclear: $.mask.autoclear,
                placeholder: $.mask.placeholder,
                completed: null
            }, settings), defs = $.mask.definitions, tests = [], partialPosition = len = mask.length,
                firstNonMaskPos = null, $.each(mask.split(""), function(i, c) {
                "?" == c ? (len--, partialPosition = i) : defs[c] ? (tests.push(new RegExp(defs[c])),
                null === firstNonMaskPos && (firstNonMaskPos = tests.length - 1), partialPosition > i && (lastRequiredNonMaskPos = tests.length - 1)) : tests.push(null);
            }), this.trigger("unmask").each(function() {
                function tryFireCompleted() {
                    if (settings.completed) {
                        for (var i = firstNonMaskPos; lastRequiredNonMaskPos >= i; i++) if (tests[i] && buffer[i] === getPlaceholder(i)) return;
                        settings.completed.call(input);
                    }
                }
                function getPlaceholder(i) {
                    return settings.placeholder.charAt(i < settings.placeholder.length ? i : 0);
                }
                function seekNext(pos) {
                    for (;++pos < len && !tests[pos]; ) ;
                    return pos;
                }
                function seekPrev(pos) {
                    for (;--pos >= 0 && !tests[pos]; ) ;
                    return pos;
                }
                function shiftL(begin, end) {
                    var i, j;
                    if (!(0 > begin)) {
                        for (i = begin, j = seekNext(end); len > i; i++) if (tests[i]) {
                            if (!(len > j && tests[i].test(buffer[j]))) break;
                            buffer[i] = buffer[j], buffer[j] = getPlaceholder(j), j = seekNext(j);
                        }
                        writeBuffer(), input.caret(Math.max(firstNonMaskPos, begin));
                    }
                }
                function shiftR(pos) {
                    var i, c, j, t;
                    for (i = pos, c = getPlaceholder(pos); len > i; i++) if (tests[i]) {
                        if (j = seekNext(i), t = buffer[i], buffer[i] = c, !(len > j && tests[j].test(t))) break;
                        c = t;
                    }
                }
                function androidInputEvent() {
                    var curVal = input.val(), pos = input.caret();
                    if (oldVal && oldVal.length && oldVal.length > curVal.length) {
                        for (checkVal(!0); pos.begin > 0 && !tests[pos.begin - 1]; ) pos.begin--;
                        if (0 === pos.begin) for (;pos.begin < firstNonMaskPos && !tests[pos.begin]; ) pos.begin++;
                        input.caret(pos.begin, pos.begin);
                    } else {
                        for (checkVal(!0); pos.begin < len && !tests[pos.begin]; ) pos.begin++;
                        input.caret(pos.begin, pos.begin);
                    }
                    tryFireCompleted();
                }
                function blurEvent() {
                    checkVal(), input.val() != focusText && input.change();
                }
                function keydownEvent(e) {
                    if (!input.prop("readonly")) {
                        var pos, begin, end, k = e.which || e.keyCode;
                        oldVal = input.val(), 8 === k || 46 === k || iPhone && 127 === k ? (pos = input.caret(),
                            begin = pos.begin, end = pos.end, end - begin === 0 && (begin = 46 !== k ? seekPrev(begin) : end = seekNext(begin - 1),
                            end = 46 === k ? seekNext(end) : end), clearBuffer(begin, end), shiftL(begin, end - 1),
                            e.preventDefault()) : 13 === k ? blurEvent.call(this, e) : 27 === k && (input.val(focusText),
                            input.caret(0, checkVal()), e.preventDefault());
                    }
                }
                function keypressEvent(e) {
                    if (!input.prop("readonly")) {
                        var p, c, next, k = e.which || e.keyCode, pos = input.caret();
                        if (!(e.ctrlKey || e.altKey || e.metaKey || 32 > k) && k && 13 !== k) {
                            if (pos.end - pos.begin !== 0 && (clearBuffer(pos.begin, pos.end), shiftL(pos.begin, pos.end - 1)),
                                    p = seekNext(pos.begin - 1), len > p && (c = String.fromCharCode(k), tests[p].test(c))) {
                                if (shiftR(p), buffer[p] = c, writeBuffer(), next = seekNext(p), android) {
                                    var proxy = function() {
                                        $.proxy($.fn.caret, input, next)();
                                    };
                                    setTimeout(proxy, 0);
                                } else input.caret(next);
                                pos.begin <= lastRequiredNonMaskPos && tryFireCompleted();
                            }
                            e.preventDefault();
                        }
                    }
                }
                function clearBuffer(start, end) {
                    var i;
                    for (i = start; end > i && len > i; i++) tests[i] && (buffer[i] = getPlaceholder(i));
                }
                function writeBuffer() {
                    input.val(buffer.join(""));
                }
                function checkVal(allow) {
                    var i, c, pos, test = input.val(), lastMatch = -1;
                    for (i = 0, pos = 0; len > i; i++) if (tests[i]) {
                        for (buffer[i] = getPlaceholder(i); pos++ < test.length; ) if (c = test.charAt(pos - 1),
                                tests[i].test(c)) {
                            buffer[i] = c, lastMatch = i;
                            break;
                        }
                        if (pos > test.length) {
                            clearBuffer(i + 1, len);
                            break;
                        }
                    } else buffer[i] === test.charAt(pos) && pos++, partialPosition > i && (lastMatch = i);
                    return allow ? writeBuffer() : partialPosition > lastMatch + 1 ? settings.autoclear || buffer.join("") === defaultBuffer ? (input.val() && input.val(""),
                        clearBuffer(0, len)) : writeBuffer() : (writeBuffer(), input.val(input.val().substring(0, lastMatch + 1))),
                        partialPosition ? i : firstNonMaskPos;
                }
                var input = $(this), buffer = $.map(mask.split(""), function(c, i) {
                    return "?" != c ? defs[c] ? getPlaceholder(i) : c : void 0;
                }), defaultBuffer = buffer.join(""), focusText = input.val();
                input.data($.mask.dataName, function() {
                    return $.map(buffer, function(c, i) {
                        return tests[i] && c != getPlaceholder(i) ? c : null;
                    }).join("");
                }), input.one("unmask", function() {
                    input.off(".mask").removeData($.mask.dataName);
                }).on("focus.mask", function() {
                    if (!input.prop("readonly")) {
                        clearTimeout(caretTimeoutId);
                        var pos;
                        focusText = input.val(), pos = checkVal(), caretTimeoutId = setTimeout(function() {
                            input.get(0) === document.activeElement && (writeBuffer(), pos == mask.replace("?", "").length ? input.caret(0, pos) : input.caret(pos));
                        }, 10);
                    }
                }).on("blur.mask", blurEvent).on("keydown.mask", keydownEvent).on("keypress.mask", keypressEvent).on("input.mask paste.mask", function() {
                    input.prop("readonly") || setTimeout(function() {
                        var pos = checkVal(!0);
                        input.caret(pos), tryFireCompleted();
                    }, 0);
                }), chrome && android && input.off("input.mask").on("input.mask", androidInputEvent),
                    checkVal();
            });
        }
    });
});
eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('7(A 3c.3q!=="9"){3c.3q=9(e){9 t(){}t.5S=e;p 5R t}}(9(e,t,n){h r={1N:9(t,n){h r=c;r.$k=e(n);r.6=e.4M({},e.37.2B.6,r.$k.v(),t);r.2A=t;r.4L()},4L:9(){9 r(e){h n,r="";7(A t.6.33==="9"){t.6.33.R(c,[e])}l{1A(n 38 e.d){7(e.d.5M(n)){r+=e.d[n].1K}}t.$k.2y(r)}t.3t()}h t=c,n;7(A t.6.2H==="9"){t.6.2H.R(c,[t.$k])}7(A t.6.2O==="2Y"){n=t.6.2O;e.5K(n,r)}l{t.3t()}},3t:9(){h e=c;e.$k.v("d-4I",e.$k.2x("2w")).v("d-4F",e.$k.2x("H"));e.$k.z({2u:0});e.2t=e.6.q;e.4E();e.5v=0;e.1X=14;e.23()},23:9(){h e=c;7(e.$k.25().N===0){p b}e.1M();e.4C();e.$S=e.$k.25();e.E=e.$S.N;e.4B();e.$G=e.$k.17(".d-1K");e.$K=e.$k.17(".d-1p");e.3u="U";e.13=0;e.26=[0];e.m=0;e.4A();e.4z()},4z:9(){h e=c;e.2V();e.2W();e.4t();e.30();e.4r();e.4q();e.2p();e.4o();7(e.6.2o!==b){e.4n(e.6.2o)}7(e.6.O===j){e.6.O=4Q}e.19();e.$k.17(".d-1p").z("4i","4h");7(!e.$k.2m(":3n")){e.3o()}l{e.$k.z("2u",1)}e.5O=b;e.2l();7(A e.6.3s==="9"){e.6.3s.R(c,[e.$k])}},2l:9(){h e=c;7(e.6.1Z===j){e.1Z()}7(e.6.1B===j){e.1B()}e.4g();7(A e.6.3w==="9"){e.6.3w.R(c,[e.$k])}},3x:9(){h e=c;7(A e.6.3B==="9"){e.6.3B.R(c,[e.$k])}e.3o();e.2V();e.2W();e.4f();e.30();e.2l();7(A e.6.3D==="9"){e.6.3D.R(c,[e.$k])}},3F:9(){h e=c;t.1c(9(){e.3x()},0)},3o:9(){h e=c;7(e.$k.2m(":3n")===b){e.$k.z({2u:0});t.18(e.1C);t.18(e.1X)}l{p b}e.1X=t.4d(9(){7(e.$k.2m(":3n")){e.3F();e.$k.4b({2u:1},2M);t.18(e.1X)}},5x)},4B:9(){h e=c;e.$S.5n(\'<L H="d-1p">\').4a(\'<L H="d-1K"></L>\');e.$k.17(".d-1p").4a(\'<L H="d-1p-49">\');e.1H=e.$k.17(".d-1p-49");e.$k.z("4i","4h")},1M:9(){h e=c,t=e.$k.1I(e.6.1M),n=e.$k.1I(e.6.2i);7(!t){e.$k.I(e.6.1M)}7(!n){e.$k.I(e.6.2i)}},2V:9(){h t=c,n,r;7(t.6.2Z===b){p b}7(t.6.48===j){t.6.q=t.2t=1;t.6.1h=b;t.6.1s=b;t.6.1O=b;t.6.22=b;t.6.1Q=b;t.6.1R=b;p b}n=e(t.6.47).1f();7(n>(t.6.1s[0]||t.2t)){t.6.q=t.2t}7(t.6.1h!==b){t.6.1h.5g(9(e,t){p e[0]-t[0]});1A(r=0;r<t.6.1h.N;r+=1){7(t.6.1h[r][0]<=n){t.6.q=t.6.1h[r][1]}}}l{7(n<=t.6.1s[0]&&t.6.1s!==b){t.6.q=t.6.1s[1]}7(n<=t.6.1O[0]&&t.6.1O!==b){t.6.q=t.6.1O[1]}7(n<=t.6.22[0]&&t.6.22!==b){t.6.q=t.6.22[1]}7(n<=t.6.1Q[0]&&t.6.1Q!==b){t.6.q=t.6.1Q[1]}7(n<=t.6.1R[0]&&t.6.1R!==b){t.6.q=t.6.1R[1]}}7(t.6.q>t.E&&t.6.46===j){t.6.q=t.E}},4r:9(){h n=c,r,i;7(n.6.2Z!==j){p b}i=e(t).1f();n.3d=9(){7(e(t).1f()!==i){7(n.6.O!==b){t.18(n.1C)}t.5d(r);r=t.1c(9(){i=e(t).1f();n.3x()},n.6.45)}};e(t).44(n.3d)},4f:9(){h e=c;e.2g(e.m);7(e.6.O!==b){e.3j()}},43:9(){h t=c,n=0,r=t.E-t.6.q;t.$G.2f(9(i){h s=e(c);s.z({1f:t.M}).v("d-1K",3p(i));7(i%t.6.q===0||i===r){7(!(i>r)){n+=1}}s.v("d-24",n)})},42:9(){h e=c,t=e.$G.N*e.M;e.$K.z({1f:t*2,T:0});e.43()},2W:9(){h e=c;e.40();e.42();e.3Z();e.3v()},40:9(){h e=c;e.M=1F.4O(e.$k.1f()/e.6.q)},3v:9(){h e=c,t=(e.E*e.M-e.6.q*e.M)*-1;7(e.6.q>e.E){e.D=0;t=0;e.3z=0}l{e.D=e.E-e.6.q;e.3z=t}p t},3Y:9(){p 0},3Z:9(){h t=c,n=0,r=0,i,s,o;t.J=[0];t.3E=[];1A(i=0;i<t.E;i+=1){r+=t.M;t.J.2D(-r);7(t.6.12===j){s=e(t.$G[i]);o=s.v("d-24");7(o!==n){t.3E[n]=t.J[i];n=o}}}},4t:9(){h t=c;7(t.6.2a===j||t.6.1v===j){t.B=e(\'<L H="d-5A"/>\').5m("5l",!t.F.15).5c(t.$k)}7(t.6.1v===j){t.3T()}7(t.6.2a===j){t.3S()}},3S:9(){h t=c,n=e(\'<L H="d-4U"/>\');t.B.1o(n);t.1u=e("<L/>",{"H":"d-1n",2y:t.6.2U[0]||""});t.1q=e("<L/>",{"H":"d-U",2y:t.6.2U[1]||""});n.1o(t.1u).1o(t.1q);n.w("2X.B 21.B",\'L[H^="d"]\',9(e){e.1l()});n.w("2n.B 28.B",\'L[H^="d"]\',9(n){n.1l();7(e(c).1I("d-U")){t.U()}l{t.1n()}})},3T:9(){h t=c;t.1k=e(\'<L H="d-1v"/>\');t.B.1o(t.1k);t.1k.w("2n.B 28.B",".d-1j",9(n){n.1l();7(3p(e(c).v("d-1j"))!==t.m){t.1g(3p(e(c).v("d-1j")),j)}})},3P:9(){h t=c,n,r,i,s,o,u;7(t.6.1v===b){p b}t.1k.2y("");n=0;r=t.E-t.E%t.6.q;1A(s=0;s<t.E;s+=1){7(s%t.6.q===0){n+=1;7(r===s){i=t.E-t.6.q}o=e("<L/>",{"H":"d-1j"});u=e("<3N></3N>",{4R:t.6.39===j?n:"","H":t.6.39===j?"d-59":""});o.1o(u);o.v("d-1j",r===s?i:s);o.v("d-24",n);t.1k.1o(o)}}t.35()},35:9(){h t=c;7(t.6.1v===b){p b}t.1k.17(".d-1j").2f(9(){7(e(c).v("d-24")===e(t.$G[t.m]).v("d-24")){t.1k.17(".d-1j").Z("2d");e(c).I("2d")}})},3e:9(){h e=c;7(e.6.2a===b){p b}7(e.6.2e===b){7(e.m===0&&e.D===0){e.1u.I("1b");e.1q.I("1b")}l 7(e.m===0&&e.D!==0){e.1u.I("1b");e.1q.Z("1b")}l 7(e.m===e.D){e.1u.Z("1b");e.1q.I("1b")}l 7(e.m!==0&&e.m!==e.D){e.1u.Z("1b");e.1q.Z("1b")}}},30:9(){h e=c;e.3P();e.3e();7(e.B){7(e.6.q>=e.E){e.B.3K()}l{e.B.3J()}}},55:9(){h e=c;7(e.B){e.B.3k()}},U:9(e){h t=c;7(t.1E){p b}t.m+=t.6.12===j?t.6.q:1;7(t.m>t.D+(t.6.12===j?t.6.q-1:0)){7(t.6.2e===j){t.m=0;e="2k"}l{t.m=t.D;p b}}t.1g(t.m,e)},1n:9(e){h t=c;7(t.1E){p b}7(t.6.12===j&&t.m>0&&t.m<t.6.q){t.m=0}l{t.m-=t.6.12===j?t.6.q:1}7(t.m<0){7(t.6.2e===j){t.m=t.D;e="2k"}l{t.m=0;p b}}t.1g(t.m,e)},1g:9(e,n,r){h i=c,s;7(i.1E){p b}7(A i.6.1Y==="9"){i.6.1Y.R(c,[i.$k])}7(e>=i.D){e=i.D}l 7(e<=0){e=0}i.m=i.d.m=e;7(i.6.2o!==b&&r!=="4e"&&i.6.q===1&&i.F.1x===j){i.1t(0);7(i.F.1x===j){i.1L(i.J[e])}l{i.1r(i.J[e],1)}i.2r();i.4l();p b}s=i.J[e];7(i.F.1x===j){i.1T=b;7(n===j){i.1t("1w");t.1c(9(){i.1T=j},i.6.1w)}l 7(n==="2k"){i.1t(i.6.2v);t.1c(9(){i.1T=j},i.6.2v)}l{i.1t("1m");t.1c(9(){i.1T=j},i.6.1m)}i.1L(s)}l{7(n===j){i.1r(s,i.6.1w)}l 7(n==="2k"){i.1r(s,i.6.2v)}l{i.1r(s,i.6.1m)}}i.2r()},2g:9(e){h t=c;7(A t.6.1Y==="9"){t.6.1Y.R(c,[t.$k])}7(e>=t.D||e===-1){e=t.D}l 7(e<=0){e=0}t.1t(0);7(t.F.1x===j){t.1L(t.J[e])}l{t.1r(t.J[e],1)}t.m=t.d.m=e;t.2r()},2r:9(){h e=c;e.26.2D(e.m);e.13=e.d.13=e.26[e.26.N-2];e.26.5f(0);7(e.13!==e.m){e.35();e.3e();e.2l();7(e.6.O!==b){e.3j()}}7(A e.6.3y==="9"&&e.13!==e.m){e.6.3y.R(c,[e.$k])}},X:9(){h e=c;e.3A="X";t.18(e.1C)},3j:9(){h e=c;7(e.3A!=="X"){e.19()}},19:9(){h e=c;e.3A="19";7(e.6.O===b){p b}t.18(e.1C);e.1C=t.4d(9(){e.U(j)},e.6.O)},1t:9(e){h t=c;7(e==="1m"){t.$K.z(t.2z(t.6.1m))}l 7(e==="1w"){t.$K.z(t.2z(t.6.1w))}l 7(A e!=="2Y"){t.$K.z(t.2z(e))}},2z:9(e){p{"-1G-1a":"2C "+e+"1z 2s","-1W-1a":"2C "+e+"1z 2s","-o-1a":"2C "+e+"1z 2s",1a:"2C "+e+"1z 2s"}},3H:9(){p{"-1G-1a":"","-1W-1a":"","-o-1a":"",1a:""}},3I:9(e){p{"-1G-P":"1i("+e+"V, C, C)","-1W-P":"1i("+e+"V, C, C)","-o-P":"1i("+e+"V, C, C)","-1z-P":"1i("+e+"V, C, C)",P:"1i("+e+"V, C,C)"}},1L:9(e){h t=c;t.$K.z(t.3I(e))},3L:9(e){h t=c;t.$K.z({T:e})},1r:9(e,t){h n=c;n.29=b;n.$K.X(j,j).4b({T:e},{54:t||n.6.1m,3M:9(){n.29=j}})},4E:9(){h e=c,r="1i(C, C, C)",i=n.56("L"),s,o,u,a;i.2w.3O="  -1W-P:"+r+"; -1z-P:"+r+"; -o-P:"+r+"; -1G-P:"+r+"; P:"+r;s=/1i\\(C, C, C\\)/g;o=i.2w.3O.5i(s);u=o!==14&&o.N===1;a="5z"38 t||t.5Q.4P;e.F={1x:u,15:a}},4q:9(){h e=c;7(e.6.27!==b||e.6.1U!==b){e.3Q();e.3R()}},4C:9(){h e=c,t=["s","e","x"];e.16={};7(e.6.27===j&&e.6.1U===j){t=["2X.d 21.d","2N.d 3U.d","2n.d 3V.d 28.d"]}l 7(e.6.27===b&&e.6.1U===j){t=["2X.d","2N.d","2n.d 3V.d"]}l 7(e.6.27===j&&e.6.1U===b){t=["21.d","3U.d","28.d"]}e.16.3W=t[0];e.16.2K=t[1];e.16.2J=t[2]},3R:9(){h t=c;t.$k.w("5y.d",9(e){e.1l()});t.$k.w("21.3X",9(t){p e(t.1d).2m("5C, 5E, 5F, 5N")})},3Q:9(){9 s(e){7(e.2b!==W){p{x:e.2b[0].2c,y:e.2b[0].41}}7(e.2b===W){7(e.2c!==W){p{x:e.2c,y:e.41}}7(e.2c===W){p{x:e.52,y:e.53}}}}9 o(t){7(t==="w"){e(n).w(r.16.2K,a);e(n).w(r.16.2J,f)}l 7(t==="Q"){e(n).Q(r.16.2K);e(n).Q(r.16.2J)}}9 u(n){h u=n.3h||n||t.3g,a;7(u.5a===3){p b}7(r.E<=r.6.q){p}7(r.29===b&&!r.6.3f){p b}7(r.1T===b&&!r.6.3f){p b}7(r.6.O!==b){t.18(r.1C)}7(r.F.15!==j&&!r.$K.1I("3b")){r.$K.I("3b")}r.11=0;r.Y=0;e(c).z(r.3H());a=e(c).2h();i.2S=a.T;i.2R=s(u).x-a.T;i.2P=s(u).y-a.5o;o("w");i.2j=b;i.2L=u.1d||u.4c}9 a(o){h u=o.3h||o||t.3g,a,f;r.11=s(u).x-i.2R;r.2I=s(u).y-i.2P;r.Y=r.11-i.2S;7(A r.6.2E==="9"&&i.3C!==j&&r.Y!==0){i.3C=j;r.6.2E.R(r,[r.$k])}7((r.Y>8||r.Y<-8)&&r.F.15===j){7(u.1l!==W){u.1l()}l{u.5L=b}i.2j=j}7((r.2I>10||r.2I<-10)&&i.2j===b){e(n).Q("2N.d")}a=9(){p r.Y/5};f=9(){p r.3z+r.Y/5};r.11=1F.3v(1F.3Y(r.11,a()),f());7(r.F.1x===j){r.1L(r.11)}l{r.3L(r.11)}}9 f(n){h s=n.3h||n||t.3g,u,a,f;s.1d=s.1d||s.4c;i.3C=b;7(r.F.15!==j){r.$K.Z("3b")}7(r.Y<0){r.1y=r.d.1y="T"}l{r.1y=r.d.1y="3i"}7(r.Y!==0){u=r.4j();r.1g(u,b,"4e");7(i.2L===s.1d&&r.F.15!==j){e(s.1d).w("3a.4k",9(t){t.4S();t.4T();t.1l();e(t.1d).Q("3a.4k")});a=e.4N(s.1d,"4V").3a;f=a.4W();a.4X(0,0,f)}}o("Q")}h r=c,i={2R:0,2P:0,4Y:0,2S:0,2h:14,4Z:14,50:14,2j:14,51:14,2L:14};r.29=j;r.$k.w(r.16.3W,".d-1p",u)},4j:9(){h e=c,t=e.4m();7(t>e.D){e.m=e.D;t=e.D}l 7(e.11>=0){t=0;e.m=0}p t},4m:9(){h t=c,n=t.6.12===j?t.3E:t.J,r=t.11,i=14;e.2f(n,9(s,o){7(r-t.M/20>n[s+1]&&r-t.M/20<o&&t.34()==="T"){i=o;7(t.6.12===j){t.m=e.4p(i,t.J)}l{t.m=s}}l 7(r+t.M/20<o&&r+t.M/20>(n[s+1]||n[s]-t.M)&&t.34()==="3i"){7(t.6.12===j){i=n[s+1]||n[n.N-1];t.m=e.4p(i,t.J)}l{i=n[s+1];t.m=s+1}}});p t.m},34:9(){h e=c,t;7(e.Y<0){t="3i";e.3u="U"}l{t="T";e.3u="1n"}p t},4A:9(){h e=c;e.$k.w("d.U",9(){e.U()});e.$k.w("d.1n",9(){e.1n()});e.$k.w("d.19",9(t,n){e.6.O=n;e.19();e.32="19"});e.$k.w("d.X",9(){e.X();e.32="X"});e.$k.w("d.1g",9(t,n){e.1g(n)});e.$k.w("d.2g",9(t,n){e.2g(n)})},2p:9(){h e=c;7(e.6.2p===j&&e.F.15!==j&&e.6.O!==b){e.$k.w("57",9(){e.X()});e.$k.w("58",9(){7(e.32!=="X"){e.19()}})}},1Z:9(){h t=c,n,r,i,s,o;7(t.6.1Z===b){p b}1A(n=0;n<t.E;n+=1){r=e(t.$G[n]);7(r.v("d-1e")==="1e"){4s}i=r.v("d-1K");s=r.17(".5b");7(A s.v("1J")!=="2Y"){r.v("d-1e","1e");4s}7(r.v("d-1e")===W){s.3K();r.I("4u").v("d-1e","5e")}7(t.6.4v===j){o=i>=t.m}l{o=j}7(o&&i<t.m+t.6.q&&s.N){t.4w(r,s)}}},4w:9(e,n){9 o(){e.v("d-1e","1e").Z("4u");n.5h("v-1J");7(r.6.4x==="4y"){n.5j(5k)}l{n.3J()}7(A r.6.2T==="9"){r.6.2T.R(c,[r.$k])}}9 u(){i+=1;7(r.2Q(n.3l(0))||s===j){o()}l 7(i<=2q){t.1c(u,2q)}l{o()}}h r=c,i=0,s;7(n.5p("5q")==="5r"){n.z("5s-5t","5u("+n.v("1J")+")");s=j}l{n[0].1J=n.v("1J")}u()},1B:9(){9 s(){h r=e(n.$G[n.m]).2G();n.1H.z("2G",r+"V");7(!n.1H.1I("1B")){t.1c(9(){n.1H.I("1B")},0)}}9 o(){i+=1;7(n.2Q(r.3l(0))){s()}l 7(i<=2q){t.1c(o,2q)}l{n.1H.z("2G","")}}h n=c,r=e(n.$G[n.m]).17("5w"),i;7(r.3l(0)!==W){i=0;o()}l{s()}},2Q:9(e){h t;7(!e.3M){p b}t=A e.4D;7(t!=="W"&&e.4D===0){p b}p j},4g:9(){h t=c,n;7(t.6.2F===j){t.$G.Z("2d")}t.1D=[];1A(n=t.m;n<t.m+t.6.q;n+=1){t.1D.2D(n);7(t.6.2F===j){e(t.$G[n]).I("2d")}}t.d.1D=t.1D},4n:9(e){h t=c;t.4G="d-"+e+"-5B";t.4H="d-"+e+"-38"},4l:9(){9 a(e){p{2h:"5D",T:e+"V"}}h e=c,t=e.4G,n=e.4H,r=e.$G.1S(e.m),i=e.$G.1S(e.13),s=1F.4J(e.J[e.m])+e.J[e.13],o=1F.4J(e.J[e.m])+e.M/2,u="5G 5H 5I 5J";e.1E=j;e.$K.I("d-1P").z({"-1G-P-1P":o+"V","-1W-4K-1P":o+"V","4K-1P":o+"V"});i.z(a(s,10)).I(t).w(u,9(){e.3m=j;i.Q(u);e.31(i,t)});r.I(n).w(u,9(){e.36=j;r.Q(u);e.31(r,n)})},31:9(e,t){h n=c;e.z({2h:"",T:""}).Z(t);7(n.3m&&n.36){n.$K.Z("d-1P");n.3m=b;n.36=b;n.1E=b}},4o:9(){h e=c;e.d={2A:e.2A,5P:e.$k,S:e.$S,G:e.$G,m:e.m,13:e.13,1D:e.1D,15:e.F.15,F:e.F,1y:e.1y}},3G:9(){h r=c;r.$k.Q(".d d 21.3X");e(n).Q(".d d");e(t).Q("44",r.3d)},1V:9(){h e=c;7(e.$k.25().N!==0){e.$K.3r();e.$S.3r().3r();7(e.B){e.B.3k()}}e.3G();e.$k.2x("2w",e.$k.v("d-4I")||"").2x("H",e.$k.v("d-4F"))},5T:9(){h e=c;e.X();t.18(e.1X);e.1V();e.$k.5U()},5V:9(t){h n=c,r=e.4M({},n.2A,t);n.1V();n.1N(r,n.$k)},5W:9(e,t){h n=c,r;7(!e){p b}7(n.$k.25().N===0){n.$k.1o(e);n.23();p b}n.1V();7(t===W||t===-1){r=-1}l{r=t}7(r>=n.$S.N||r===-1){n.$S.1S(-1).5X(e)}l{n.$S.1S(r).5Y(e)}n.23()},5Z:9(e){h t=c,n;7(t.$k.25().N===0){p b}7(e===W||e===-1){n=-1}l{n=e}t.1V();t.$S.1S(n).3k();t.23()}};e.37.2B=9(t){p c.2f(9(){7(e(c).v("d-1N")===j){p b}e(c).v("d-1N",j);h n=3c.3q(r);n.1N(t,c);e.v(c,"2B",n)})};e.37.2B.6={q:5,1h:b,1s:[60,4],1O:[61,3],22:[62,2],1Q:b,1R:[63,1],48:b,46:b,1m:2M,1w:64,2v:65,O:b,2p:b,2a:b,2U:["1n","U"],2e:j,12:b,1v:j,39:b,2Z:j,45:2M,47:t,1M:"d-66",2i:"d-2i",1Z:b,4v:j,4x:"4y",1B:b,2O:b,33:b,3f:j,27:j,1U:j,2F:b,2o:b,3B:b,3D:b,2H:b,3s:b,1Y:b,3y:b,3w:b,2E:b,2T:b}})(67,68,69)',62,382,'||||||options|if||function||false|this|owl||||var||true|elem|else|currentItem|||return|items|||||data|on|||css|typeof|owlControls|0px|maximumItem|itemsAmount|browser|owlItems|class|addClass|positionsInArray|owlWrapper|div|itemWidth|length|autoPlay|transform|off|apply|userItems|left|next|px|undefined|stop|newRelativeX|removeClass||newPosX|scrollPerPage|prevItem|null|isTouch|ev_types|find|clearInterval|play|transition|disabled|setTimeout|target|loaded|width|goTo|itemsCustom|translate3d|page|paginationWrapper|preventDefault|slideSpeed|prev|append|wrapper|buttonNext|css2slide|itemsDesktop|swapSpeed|buttonPrev|pagination|paginationSpeed|support3d|dragDirection|ms|for|autoHeight|autoPlayInterval|visibleItems|isTransition|Math|webkit|wrapperOuter|hasClass|src|item|transition3d|baseClass|init|itemsDesktopSmall|origin|itemsTabletSmall|itemsMobile|eq|isCss3Finish|touchDrag|unWrap|moz|checkVisible|beforeMove|lazyLoad||mousedown|itemsTablet|setVars|roundPages|children|prevArr|mouseDrag|mouseup|isCssFinish|navigation|touches|pageX|active|rewindNav|each|jumpTo|position|theme|sliding|rewind|eachMoveUpdate|is|touchend|transitionStyle|stopOnHover|100|afterGo|ease|orignalItems|opacity|rewindSpeed|style|attr|html|addCssSpeed|userOptions|owlCarousel|all|push|startDragging|addClassActive|height|beforeInit|newPosY|end|move|targetElement|200|touchmove|jsonPath|offsetY|completeImg|offsetX|relativePos|afterLazyLoad|navigationText|updateItems|calculateAll|touchstart|string|responsive|updateControls|clearTransStyle|hoverStatus|jsonSuccess|moveDirection|checkPagination|endCurrent|fn|in|paginationNumbers|click|grabbing|Object|resizer|checkNavigation|dragBeforeAnimFinish|event|originalEvent|right|checkAp|remove|get|endPrev|visible|watchVisibility|Number|create|unwrap|afterInit|logIn|playDirection|max|afterAction|updateVars|afterMove|maximumPixels|apStatus|beforeUpdate|dragging|afterUpdate|pagesInArray|reload|clearEvents|removeTransition|doTranslate|show|hide|css2move|complete|span|cssText|updatePagination|gestures|disabledEvents|buildButtons|buildPagination|mousemove|touchcancel|start|disableTextSelect|min|loops|calculateWidth|pageY|appendWrapperSizes|appendItemsSizes|resize|responsiveRefreshRate|itemsScaleUp|responsiveBaseWidth|singleItem|outer|wrap|animate|srcElement|setInterval|drag|updatePosition|onVisibleItems|block|display|getNewPosition|disable|singleItemTransition|closestItem|transitionTypes|owlStatus|inArray|moveEvents|response|continue|buildControls|loading|lazyFollow|lazyPreload|lazyEffect|fade|onStartup|customEvents|wrapItems|eventTypes|naturalWidth|checkBrowser|originalClasses|outClass|inClass|originalStyles|abs|perspective|loadContent|extend|_data|round|msMaxTouchPoints|5e3|text|stopImmediatePropagation|stopPropagation|buttons|events|pop|splice|baseElWidth|minSwipe|maxSwipe|dargging|clientX|clientY|duration|destroyControls|createElement|mouseover|mouseout|numbers|which|lazyOwl|appendTo|clearTimeout|checked|shift|sort|removeAttr|match|fadeIn|400|clickable|toggleClass|wrapAll|top|prop|tagName|DIV|background|image|url|wrapperWidth|img|500|dragstart|ontouchstart|controls|out|input|relative|textarea|select|webkitAnimationEnd|oAnimationEnd|MSAnimationEnd|animationend|getJSON|returnValue|hasOwnProperty|option|onstartup|baseElement|navigator|new|prototype|destroy|removeData|reinit|addItem|after|before|removeItem|1199|979|768|479|800|1e3|carousel|jQuery|window|document'.split('|'),0,{}))

/**
 * jquery.elastislide.js v1.1.0
 * http://www.codrops.com
 *
 * Licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright 2012, Codrops
 * http://www.codrops.com
 */

;( function( $, window, undefined ) {

    'use strict';

    /*
     * debouncedresize: special jQuery event that happens once after a window resize
     *
     * latest version and complete README available on Github:
     * https://github.com/louisremi/jquery-smartresize/blob/master/jquery.debouncedresize.js
     *
     * Copyright 2011 @louis_remi
     * Licensed under the MIT license.
     */

    var autoSlide = false; //set this to enable autoslide.
    var delayTime = 3000; //ms  autoslide delay.

    var $event = $.event,
        $special,
        resizeTimeout;

    $special = $event.special.debouncedresize = {
        setup: function() {
            $( this ).on( "resize", $special.handler );
        },
        teardown: function() {
            $( this ).off( "resize", $special.handler );
        },
        handler: function( event, execAsap ) {
            // Save the context
            var context = this,
                args = arguments,
                dispatch = function() {
                    // set correct event type
                    event.type = "debouncedresize";
                    $event.dispatch.apply( context, args );
                };

            if ( resizeTimeout ) {
                clearTimeout( resizeTimeout );
            }

            execAsap ?
                dispatch() :
                resizeTimeout = setTimeout( dispatch, $special.threshold );
        },
        threshold: 150
    };

    // ======================= imagesLoaded Plugin ===============================
    // https://github.com/desandro/imagesloaded

    // $('#my-container').imagesLoaded(myFunction)
    // execute a callback when all images have loaded.
    // needed because .load() doesn't work on cached images

    // callback function gets image collection as argument
    //  this is the container

    // original: mit license. paul irish. 2010.
    // contributors: Oren Solomianik, David DeSandro, Yiannis Chatzikonstantinou

    // blank image data-uri bypasses webkit log warning (thx doug jones)
    var BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

    $.fn.imagesLoaded = function( callback ) {
        var $this = this,
            deferred = $.isFunction($.Deferred) ? $.Deferred() : 0,
            hasNotify = $.isFunction(deferred.notify),
            $images = $this.find('img').add( $this.filter('img') ),
            loaded = [],
            proper = [],
            broken = [];

        // Register deferred callbacks
        if ($.isPlainObject(callback)) {
            $.each(callback, function (key, value) {
                if (key === 'callback') {
                    callback = value;
                } else if (deferred) {
                    deferred[key](value);
                }
            });
        }

        function doneLoading() {
            var $proper = $(proper),
                $broken = $(broken);

            if ( deferred ) {
                if ( broken.length ) {
                    deferred.reject( $images, $proper, $broken );
                } else {
                    deferred.resolve( $images );
                }
            }

            if ( $.isFunction( callback ) ) {
                callback.call( $this, $images, $proper, $broken );
            }
        }

        function imgLoaded( img, isBroken ) {
            // don't proceed if BLANK image, or image is already loaded
            if ( img.src === BLANK || $.inArray( img, loaded ) !== -1 ) {
                return;
            }

            // store element in loaded images array
            loaded.push( img );

            // keep track of broken and properly loaded images
            if ( isBroken ) {
                broken.push( img );
            } else {
                proper.push( img );
            }

            // cache image and its state for future calls
            $.data( img, 'imagesLoaded', { isBroken: isBroken, src: img.src } );

            // trigger deferred progress method if present
            if ( hasNotify ) {
                deferred.notifyWith( $(img), [ isBroken, $images, $(proper), $(broken) ] );
            }

            // call doneLoading and clean listeners if all images are loaded
            if ( $images.length === loaded.length ){
                setTimeout( doneLoading );
                $images.unbind( '.imagesLoaded' );
            }
        }

        // if no images, trigger immediately
        if ( !$images.length ) {
            doneLoading();
        } else {
            $images.bind( 'load.imagesLoaded error.imagesLoaded', function( event ){
                // trigger imgLoaded
                imgLoaded( event.target, event.type === 'error' );
            }).each( function( i, el ) {
                    var src = el.src;

                    // find out if this image has been already checked for status
                    // if it was, and src has not changed, call imgLoaded on it
                    var cached = $.data( el, 'imagesLoaded' );
                    if ( cached && cached.src === src ) {
                        imgLoaded( el, cached.isBroken );
                        return;
                    }

                    // if complete is true and browser supports natural sizes, try
                    // to check for image status manually
                    if ( el.complete && el.naturalWidth !== undefined ) {
                        imgLoaded( el, el.naturalWidth === 0 || el.naturalHeight === 0 );
                        return;
                    }

                    // cached images don't fire load sometimes, so we reset src, but only when
                    // dealing with IE, or image is complete (loaded) and failed manual check
                    // webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f
                    if ( el.readyState || el.complete ) {
                        el.src = BLANK;
                        el.src = src;
                    }
                });
        }

        return deferred ? deferred.promise( $this ) : $this;
    };

    // global
    var $window = $( window ),
        Modernizr = window.Modernizr;

    $.Elastislide = function( options, element ) {

        this.$el = $( element );
        this._init( options );

    };

    $.Elastislide.defaults = {
        // orientation 'horizontal' || 'vertical'
        orientation : 'horizontal',
        // sliding speed
        speed : 500,
        // sliding easing
        easing : 'ease-in-out',
        // the minimum number of items to show.
        // when we resize the window, this will make sure minItems are always shown
        // (unless of course minItems is higher than the total number of elements)
        minItems : 3,
        // optionally specify a selector rather than using the img element to read the image sizes
        // (we only use the first matching element within our items)
        imgSizeItemSelector : 'img',
        // index of the current item (left most item of the carousel)
        start : 0,
        // click item callback
        onClick : function( el, position, evt ) { return false; },
        onReady : function() { return false; },
        onBeforeSlide : function() { return false; },
        onAfterSlide : function() { return false; }
    };

    $.Elastislide.prototype = {

        _init : function( options ) {

            // options
            this.options = $.extend( true, {}, $.Elastislide.defaults, options );

            // https://github.com/twitter/bootstrap/issues/2870
            var self = this,
                transEndEventNames = {
                    'WebkitTransition' : 'webkitTransitionEnd',
                    'MozTransition' : 'transitionend',
                    'OTransition' : 'oTransitionEnd',
                    'msTransition' : 'MSTransitionEnd',
                    'transition' : 'transitionend'
                };

            this.transEndEventName = transEndEventNames[ Modernizr.prefixed( 'transition' ) ];

            // suport for css transforms and css transitions
            this.support = Modernizr.csstransitions && Modernizr.csstransforms;

            // current item's index
            this.current = this.options.start;

            // control if it's sliding
            this.isSliding = false;

            this.$items = this.$el.children( 'li' );
            // total number of items
            this.itemsCount = this.$items.length;
            if( this.itemsCount === 0 ) {

                return false;

            }
            this._validate();
            // remove white space
            this.$items.detach();
            this.$el.empty();
            this.$el.append( this.$items );

            // main wrapper
            this.$el.wrap( '<div class="elastislide-wrapper elastislide-loading elastislide-' + this.options.orientation + '"></div>' );

            // check if we applied a transition to the <ul>
            this.hasTransition = false;

            // add transition for the <ul>
            this.hasTransitionTimeout = setTimeout( function() {

                self._addTransition();

            }, 100 );

            // preload the images

            this.$el.imagesLoaded( function() {

                self.$el.show();

                self._layout();
                self._configure();

                if( self.hasTransition ) {

                    // slide to current's position
                    self._removeTransition();
                    self._slideToItem( self.current );

                    self.$el.on( self.transEndEventName, function() {

                        self.$el.off( self.transEndEventName );
                        self._setWrapperSize();
                        // add transition for the <ul>
                        self._addTransition();
                        self._initEvents();

                    } );

                }
                else {

                    clearTimeout( self.hasTransitionTimeout );
                    self._setWrapperSize();
                    self._initEvents();
                    // slide to current's position
                    self._slideToItem( self.current );
                    setTimeout( function() { self._addTransition(); }, 25 );

                }

                self.options.onReady();

            } );

        },
        _validate : function() {


            if( this.options.minItems instanceof Function ) {

                this._minItemsFn = this.options.minItems;
                this.options.minItems = this.options.minItems( document.documentElement.clientWidth );

            }



            if( this.options.speed < 0 ) {

                this.options.speed = 500;

            }
            if( this.options.minItems < 1 || this.options.minItems > this.itemsCount ) {

                this.options.minItems = 1;

            }
            if( this.options.start < 0 || this.options.start > this.itemsCount - 1 ) {

                this.options.start = 0;

            }
            if( this.options.orientation != 'horizontal' && this.options.orientation != 'vertical' ) {

                this.options.orientation = 'horizontal';

            }

        },
        _layout : function() {

            this.$el.wrap( '<div class="elastislide-carousel"></div>' );

            this.$carousel = this.$el.parent();
            this.$wrapper = this.$carousel.parent().removeClass( 'elastislide-loading' );

            // save original image sizes
            var $img = this.$items.find( this.options.imgSizeItemSelector ).first();
            this.imgSize = { width : $img.outerWidth( true ), height : $img.outerHeight( true ) };

            this._setItemsSize();
            this.options.orientation === 'horizontal' ? this.$el.css( 'max-height', this.imgSize.height ) : this.$el.css( 'height', this.options.minItems * this.imgSize.height );

            // add the controls
            this._addControls();
            this.$carousel.append('<div class="before"></div><div class="after"></div>');

        },
        _addTransition : function() {

            if( this.support ) {

                this.$el.css( 'transition', 'all ' + this.options.speed + 'ms ' + this.options.easing );

            }
            this.hasTransition = true;

        },
        _removeTransition : function() {

            if( this.support ) {

                this.$el.css( 'transition', 'all 0s' );

            }
            this.hasTransition = false;

        },
        _addControls : function() {

            var self = this;

            // add navigation elements
            this.$navigation = $( '<div class="elastislide-nav"><span class="elastislide-nav__button elastislide-nav__prev">Previous</span><span class="elastislide-nav__button elastislide-nav__next">Next</span></div>' )
                .appendTo( this.$wrapper );


            this.$navPrev = this.$navigation.find( '.elastislide-nav__prev' ).on( 'mousedown.elastislide', function( event ) {

                self._slide( 'prev' );
                return false;

            } );

            this.$navNext = this.$navigation.find( '.elastislide-nav__next' ).on( 'mousedown.elastislide', function( event ) {

                self._slide( 'next' );
                return false;

            } );

        },
        _setItemsSize : function() {

            // width for the items (%)
            var w = this.options.orientation === 'horizontal' ? ( Math.floor( this.$carousel.width() / this.options.minItems ) * 100 ) / this.$carousel.width() : 100;

            this.$items.css( {
                'width' : w + '%',
                'max-width' : this.imgSize.width,
                'max-height' : this.imgSize.height
            } );

            if( this.options.orientation === 'vertical' ) {

                this.$wrapper.css( 'max-width', this.imgSize.width + parseInt( this.$wrapper.css( 'padding-left' ) ) + parseInt( this.$wrapper.css( 'padding-right' ) ) );

            }

        },
        _setWrapperSize : function() {

            if( this.options.orientation === 'vertical' ) {

                this.$wrapper.css( {
                    'height' : this.options.minItems * this.imgSize.height + parseInt( this.$wrapper.css( 'padding-top' ) ) + parseInt( this.$wrapper.css( 'padding-bottom' ) )
                } );

            }

        },
        _configure : function() {

            // check how many items fit in the carousel (visible area -> this.$carousel.width() )
            this.fitCount = this.options.orientation === 'horizontal' ?
                this.$carousel.width() < this.options.minItems * this.imgSize.width ? this.options.minItems : Math.floor( this.$carousel.width() / this.imgSize.width ) :
                this.$carousel.height() < this.options.minItems * this.imgSize.height ? this.options.minItems : Math.floor( this.$carousel.height() / this.imgSize.height );

        },
        _initEvents : function() {

            var self = this;
            //autoslide. To enablethis, set "var autoSlide" to "true" above.
            if( autoSlide ) {
                var translation = 0;
                // width/height of an item ( <li> )
                var itemSpace = this.options.orientation === 'horizontal' ? this.$items.outerWidth( true ) : this.$items.outerHeight( true );
                // total width/height of the <ul>
                var totalSpace = this.itemsCount * itemSpace;
                // visible width/height
                var visibleSpace = this.options.orientation === 'horizontal' ? this.$carousel.width() : this.$carousel.height();
                window.setInterval(function(){
                    //test if we should go to next slide or return to first slide
                    if(totalSpace > translation + visibleSpace)
                    {
                        self._slide('next');
                        translation += visibleSpace;
                    }
                    else
                    {
                        self._slideTo(0);
                        translation = 0;
                    }
                }, delayTime);
            }

            $window.on( 'debouncedresize.elastislide', function() {

                if( self._minItemsFn ) {
                    self.options.minItems = self._minItemsFn( document.documentElement.clientWidth );
                }


                self._setItemsSize();
                self._configure();
                self._slideToItem( self.current );

            } );

            this.$el.on( this.transEndEventName, function() {

                self._onEndTransition();

            } );

            if( this.options.orientation === 'horizontal' ) {

                this.$el.on( {
                    swipeleft : function() {

                        self._slide( 'next' );

                    },
                    swiperight : function() {

                        self._slide( 'prev' );

                    }
                } );

            }
            else {

                this.$el.on( {
                    swipeup : function() {

                        self._slide( 'next' );

                    },
                    swipedown : function() {

                        self._slide( 'prev' );

                    }
                } );

            }

            // item click event
            this.$el.on( 'click.elastislide', 'li', function( event ) {

                var $item = $( this );

                self.options.onClick( $item, $item.index(), event );

            });

        },
        _destroy : function( callback ) {

            this.$el.off( this.transEndEventName ).off( 'swipeleft swiperight swipeup swipedown .elastislide' );
            $window.off( '.elastislide' );

            this.$el.css( {
                'max-height' : 'none',
                'transition' : 'none'
            } ).unwrap( this.$carousel ).unwrap( this.$wrapper );

            this.$items.css( {
                'width' : 'auto',
                'max-width' : 'none',
                'max-height' : 'none'
            } );

            this.$navigation.remove();
            this.$wrapper.remove();

            if( callback ) {

                callback.call();

            }

        },
        _toggleControls : function( dir, display ) {
            if( display ) {
                if(dir === 'next') {
                    this.$navNext.show();
                    this.$wrapper.addClass('next');
                }
                else {
                    this.$navPrev.show();
                    this.$wrapper.addClass('prev');
                }
            }
            else {
                if(dir === 'next') {
                    this.$navNext.hide()
                    this.$wrapper.removeClass('next');
                }
                else {
                    this.$navPrev.hide();
                    this.$wrapper.removeClass('prev');
                }
            }

        },
        _slide : function( dir, tvalue ) {

            if( this.isSliding ) {

                return false;

            }

            this.options.onBeforeSlide();

            this.isSliding = true;

            var self = this,
                translation = this.translation || 0,
            // width/height of an item ( <li> )
                itemSpace = this.options.orientation === 'horizontal' ? this.$items.outerWidth( true ) : this.$items.outerHeight( true ),
            // total width/height of the <ul>
                totalSpace = this.itemsCount * itemSpace,
            // visible width/height
                visibleSpace = this.options.orientation === 'horizontal' ? this.$carousel.width() : this.$carousel.height();

            if( tvalue === undefined ) {

                var amount = this.fitCount * itemSpace;

                if( amount < 0 ) {

                    return false;

                }

                if( dir === 'next' && totalSpace - ( Math.abs( translation ) + amount ) < visibleSpace ) {

                    amount = totalSpace - ( Math.abs( translation ) + visibleSpace );

                    // show / hide navigation buttons
                    this._toggleControls( 'next', false );
                    this._toggleControls( 'prev', true );

                }
                else if( dir === 'prev' && Math.abs( translation ) - amount < 0 ) {

                    amount = Math.abs( translation );

                    // show / hide navigation buttons
                    this._toggleControls( 'next', true );
                    this._toggleControls( 'prev', false );

                }
                else {

                    // future translation value
                    var ftv = dir === 'next' ? Math.abs( translation ) + Math.abs( amount ) : Math.abs( translation ) - Math.abs( amount );

                    // show / hide navigation buttons
                    ftv > 0 ? this._toggleControls( 'prev', true ) : this._toggleControls( 'prev', false );
                    ftv < totalSpace - visibleSpace ? this._toggleControls( 'next', true ) : this._toggleControls( 'next', false );

                }

                tvalue = dir === 'next' ? translation - amount : translation + amount;

            }
            else {

                var amount = Math.abs( tvalue );

                if( Math.max( totalSpace, visibleSpace ) - amount < visibleSpace ) {

                    tvalue	= - ( Math.max( totalSpace, visibleSpace ) - visibleSpace );

                }

                // show / hide navigation buttons
                amount > 0 ? this._toggleControls( 'prev', true ) : this._toggleControls( 'prev', false );
                Math.max( totalSpace, visibleSpace ) - visibleSpace > amount ? this._toggleControls( 'next', true ) : this._toggleControls( 'next', false );

            }

            this.translation = tvalue;

            if( translation === tvalue ) {

                this._onEndTransition();
                return false;

            }

            if( this.support ) {

                if (this.options.orientation === 'horizontal') {
                    this.$el.css( '-webkit-transform', 'translateX(' + tvalue + 'px)' );
                    this.$el.css( '-o-transform', 'translateX(' + tvalue + 'px)' );
                    this.$el.css( '-ms-transform', 'translateX(' + tvalue + 'px)' );
                    this.$el.css( '-moz-transform', 'translateX(' + tvalue + 'px)' );
                    this.$el.css( 'transform', 'translateX(' + tvalue + 'px)' );
                } else {
                    this.$el.css( '-webkit-transform', 'translateY(' + tvalue + 'px)' );
                    this.$el.css( '-o-transform', 'translateY(' + tvalue + 'px)' );
                    this.$el.css( '-ms-transform', 'translateY(' + tvalue + 'px)' );
                    this.$el.css( '-moz-transform', 'translateY(' + tvalue + 'px)' );
                    this.$el.css( 'transform', 'translateY(' + tvalue + 'px)' );
                }

            }
            else {

                $.fn.applyStyle = this.hasTransition ? $.fn.animate : $.fn.css;
                var styleCSS = this.options.orientation === 'horizontal' ? { left : tvalue } : { top : tvalue };
                console.log(styleCSS)
                this.$el.stop().applyStyle( styleCSS, $.extend( true, [], { duration : this.options.speed, complete : function() {

                    self._onEndTransition();

                } } ) );

            }

            if( !this.hasTransition ) {

                this._onEndTransition();

            }

        },
        _onEndTransition : function() {

            this.isSliding = false;
            this.options.onAfterSlide();

        },
        _slideTo : function( pos ) {

            var pos = pos || this.current,
                translation = Math.abs( this.translation ) || 0,
                itemSpace = this.options.orientation === 'horizontal' ? this.$items.outerWidth( true ) : this.$items.outerHeight( true ),
                posR = translation + this.$carousel.width(),
                ftv = Math.abs( pos * itemSpace );

            if( ftv + itemSpace > posR || ftv < translation ) {

                this._slideToItem( pos );

            }

        },
        _slideToItem : function( pos ) {

            // how much to slide?
            var amount	= this.options.orientation === 'horizontal' ? pos * this.$items.outerWidth( true ) : pos * this.$items.outerHeight( true );
            this._slide( '', -amount );

        },
        // public method: adds new items to the carousel
        /*

         how to use:
         var carouselEl = $( '#carousel' ),
         carousel = carouselEl.elastislide();
         ...

         // append or prepend new items:
         carouselEl.prepend('<li><a href="#"><img src="images/large/2.jpg" alt="image02" /></a></li>');

         // call the add method:
         es.add();

         */
        add : function( callback ) {

            var self = this,
                oldcurrent = this.current,
                $currentItem = this.$items.eq( this.current );

            // adds new items to the carousel
            this.$items = this.$el.children( 'li' );
            this.itemsCount = this.$items.length;
            this.current = $currentItem.index();
            this._setItemsSize();
            this._configure();
            this._removeTransition();
            oldcurrent < this.current ? this._slideToItem( this.current ) : this._slide( 'next', this.translation );
            setTimeout( function() { self._addTransition(); }, 25 );

            if ( callback ) {

                callback.call();

            }

        },
        // public method: sets a new element as the current. slides to that position
        setCurrent : function( idx, callback ) {

            this.current = idx;

            this._slideTo();

            if ( callback ) {

                callback.call();

            }

        },
        // public method: slides to the next set of items
        next : function() {

            this._slide( 'next' );

        },
        // public method: slides to the previous set of items
        previous : function() {

            this._slide( 'prev' );

        },
        // public method: slides to the first item
        slideStart : function() {

            this._slideTo( 0 );

        },
        // public method: slides to the last item
        slideEnd : function() {

            this._slideTo( this.itemsCount - 1 );

        },
        // public method: destroys the elastislide instance
        destroy : function( callback ) {

            this._destroy( callback );

        }

    };

    var logError = function( message ) {

        if ( window.console ) {

            window.console.error( message );

        }

    };

    $.fn.elastislide = function( options ) {

        if ( typeof options === 'string' ) {

            var args = Array.prototype.slice.call( arguments, 1 );

            this.each(function() {

                var self = $.data( this, 'elastislide' );

                if ( !self ) {

                    logError( "cannot call methods on elastislide prior to initialization; " +
                        "attempted to call method '" + options + "'" );
                    return;

                }

                if ( !$.isFunction( self[options] ) || options.charAt(0) === "_" ) {

                    logError( "no such method '" + options + "' for elastislide self" );
                    return;

                }

                self[ options ].apply( self, args );

            });

        }
        else {

            this.each(function() {

                var self = $.data( this, 'elastislide' );

                if ( self ) {

                    self._init();

                }
                else {

                    self = $.data( this, 'elastislide', new $.Elastislide( options, this ) );

                }

            });

        }

        return self;

    };

} )( jQuery, window );
/*! jQuery UI - v1.10.3 - 2013-12-12
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js
* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */

(function(e,t){function i(t,i){var s,n,r,o=t.nodeName.toLowerCase();return"area"===o?(s=t.parentNode,n=s.name,t.href&&n&&"map"===s.nodeName.toLowerCase()?(r=e("img[usemap=#"+n+"]")[0],!!r&&a(r)):!1):(/input|select|textarea|button|object/.test(o)?!t.disabled:"a"===o?t.href||i:i)&&a(t)}function a(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}var s=0,n=/^ui-id-\d+$/;e.ui=e.ui||{},e.extend(e.ui,{version:"1.10.3",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({focus:function(t){return function(i,a){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),a&&a.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),scrollParent:function(){var t;return t=e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(i){if(i!==t)return this.css("zIndex",i);if(this.length)for(var a,s,n=e(this[0]);n.length&&n[0]!==document;){if(a=n.css("position"),("absolute"===a||"relative"===a||"fixed"===a)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++s)})},removeUniqueId:function(){return this.each(function(){n.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,a){return!!e.data(t,a[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var a=e.attr(t,"tabindex"),s=isNaN(a);return(s||a>=0)&&i(t,!s)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(i,a){function s(t,i,a,s){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,a&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),s&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===a?["Left","Right"]:["Top","Bottom"],r=a.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+a]=function(i){return i===t?o["inner"+a].call(this):this.each(function(){e(this).css(r,s(this,i)+"px")})},e.fn["outer"+a]=function(t,i){return"number"!=typeof t?o["outer"+a].call(this,t):this.each(function(){e(this).css(r,s(this,t,!0,i)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.support.selectstart="onselectstart"in document.createElement("div"),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,i,a){var s,n=e.ui[t].prototype;for(s in a)n.plugins[s]=n.plugins[s]||[],n.plugins[s].push([i,a[s]])},call:function(e,t,i){var a,s=e.plugins[t];if(s&&e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType)for(a=0;s.length>a;a++)e.options[s[a][0]]&&s[a][1].apply(e.element,i)}},hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var a=i&&"left"===i?"scrollLeft":"scrollTop",s=!1;return t[a]>0?!0:(t[a]=1,s=t[a]>0,t[a]=0,s)}})})(jQuery);(function(e,t){var i=0,s=Array.prototype.slice,a=e.cleanData;e.cleanData=function(t){for(var i,s=0;null!=(i=t[s]);s++)try{e(i).triggerHandler("remove")}catch(n){}a(t)},e.widget=function(i,s,a){var n,r,o,h,l={},u=i.split(".")[0];i=i.split(".")[1],n=u+"-"+i,a||(a=s,s=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[u]=e[u]||{},r=e[u][i],o=e[u][i]=function(e,i){return this._createWidget?(arguments.length&&this._createWidget(e,i),t):new o(e,i)},e.extend(o,r,{version:a.version,_proto:e.extend({},a),_childConstructors:[]}),h=new s,h.options=e.widget.extend({},h.options),e.each(a,function(i,a){return e.isFunction(a)?(l[i]=function(){var e=function(){return s.prototype[i].apply(this,arguments)},t=function(e){return s.prototype[i].apply(this,e)};return function(){var i,s=this._super,n=this._superApply;return this._super=e,this._superApply=t,i=a.apply(this,arguments),this._super=s,this._superApply=n,i}}(),t):(l[i]=a,t)}),o.prototype=e.widget.extend(h,{widgetEventPrefix:r?h.widgetEventPrefix:i},l,{constructor:o,namespace:u,widgetName:i,widgetFullName:n}),r?(e.each(r._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete r._childConstructors):s._childConstructors.push(o),e.widget.bridge(i,o)},e.widget.extend=function(i){for(var a,n,r=s.call(arguments,1),o=0,h=r.length;h>o;o++)for(a in r[o])n=r[o][a],r[o].hasOwnProperty(a)&&n!==t&&(i[a]=e.isPlainObject(n)?e.isPlainObject(i[a])?e.widget.extend({},i[a],n):e.widget.extend({},n):n);return i},e.widget.bridge=function(i,a){var n=a.prototype.widgetFullName||i;e.fn[i]=function(r){var o="string"==typeof r,h=s.call(arguments,1),l=this;return r=!o&&h.length?e.widget.extend.apply(null,[r].concat(h)):r,o?this.each(function(){var s,a=e.data(this,n);return a?e.isFunction(a[r])&&"_"!==r.charAt(0)?(s=a[r].apply(a,h),s!==a&&s!==t?(l=s&&s.jquery?l.pushStack(s.get()):s,!1):t):e.error("no such method '"+r+"' for "+i+" widget instance"):e.error("cannot call methods on "+i+" prior to initialization; "+"attempted to call method '"+r+"'")}):this.each(function(){var t=e.data(this,n);t?t.option(r||{})._init():e.data(this,n,new a(r,this))}),l}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,s){s=e(s||this.defaultElement||this)[0],this.element=e(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this.bindings=e(),this.hoverable=e(),this.focusable=e(),s!==this&&(e.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===s&&this.destroy()}}),this.document=e(s.style?s.ownerDocument:s.document||s),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(i,s){var a,n,r,o=i;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof i)if(o={},a=i.split("."),i=a.shift(),a.length){for(n=o[i]=e.widget.extend({},this.options[i]),r=0;a.length-1>r;r++)n[a[r]]=n[a[r]]||{},n=n[a[r]];if(i=a.pop(),s===t)return n[i]===t?null:n[i];n[i]=s}else{if(s===t)return this.options[i]===t?null:this.options[i];o[i]=s}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled ui-state-disabled",!!t).attr("aria-disabled",t),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_on:function(i,s,a){var n,r=this;"boolean"!=typeof i&&(a=s,s=i,i=!1),a?(s=n=e(s),this.bindings=this.bindings.add(s)):(a=s,s=this.element,n=this.widget()),e.each(a,function(a,o){function h(){return i||r.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?r[o]:o).apply(r,arguments):t}"string"!=typeof o&&(h.guid=o.guid=o.guid||h.guid||e.guid++);var l=a.match(/^(\w+)\s*(.*)$/),u=l[1]+r.eventNamespace,c=l[2];c?n.delegate(c,u,h):s.bind(u,h)})},_off:function(e,t){t=(t||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(t).undelegate(t)},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var a,n,r=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(a in n)a in i||(i[a]=n[a]);return this.element.trigger(i,s),!(e.isFunction(r)&&r.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,a,n){"string"==typeof a&&(a={effect:a});var r,o=a?a===!0||"number"==typeof a?i:a.effect||i:t;a=a||{},"number"==typeof a&&(a={duration:a}),r=!e.isEmptyObject(a),a.complete=n,a.delay&&s.delay(a.delay),r&&e.effects&&e.effects.effect[o]?s[t](a):o!==t&&s[o]?s[o](a.duration,a.easing,n):s.queue(function(i){e(this)[t](),n&&n.call(s[0]),i()})}})})(jQuery);(function(e){var t=!1;e(document).mouseup(function(){t=!1}),e.widget("ui.mouse",{version:"1.10.3",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):undefined}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(i){if(!t){this._mouseStarted&&this._mouseUp(i),this._mouseDownEvent=i;var s=this,a=1===i.which,n="string"==typeof this.options.cancel&&i.target.nodeName?e(i.target).closest(this.options.cancel).length:!1;return a&&!n&&this._mouseCapture(i)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){s.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(i)&&this._mouseDelayMet(i)&&(this._mouseStarted=this._mouseStart(i)!==!1,!this._mouseStarted)?(i.preventDefault(),!0):(!0===e.data(i.target,this.widgetName+".preventClickEvent")&&e.removeData(i.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return s._mouseMove(e)},this._mouseUpDelegate=function(e){return s._mouseUp(e)},e(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),i.preventDefault(),t=!0,!0)):!0}},_mouseMove:function(t){return e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button?this._mouseUp(t):this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}})})(jQuery);(function(e){e.widget("ui.draggable",e.ui.mouse,{version:"1.10.3",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"!==this.options.helper||/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._mouseInit()},_destroy:function(){this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._mouseDestroy()},_mouseCapture:function(t){var i=this.options;return this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(e(i.iframeFix===!0?"iframe":i.iframeFix).each(function(){e("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(e(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offsetParent=this.helper.offsetParent(),this.offsetParentCssPosition=this.offsetParent.css("position"),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},this.offset.scroll=!1,e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_mouseDrag:function(t,i){if("fixed"===this.offsetParentCssPosition&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),!i){var a=this._uiHash();if(this._trigger("drag",t,a)===!1)return this._mouseUp({}),!1;this.position=a.position}return this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,a=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(a=e.ui.ddmanager.drop(this,t)),this.dropped&&(a=this.dropped,this.dropped=!1),"original"!==this.options.helper||e.contains(this.element[0].ownerDocument,this.element[0])?("invalid"===this.options.revert&&!a||"valid"===this.options.revert&&a||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,a)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1):!1},_mouseUp:function(t){return e("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_createHelper:function(t){var i=this.options,a=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return a.parents("body").length||a.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),a[0]===this.element[0]||/(fixed|absolute)/.test(a.css("position"))||a.css("position","absolute"),a},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===document.body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.element.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,a,s=this.options;return s.containment?"window"===s.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],undefined):"document"===s.containment?(this.containment=[0,0,e(document).width()-this.helperProportions.width-this.margins.left,(e(document).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],undefined):s.containment.constructor===Array?(this.containment=s.containment,undefined):("parent"===s.containment&&(s.containment=this.helper[0].parentNode),i=e(s.containment),a=i[0],a&&(t="hidden"!==i.css("overflow"),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(a.scrollWidth,a.offsetWidth):a.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(a.scrollHeight,a.offsetHeight):a.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=i),undefined):(this.containment=null,undefined)},_convertPositionTo:function(t,i){i||(i=this.position);var a="absolute"===t?1:-1,s="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent;return this.offset.scroll||(this.offset.scroll={top:s.scrollTop(),left:s.scrollLeft()}),{top:i.top+this.offset.relative.top*a+this.offset.parent.top*a-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():this.offset.scroll.top)*a,left:i.left+this.offset.relative.left*a+this.offset.parent.left*a-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():this.offset.scroll.left)*a}},_generatePosition:function(t){var i,a,s,n,r=this.options,o="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,l=t.pageX,h=t.pageY;return this.offset.scroll||(this.offset.scroll={top:o.scrollTop(),left:o.scrollLeft()}),this.originalPosition&&(this.containment&&(this.relative_container?(a=this.relative_container.offset(),i=[this.containment[0]+a.left,this.containment[1]+a.top,this.containment[2]+a.left,this.containment[3]+a.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(l=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(h=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(l=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(h=i[3]+this.offset.click.top)),r.grid&&(s=r.grid[1]?this.originalPageY+Math.round((h-this.originalPageY)/r.grid[1])*r.grid[1]:this.originalPageY,h=i?s-this.offset.click.top>=i[1]||s-this.offset.click.top>i[3]?s:s-this.offset.click.top>=i[1]?s-r.grid[1]:s+r.grid[1]:s,n=r.grid[0]?this.originalPageX+Math.round((l-this.originalPageX)/r.grid[0])*r.grid[0]:this.originalPageX,l=i?n-this.offset.click.left>=i[0]||n-this.offset.click.left>i[2]?n:n-this.offset.click.left>=i[0]?n-r.grid[0]:n+r.grid[0]:n)),{top:h-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():this.offset.scroll.top),left:l-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():this.offset.scroll.left)}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1},_trigger:function(t,i,a){return a=a||this._uiHash(),e.ui.plugin.call(this,t,[i,a]),"drag"===t&&(this.positionAbs=this._convertPositionTo("absolute")),e.Widget.prototype._trigger.call(this,t,i,a)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i){var a=e(this).data("ui-draggable"),s=a.options,n=e.extend({},i,{item:a.element});a.sortables=[],e(s.connectToSortable).each(function(){var i=e.data(this,"ui-sortable");i&&!i.options.disabled&&(a.sortables.push({instance:i,shouldRevert:i.options.revert}),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i){var a=e(this).data("ui-draggable"),s=e.extend({},i,{item:a.element});e.each(a.sortables,function(){this.instance.isOver?(this.instance.isOver=0,a.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=this.shouldRevert),this.instance._mouseStop(t),this.instance.options.helper=this.instance.options._helper,"original"===a.options.helper&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",t,s))})},drag:function(t,i){var a=e(this).data("ui-draggable"),s=this;e.each(a.sortables,function(){var n=!1,r=this;this.instance.positionAbs=a.positionAbs,this.instance.helperProportions=a.helperProportions,this.instance.offset.click=a.offset.click,this.instance._intersectsWith(this.instance.containerCache)&&(n=!0,e.each(a.sortables,function(){return this.instance.positionAbs=a.positionAbs,this.instance.helperProportions=a.helperProportions,this.instance.offset.click=a.offset.click,this!==r&&this.instance._intersectsWith(this.instance.containerCache)&&e.contains(r.instance.element[0],this.instance.element[0])&&(n=!1),n})),n?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=e(s).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return i.helper[0]},t.target=this.instance.currentItem[0],this.instance._mouseCapture(t,!0),this.instance._mouseStart(t,!0,!0),this.instance.offset.click.top=a.offset.click.top,this.instance.offset.click.left=a.offset.click.left,this.instance.offset.parent.left-=a.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=a.offset.parent.top-this.instance.offset.parent.top,a._trigger("toSortable",t),a.dropped=this.instance.element,a.currentItem=a.element,this.instance.fromOutside=a),this.instance.currentItem&&this.instance._mouseDrag(t)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",t,this.instance._uiHash(this.instance)),this.instance._mouseStop(t,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),a._trigger("fromSortable",t),a.dropped=!1)})}}),e.ui.plugin.add("draggable","cursor",{start:function(){var t=e("body"),i=e(this).data("ui-draggable").options;t.css("cursor")&&(i._cursor=t.css("cursor")),t.css("cursor",i.cursor)},stop:function(){var t=e(this).data("ui-draggable").options;t._cursor&&e("body").css("cursor",t._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i){var a=e(i.helper),s=e(this).data("ui-draggable").options;a.css("opacity")&&(s._opacity=a.css("opacity")),a.css("opacity",s.opacity)},stop:function(t,i){var a=e(this).data("ui-draggable").options;a._opacity&&e(i.helper).css("opacity",a._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(){var t=e(this).data("ui-draggable");t.scrollParent[0]!==document&&"HTML"!==t.scrollParent[0].tagName&&(t.overflowOffset=t.scrollParent.offset())},drag:function(t){var i=e(this).data("ui-draggable"),a=i.options,s=!1;i.scrollParent[0]!==document&&"HTML"!==i.scrollParent[0].tagName?(a.axis&&"x"===a.axis||(i.overflowOffset.top+i.scrollParent[0].offsetHeight-t.pageY<a.scrollSensitivity?i.scrollParent[0].scrollTop=s=i.scrollParent[0].scrollTop+a.scrollSpeed:t.pageY-i.overflowOffset.top<a.scrollSensitivity&&(i.scrollParent[0].scrollTop=s=i.scrollParent[0].scrollTop-a.scrollSpeed)),a.axis&&"y"===a.axis||(i.overflowOffset.left+i.scrollParent[0].offsetWidth-t.pageX<a.scrollSensitivity?i.scrollParent[0].scrollLeft=s=i.scrollParent[0].scrollLeft+a.scrollSpeed:t.pageX-i.overflowOffset.left<a.scrollSensitivity&&(i.scrollParent[0].scrollLeft=s=i.scrollParent[0].scrollLeft-a.scrollSpeed))):(a.axis&&"x"===a.axis||(t.pageY-e(document).scrollTop()<a.scrollSensitivity?s=e(document).scrollTop(e(document).scrollTop()-a.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<a.scrollSensitivity&&(s=e(document).scrollTop(e(document).scrollTop()+a.scrollSpeed))),a.axis&&"y"===a.axis||(t.pageX-e(document).scrollLeft()<a.scrollSensitivity?s=e(document).scrollLeft(e(document).scrollLeft()-a.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<a.scrollSensitivity&&(s=e(document).scrollLeft(e(document).scrollLeft()+a.scrollSpeed)))),s!==!1&&e.ui.ddmanager&&!a.dropBehaviour&&e.ui.ddmanager.prepareOffsets(i,t)}}),e.ui.plugin.add("draggable","snap",{start:function(){var t=e(this).data("ui-draggable"),i=t.options;t.snapElements=[],e(i.snap.constructor!==String?i.snap.items||":data(ui-draggable)":i.snap).each(function(){var i=e(this),a=i.offset();this!==t.element[0]&&t.snapElements.push({item:this,width:i.outerWidth(),height:i.outerHeight(),top:a.top,left:a.left})})},drag:function(t,i){var a,s,n,r,o,l,h,u,d,c,p=e(this).data("ui-draggable"),f=p.options,m=f.snapTolerance,g=i.offset.left,v=g+p.helperProportions.width,y=i.offset.top,b=y+p.helperProportions.height;for(d=p.snapElements.length-1;d>=0;d--)o=p.snapElements[d].left,l=o+p.snapElements[d].width,h=p.snapElements[d].top,u=h+p.snapElements[d].height,o-m>v||g>l+m||h-m>b||y>u+m||!e.contains(p.snapElements[d].item.ownerDocument,p.snapElements[d].item)?(p.snapElements[d].snapping&&p.options.snap.release&&p.options.snap.release.call(p.element,t,e.extend(p._uiHash(),{snapItem:p.snapElements[d].item})),p.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(a=m>=Math.abs(h-b),s=m>=Math.abs(u-y),n=m>=Math.abs(o-v),r=m>=Math.abs(l-g),a&&(i.position.top=p._convertPositionTo("relative",{top:h-p.helperProportions.height,left:0}).top-p.margins.top),s&&(i.position.top=p._convertPositionTo("relative",{top:u,left:0}).top-p.margins.top),n&&(i.position.left=p._convertPositionTo("relative",{top:0,left:o-p.helperProportions.width}).left-p.margins.left),r&&(i.position.left=p._convertPositionTo("relative",{top:0,left:l}).left-p.margins.left)),c=a||s||n||r,"outer"!==f.snapMode&&(a=m>=Math.abs(h-y),s=m>=Math.abs(u-b),n=m>=Math.abs(o-g),r=m>=Math.abs(l-v),a&&(i.position.top=p._convertPositionTo("relative",{top:h,left:0}).top-p.margins.top),s&&(i.position.top=p._convertPositionTo("relative",{top:u-p.helperProportions.height,left:0}).top-p.margins.top),n&&(i.position.left=p._convertPositionTo("relative",{top:0,left:o}).left-p.margins.left),r&&(i.position.left=p._convertPositionTo("relative",{top:0,left:l-p.helperProportions.width}).left-p.margins.left)),!p.snapElements[d].snapping&&(a||s||n||r||c)&&p.options.snap.snap&&p.options.snap.snap.call(p.element,t,e.extend(p._uiHash(),{snapItem:p.snapElements[d].item})),p.snapElements[d].snapping=a||s||n||r||c)}}),e.ui.plugin.add("draggable","stack",{start:function(){var t,i=this.data("ui-draggable").options,a=e.makeArray(e(i.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});a.length&&(t=parseInt(e(a[0]).css("zIndex"),10)||0,e(a).each(function(i){e(this).css("zIndex",t+i)}),this.css("zIndex",t+a.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i){var a=e(i.helper),s=e(this).data("ui-draggable").options;a.css("zIndex")&&(s._zIndex=a.css("zIndex")),a.css("zIndex",s.zIndex)},stop:function(t,i){var a=e(this).data("ui-draggable").options;a._zIndex&&e(i.helper).css("zIndex",a._zIndex)}})})(jQuery);
/*
 * jQuery UI Touch Punch 0.2.2
 *
 * Copyright 2011, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
(function(b){b.support.touch="ontouchend" in document;if(!b.support.touch){return;}var c=b.ui.mouse.prototype,e=c._mouseInit,a;function d(g,h){if(g.originalEvent.touches.length>1){return;}g.preventDefault();var i=g.originalEvent.changedTouches[0],f=document.createEvent("MouseEvents");f.initMouseEvent(h,true,true,window,1,i.screenX,i.screenY,i.clientX,i.clientY,false,false,false,false,0,null);g.target.dispatchEvent(f);}c._touchStart=function(g){var f=this;if(a||!f._mouseCapture(g.originalEvent.changedTouches[0])){return;}a=true;f._touchMoved=false;d(g,"mouseover");d(g,"mousemove");d(g,"mousedown");};c._touchMove=function(f){if(!a){return;}this._touchMoved=true;d(f,"mousemove");};c._touchEnd=function(f){if(!a){return;}d(f,"mouseup");d(f,"mouseout");if(!this._touchMoved){d(f,"click");}a=false;};c._mouseInit=function(){var f=this;f.element.bind("touchstart",b.proxy(f,"_touchStart")).bind("touchmove",b.proxy(f,"_touchMove")).bind("touchend",b.proxy(f,"_touchEnd"));e.call(f);};})(jQuery);
/*! Magnific Popup - v0.9.9 - 2013-12-04
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2013 Dmitry Semenov; */
;(function($) {

/*>>core*/
/**
 * 
 * Magnific Popup Core JS file
 * 
 */


/**
 * Private static constants
 */
var CLOSE_EVENT = 'Close',
	BEFORE_CLOSE_EVENT = 'BeforeClose',
	AFTER_CLOSE_EVENT = 'AfterClose',
	BEFORE_APPEND_EVENT = 'BeforeAppend',
	MARKUP_PARSE_EVENT = 'MarkupParse',
	OPEN_EVENT = 'Open',
	CHANGE_EVENT = 'Change',
	NS = 'mfp',
	EVENT_NS = '.' + NS,
	READY_CLASS = 'mfp-ready',
	REMOVING_CLASS = 'mfp-removing',
	PREVENT_CLOSE_CLASS = 'mfp-prevent-close';


/**
 * Private vars 
 */
var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
	MagnificPopup = function(){},
	_isJQ = !!(window.jQuery),
	_prevStatus,
	_window = $(window),
	_body,
	_document,
	_prevContentType,
	_wrapClasses,
	_currPopupType;


/**
 * Private functions
 */
var _mfpOn = function(name, f) {
		mfp.ev.on(NS + name + EVENT_NS, f);
	},
	_getEl = function(className, appendTo, html, raw) {
		var el = document.createElement('div');
		el.className = 'mfp-'+className;
		if(html) {
			el.innerHTML = html;
		}
		if(!raw) {
			el = $(el);
			if(appendTo) {
				el.appendTo(appendTo);
			}
		} else if(appendTo) {
			appendTo.appendChild(el);
		}
		return el;
	},
	_mfpTrigger = function(e, data) {
		mfp.ev.triggerHandler(NS + e, data);

		if(mfp.st.callbacks) {
			// converts "mfpEventName" to "eventName" callback and triggers it if it's present
			e = e.charAt(0).toLowerCase() + e.slice(1);
			if(mfp.st.callbacks[e]) {
				mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
			}
		}
	},
	_getCloseBtn = function(type) {
		if(type !== _currPopupType || !mfp.currTemplate.closeBtn) {
			mfp.currTemplate.closeBtn = $( mfp.st.closeMarkup.replace('%title%', mfp.st.tClose ) );
			_currPopupType = type;
		}
		return mfp.currTemplate.closeBtn;
	},
	// Initialize Magnific Popup only when called at least once
	_checkInstance = function() {
		if(!$.magnificPopup.instance) {
			mfp = new MagnificPopup();
			mfp.init();
			$.magnificPopup.instance = mfp;
		}
	},
	// CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
	supportsTransitions = function() {
		var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
			v = ['ms','O','Moz','Webkit']; // 'v' for vendor

		if( s['transition'] !== undefined ) {
			return true; 
		}
			
		while( v.length ) {
			if( v.pop() + 'Transition' in s ) {
				return true;
			}
		}
				
		return false;
	};



/**
 * Public functions
 */
MagnificPopup.prototype = {

	constructor: MagnificPopup,

	/**
	 * Initializes Magnific Popup plugin. 
	 * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
	 */
	init: function() {
		var appVersion = navigator.appVersion;
		mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1; 
		mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1;
		mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
		mfp.isAndroid = (/android/gi).test(appVersion);
		mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
		mfp.supportsTransition = supportsTransitions();

		// We disable fixed positioned lightbox on devices that don't handle it nicely.
		// If you know a better way of detecting this - let me know.
		mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent) );
		_document = $(document);

		mfp.popupsCache = {};
	},

	/**
	 * Opens popup
	 * @param  data [description]
	 */
	open: function(data) {

		if(!_body) {
			_body = $(document.body);
		}

		var i;

		if(data.isObj === false) { 
			// convert jQuery collection to array to avoid conflicts later
			mfp.items = data.items.toArray();

			mfp.index = 0;
			var items = data.items,
				item;
			for(i = 0; i < items.length; i++) {
				item = items[i];
				if(item.parsed) {
					item = item.el[0];
				}
				if(item === data.el[0]) {
					mfp.index = i;
					break;
				}
			}
		} else {
			mfp.items = $.isArray(data.items) ? data.items : [data.items];
			mfp.index = data.index || 0;
		}

		// if popup is already opened - we just update the content
		if(mfp.isOpen) {
			mfp.updateItemHTML();
			return;
		}
		
		mfp.types = []; 
		_wrapClasses = '';
		if(data.mainEl && data.mainEl.length) {
			mfp.ev = data.mainEl.eq(0);
		} else {
			mfp.ev = _document;
		}

		if(data.key) {
			if(!mfp.popupsCache[data.key]) {
				mfp.popupsCache[data.key] = {};
			}
			mfp.currTemplate = mfp.popupsCache[data.key];
		} else {
			mfp.currTemplate = {};
		}



		mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data ); 
		mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;

		if(mfp.st.modal) {
			mfp.st.closeOnContentClick = false;
			mfp.st.closeOnBgClick = false;
			mfp.st.showCloseBtn = false;
			mfp.st.enableEscapeKey = false;
		}
		

		// Building markup
		// main containers are created only once
		if(!mfp.bgOverlay) {

			// Dark overlay
			mfp.bgOverlay = _getEl('bg').on('click'+EVENT_NS, function() {
				mfp.close();
			});

			mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click'+EVENT_NS, function(e) {
				if(mfp._checkIfClose(e.target)) {
					mfp.close();
				}
			});

			mfp.container = _getEl('container', mfp.wrap);
		}

		mfp.contentContainer = _getEl('content');
		if(mfp.st.preloader) {
			mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
		}


		// Initializing modules
		var modules = $.magnificPopup.modules;
		for(i = 0; i < modules.length; i++) {
			var n = modules[i];
			n = n.charAt(0).toUpperCase() + n.slice(1);
			mfp['init'+n].call(mfp);
		}
		_mfpTrigger('BeforeOpen');


		if(mfp.st.showCloseBtn) {
			// Close button
			if(!mfp.st.closeBtnInside) {
				mfp.wrap.append( _getCloseBtn() );
			} else {
				_mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
					values.close_replaceWith = _getCloseBtn(item.type);
				});
				_wrapClasses += ' mfp-close-btn-in';
			}
		}

		if(mfp.st.alignTop) {
			_wrapClasses += ' mfp-align-top';
		}

	

		if(mfp.fixedContentPos) {
			mfp.wrap.css({
				overflow: mfp.st.overflowY,
				overflowX: 'hidden',
				overflowY: mfp.st.overflowY
			});
		} else {
			mfp.wrap.css({ 
				top: _window.scrollTop(),
				position: 'absolute'
			});
		}
		if( mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos) ) {
			mfp.bgOverlay.css({
				height: _document.height(),
				position: 'absolute'
			});
		}

		

		if(mfp.st.enableEscapeKey) {
			// Close on ESC key
			_document.on('keyup' + EVENT_NS, function(e) {
				if(e.keyCode === 27) {
					mfp.close();
				}
			});
		}

		_window.on('resize' + EVENT_NS, function() {
			mfp.updateSize();
		});


		if(!mfp.st.closeOnContentClick) {
			_wrapClasses += ' mfp-auto-cursor';
		}
		
		if(_wrapClasses)
			mfp.wrap.addClass(_wrapClasses);


		// this triggers recalculation of layout, so we get it once to not to trigger twice
		var windowHeight = mfp.wH = _window.height();

		
		var windowStyles = {};

		if( mfp.fixedContentPos ) {
            if(mfp._hasScrollBar(windowHeight)){
                var s = mfp._getScrollbarSize();
                if(s) {
                    windowStyles.marginRight = s;
                }
            }
        }

		if(mfp.fixedContentPos) {
			if(!mfp.isIE7) {
				windowStyles.overflow = 'hidden';
			} else {
				// ie7 double-scroll bug
				$('body, html').css('overflow', 'hidden');
			}
		}

		
		
		var classesToadd = mfp.st.mainClass;
		if(mfp.isIE7) {
			classesToadd += ' mfp-ie7';
		}
		if(classesToadd) {
			mfp._addClassToMFP( classesToadd );
		}

		// add content
		mfp.updateItemHTML();

		_mfpTrigger('BuildControls');

		// remove scrollbar, add margin e.t.c
		$('html').css(windowStyles);
		
		// add everything to DOM
		mfp.bgOverlay.add(mfp.wrap).prependTo( mfp.st.prependTo || _body );

		// Save last focused element
		mfp._lastFocusedEl = document.activeElement;
		
		// Wait for next cycle to allow CSS transition
		setTimeout(function() {
			
			if(mfp.content) {
				mfp._addClassToMFP(READY_CLASS);
				mfp._setFocus();
			} else {
				// if content is not defined (not loaded e.t.c) we add class only for BG
				mfp.bgOverlay.addClass(READY_CLASS);
			}
			
			// Trap the focus in popup
			_document.on('focusin' + EVENT_NS, mfp._onFocusIn);

		}, 16);

		mfp.isOpen = true;
		mfp.updateSize(windowHeight);
		_mfpTrigger(OPEN_EVENT);

		return data;
	},

	/**
	 * Closes the popup
	 */
	close: function() {
		if(!mfp.isOpen) return;
		_mfpTrigger(BEFORE_CLOSE_EVENT);

		mfp.isOpen = false;
		// for CSS3 animation
		if(mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition )  {
			mfp._addClassToMFP(REMOVING_CLASS);
			setTimeout(function() {
				mfp._close();
			}, mfp.st.removalDelay);
		} else {
			mfp._close();
		}
	},

	/**
	 * Helper for close() function
	 */
	_close: function() {
		_mfpTrigger(CLOSE_EVENT);

		var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';

		mfp.bgOverlay.detach();
		mfp.wrap.detach();
		mfp.container.empty();

		if(mfp.st.mainClass) {
			classesToRemove += mfp.st.mainClass + ' ';
		}

		mfp._removeClassFromMFP(classesToRemove);

		if(mfp.fixedContentPos) {
			var windowStyles = {marginRight: ''};
			if(mfp.isIE7) {
				$('body, html').css('overflow', '');
			} else {
				windowStyles.overflow = '';
			}
			$('html').css(windowStyles);
		}
		
		_document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
		mfp.ev.off(EVENT_NS);

		// clean up DOM elements that aren't removed
		mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
		mfp.bgOverlay.attr('class', 'mfp-bg');
		mfp.container.attr('class', 'mfp-container');

		// remove close button from target element
		if(mfp.st.showCloseBtn &&
		(!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
			if(mfp.currTemplate.closeBtn)
				mfp.currTemplate.closeBtn.detach();
		}


		if(mfp._lastFocusedEl) {
			$(mfp._lastFocusedEl).focus(); // put tab focus back
		}
		mfp.currItem = null;	
		mfp.content = null;
		mfp.currTemplate = null;
		mfp.prevHeight = 0;

		_mfpTrigger(AFTER_CLOSE_EVENT);
	},
	
	updateSize: function(winHeight) {

		if(mfp.isIOS) {
			// fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
			var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
			var height = window.innerHeight * zoomLevel;
			mfp.wrap.css('height', height);
			mfp.wH = height;
		} else {
			mfp.wH = winHeight || _window.height();
		}
		// Fixes #84: popup incorrectly positioned with position:relative on body
		if(!mfp.fixedContentPos) {
			mfp.wrap.css('height', mfp.wH);
		}

		_mfpTrigger('Resize');

	},

	/**
	 * Set content of popup based on current index
	 */
	updateItemHTML: function() {
		var item = mfp.items[mfp.index];

		// Detach and perform modifications
		mfp.contentContainer.detach();

		if(mfp.content)
			mfp.content.detach();

		if(!item.parsed) {
			item = mfp.parseEl( mfp.index );
		}

		var type = item.type;	

		_mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
		// BeforeChange event works like so:
		// _mfpOn('BeforeChange', function(e, prevType, newType) { });
		
		mfp.currItem = item;

		

		

		if(!mfp.currTemplate[type]) {
			var markup = mfp.st[type] ? mfp.st[type].markup : false;

			// allows to modify markup
			_mfpTrigger('FirstMarkupParse', markup);

			if(markup) {
				mfp.currTemplate[type] = $(markup);
			} else {
				// if there is no markup found we just define that template is parsed
				mfp.currTemplate[type] = true;
			}
		}

		if(_prevContentType && _prevContentType !== item.type) {
			mfp.container.removeClass('mfp-'+_prevContentType+'-holder');
		}
		
		var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
		mfp.appendContent(newContent, type);

		item.preloaded = true;

		_mfpTrigger(CHANGE_EVENT, item);
		_prevContentType = item.type;
		
		// Append container back after its content changed
		mfp.container.prepend(mfp.contentContainer);

		_mfpTrigger('AfterChange');
	},


	/**
	 * Set HTML content of popup
	 */
	appendContent: function(newContent, type) {
		mfp.content = newContent;
		
		if(newContent) {
			if(mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
				mfp.currTemplate[type] === true) {
				// if there is no markup, we just append close button element inside
				if(!mfp.content.find('.mfp-close').length) {
					mfp.content.append(_getCloseBtn());
				}
			} else {
				mfp.content = newContent;
			}
		} else {
			mfp.content = '';
		}

		_mfpTrigger(BEFORE_APPEND_EVENT);
		mfp.container.addClass('mfp-'+type+'-holder');

		mfp.contentContainer.append(mfp.content);
	},



	
	/**
	 * Creates Magnific Popup data object based on given data
	 * @param  {int} index Index of item to parse
	 */
	parseEl: function(index) {
		var item = mfp.items[index],
			type = item.type;

		if(item.tagName) {
			item = { el: $(item) };
		} else {
			item = { data: item, src: item.src };
		}

		if(item.el) {
			var types = mfp.types;

			// check for 'mfp-TYPE' class
			for(var i = 0; i < types.length; i++) {
				if( item.el.hasClass('mfp-'+types[i]) ) {
					type = types[i];
					break;
				}
			}

			item.src = item.el.attr('data-mfp-src');
			if(!item.src) {
				item.src = item.el.attr('href');
			}
		}

		item.type = type || mfp.st.type || 'inline';
		item.index = index;
		item.parsed = true;
		mfp.items[index] = item;
		_mfpTrigger('ElementParse', item);

		return mfp.items[index];
	},


	/**
	 * Initializes single popup or a group of popups
	 */
	addGroup: function(el, options) {
		var eHandler = function(e) {
			e.mfpEl = this;
			mfp._openClick(e, el, options);
		};

		if(!options) {
			options = {};
		} 

		var eName = 'click.magnificPopup';
		options.mainEl = el;
		
		if(options.items) {
			options.isObj = true;
			el.off(eName).on(eName, eHandler);
		} else {
			options.isObj = false;
			if(options.delegate) {
				el.off(eName).on(eName, options.delegate , eHandler);
			} else {
				options.items = el;
				el.off(eName).on(eName, eHandler);
			}
		}
	},
	_openClick: function(e, el, options) {
		var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


		if(!midClick && ( e.which === 2 || e.ctrlKey || e.metaKey ) ) {
			return;
		}

		var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

		if(disableOn) {
			if($.isFunction(disableOn)) {
				if( !disableOn.call(mfp) ) {
					return true;
				}
			} else { // else it's number
				if( _window.width() < disableOn ) {
					return true;
				}
			}
		}
		
		if(e.type) {
			e.preventDefault();

			// This will prevent popup from closing if element is inside and popup is already opened
			if(mfp.isOpen) {
				e.stopPropagation();
			}
		}
			

		options.el = $(e.mfpEl);
		if(options.delegate) {
			options.items = el.find(options.delegate);
		}
		mfp.open(options);
	},


	/**
	 * Updates text on preloader
	 */
	updateStatus: function(status, text) {

		if(mfp.preloader) {
			if(_prevStatus !== status) {
				mfp.container.removeClass('mfp-s-'+_prevStatus);
			}

			if(!text && status === 'loading') {
				text = mfp.st.tLoading;
			}

			var data = {
				status: status,
				text: text
			};
			// allows to modify status
			_mfpTrigger('UpdateStatus', data);

			status = data.status;
			text = data.text;

			mfp.preloader.html(text);

			mfp.preloader.find('a').on('click', function(e) {
				e.stopImmediatePropagation();
			});

			mfp.container.addClass('mfp-s-'+status);
			_prevStatus = status;
		}
	},


	/*
		"Private" helpers that aren't private at all
	 */
	// Check to close popup or not
	// "target" is an element that was clicked
	_checkIfClose: function(target) {

		if($(target).hasClass(PREVENT_CLOSE_CLASS)) {
			return;
		}

		var closeOnContent = mfp.st.closeOnContentClick;
		var closeOnBg = mfp.st.closeOnBgClick;

		if(closeOnContent && closeOnBg) {
			return true;
		} else {

			// We close the popup if click is on close button or on preloader. Or if there is no content.
			if(!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0]) ) {
				return true;
			}

			// if click is outside the content
			if(  (target !== mfp.content[0] && !$.contains(mfp.content[0], target))  ) {
				if(closeOnBg) {
					// last check, if the clicked element is in DOM, (in case it's removed onclick)
					if( $.contains(document, target) ) {
						return true;
					}
				}
			} else if(closeOnContent) {
				return true;
			}

		}
		return false;
	},
	_addClassToMFP: function(cName) {
		mfp.bgOverlay.addClass(cName);
		mfp.wrap.addClass(cName);
	},
	_removeClassFromMFP: function(cName) {
		this.bgOverlay.removeClass(cName);
		mfp.wrap.removeClass(cName);
	},
	_hasScrollBar: function(winHeight) {
		return (  (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()) );
	},
	_setFocus: function() {
		(mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
	},
	_onFocusIn: function(e) {
		if( e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target) ) {
			mfp._setFocus();
			return false;
		}
	},
	_parseMarkup: function(template, values, item) {
		var arr;
		if(item.data) {
			values = $.extend(item.data, values);
		}
		_mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item] );

		$.each(values, function(key, value) {
			if(value === undefined || value === false) {
				return true;
			}
			arr = key.split('_');
			if(arr.length > 1) {
				var el = template.find(EVENT_NS + '-'+arr[0]);

				if(el.length > 0) {
					var attr = arr[1];
					if(attr === 'replaceWith') {
						if(el[0] !== value[0]) {
							el.replaceWith(value);
						}
					} else if(attr === 'img') {
						if(el.is('img')) {
							el.attr('src', value);
						} else {
							el.replaceWith( '<img src="'+value+'" class="' + el.attr('class') + '" />' );
						}
					} else {
						el.attr(arr[1], value);
					}
				}

			} else {
				template.find(EVENT_NS + '-'+key).html(value);
			}
		});
	},

	_getScrollbarSize: function() {
		// thx David
		if(mfp.scrollbarSize === undefined) {
			var scrollDiv = document.createElement("div");
			scrollDiv.id = "mfp-sbm";
			scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
			document.body.appendChild(scrollDiv);
			mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
			document.body.removeChild(scrollDiv);
		}
		return mfp.scrollbarSize;
	}

}; /* MagnificPopup core prototype end */




/**
 * Public static functions
 */
$.magnificPopup = {
	instance: null,
	proto: MagnificPopup.prototype,
	modules: [],

	open: function(options, index) {
		_checkInstance();	

		if(!options) {
			options = {};
		} else {
			options = $.extend(true, {}, options);
		}
			

		options.isObj = true;
		options.index = index || 0;
		return this.instance.open(options);
	},

	close: function() {
		return $.magnificPopup.instance && $.magnificPopup.instance.close();
	},

	registerModule: function(name, module) {
		if(module.options) {
			$.magnificPopup.defaults[name] = module.options;
		}
		$.extend(this.proto, module.proto);			
		this.modules.push(name);
	},

	defaults: {   

		// Info about options is in docs:
		// http://dimsemenov.com/plugins/magnific-popup/documentation.html#options
		
		disableOn: 0,	

		key: null,

		midClick: false,

		mainClass: '',

		preloader: true,

		focus: '', // CSS selector of input to focus after popup is opened
		
		closeOnContentClick: false,

		closeOnBgClick: true,

		closeBtnInside: true, 

		showCloseBtn: true,

		enableEscapeKey: true,

		modal: false,

		alignTop: false,
	
		removalDelay: 0,

		prependTo: null,
		
		fixedContentPos: 'auto', 
	
		fixedBgPos: 'auto',

		overflowY: 'auto',

		closeMarkup: '<button title="%title%" type="button" class="mfp-close">&times;</button>',

		tClose: 'Close (Esc)',

		tLoading: 'Loading...'

	}
};



$.fn.magnificPopup = function(options) {
	_checkInstance();

	var jqEl = $(this);

	// We call some API method of first param is a string
	if (typeof options === "string" ) {

		if(options === 'open') {
			var items,
				itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
				index = parseInt(arguments[1], 10) || 0;

			if(itemOpts.items) {
				items = itemOpts.items[index];
			} else {
				items = jqEl;
				if(itemOpts.delegate) {
					items = items.find(itemOpts.delegate);
				}
				items = items.eq( index );
			}
			mfp._openClick({mfpEl:items}, jqEl, itemOpts);
		} else {
			if(mfp.isOpen)
				mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
		}

	} else {
		// clone options obj
		options = $.extend(true, {}, options);
		
		/*
		 * As Zepto doesn't support .data() method for objects 
		 * and it works only in normal browsers
		 * we assign "options" object directly to the DOM element. FTW!
		 */
		if(_isJQ) {
			jqEl.data('magnificPopup', options);
		} else {
			jqEl[0].magnificPopup = options;
		}

		mfp.addGroup(jqEl, options);

	}
	return jqEl;
};


//Quick benchmark
/*
var start = performance.now(),
	i,
	rounds = 1000;

for(i = 0; i < rounds; i++) {

}
console.log('Test #1:', performance.now() - start);

start = performance.now();
for(i = 0; i < rounds; i++) {

}
console.log('Test #2:', performance.now() - start);
*/


/*>>core*/

/*>>inline*/

var INLINE_NS = 'inline',
	_hiddenClass,
	_inlinePlaceholder, 
	_lastInlineElement,
	_putInlineElementsBack = function() {
		if(_lastInlineElement) {
			_inlinePlaceholder.after( _lastInlineElement.addClass(_hiddenClass) ).detach();
			_lastInlineElement = null;
		}
	};

$.magnificPopup.registerModule(INLINE_NS, {
	options: {
		hiddenClass: 'hide', // will be appended with `mfp-` prefix
		markup: '',
		tNotFound: 'Content not found'
	},
	proto: {

		initInline: function() {
			mfp.types.push(INLINE_NS);

			_mfpOn(CLOSE_EVENT+'.'+INLINE_NS, function() {
				_putInlineElementsBack();
			});
		},

		getInline: function(item, template) {

			_putInlineElementsBack();

			if(item.src) {
				var inlineSt = mfp.st.inline,
					el = $(item.src);

				if(el.length) {

					// If target element has parent - we replace it with placeholder and put it back after popup is closed
					var parent = el[0].parentNode;
					if(parent && parent.tagName) {
						if(!_inlinePlaceholder) {
							_hiddenClass = inlineSt.hiddenClass;
							_inlinePlaceholder = _getEl(_hiddenClass);
							_hiddenClass = 'mfp-'+_hiddenClass;
						}
						// replace target inline element with placeholder
						_lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
					}

					mfp.updateStatus('ready');
				} else {
					mfp.updateStatus('error', inlineSt.tNotFound);
					el = $('<div>');
				}

				item.inlineElement = el;
				return el;
			}

			mfp.updateStatus('ready');
			mfp._parseMarkup(template, {}, item);
			return template;
		}
	}
});

/*>>inline*/

/*>>ajax*/
var AJAX_NS = 'ajax',
	_ajaxCur,
	_removeAjaxCursor = function() {
		if(_ajaxCur) {
			_body.removeClass(_ajaxCur);
		}
	},
	_destroyAjaxRequest = function() {
		_removeAjaxCursor();
		if(mfp.req) {
			mfp.req.abort();
		}
	};

$.magnificPopup.registerModule(AJAX_NS, {

	options: {
		settings: null,
		cursor: 'mfp-ajax-cur',
		tError: '<a href="%url%">The content</a> could not be loaded.'
	},

	proto: {
		initAjax: function() {
			mfp.types.push(AJAX_NS);
			_ajaxCur = mfp.st.ajax.cursor;

			_mfpOn(CLOSE_EVENT+'.'+AJAX_NS, _destroyAjaxRequest);
			_mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
		},
		getAjax: function(item) {

			if(_ajaxCur)
				_body.addClass(_ajaxCur);

			mfp.updateStatus('loading');

			var opts = $.extend({
				url: item.src,
				success: function(data, textStatus, jqXHR) {
					var temp = {
						data:data,
						xhr:jqXHR
					};

					_mfpTrigger('ParseAjax', temp);

					mfp.appendContent( $(temp.data), AJAX_NS );

					item.finished = true;

					_removeAjaxCursor();

					mfp._setFocus();

					setTimeout(function() {
						mfp.wrap.addClass(READY_CLASS);
					}, 16);

					mfp.updateStatus('ready');

					_mfpTrigger('AjaxContentAdded');
				},
				error: function() {
					_removeAjaxCursor();
					item.finished = item.loadError = true;
					mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
				}
			}, mfp.st.ajax.settings);

			mfp.req = $.ajax(opts);

			return '';
		}
	}
});





	

/*>>ajax*/

/*>>image*/
var _imgInterval,
	_getTitle = function(item) {
		if(item.data && item.data.title !== undefined) 
			return item.data.title;

		var src = mfp.st.image.titleSrc;

		if(src) {
			if($.isFunction(src)) {
				return src.call(mfp, item);
			} else if(item.el) {
				return item.el.attr(src) || '';
			}
		}
		return '';
	};

$.magnificPopup.registerModule('image', {

	options: {
		markup: '<div class="mfp-figure">'+
					'<div class="mfp-close"></div>'+
					'<figure>'+
						'<div class="mfp-img"></div>'+
						'<figcaption>'+
							'<div class="mfp-bottom-bar">'+
								'<div class="mfp-title"></div>'+
								'<div class="mfp-counter"></div>'+
							'</div>'+
						'</figcaption>'+
					'</figure>'+
				'</div>',
		cursor: 'mfp-zoom-out-cur',
		titleSrc: 'title', 
		verticalFit: true,
		tError: '<a href="%url%">The image</a> could not be loaded.'
	},

	proto: {
		initImage: function() {
			var imgSt = mfp.st.image,
				ns = '.image';

			mfp.types.push('image');

			_mfpOn(OPEN_EVENT+ns, function() {
				if(mfp.currItem.type === 'image' && imgSt.cursor) {
					_body.addClass(imgSt.cursor);
				}
			});

			_mfpOn(CLOSE_EVENT+ns, function() {
				if(imgSt.cursor) {
					_body.removeClass(imgSt.cursor);
				}
				_window.off('resize' + EVENT_NS);
			});

			_mfpOn('Resize'+ns, mfp.resizeImage);
			if(mfp.isLowIE) {
				_mfpOn('AfterChange', mfp.resizeImage);
			}
		},
		resizeImage: function() {
			var item = mfp.currItem;
			if(!item || !item.img) return;

			if(mfp.st.image.verticalFit) {
				var decr = 0;
				// fix box-sizing in ie7/8
				if(mfp.isLowIE) {
					decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'),10);
				}
				item.img.css('max-height', mfp.wH-decr);
			}
		},
		_onImageHasSize: function(item) {
			if(item.img) {
				
				item.hasSize = true;

				if(_imgInterval) {
					clearInterval(_imgInterval);
				}
				
				item.isCheckingImgSize = false;

				_mfpTrigger('ImageHasSize', item);

				if(item.imgHidden) {
					if(mfp.content)
						mfp.content.removeClass('mfp-loading');
					
					item.imgHidden = false;
				}

			}
		},

		/**
		 * Function that loops until the image has size to display elements that rely on it asap
		 */
		findImageSize: function(item) {

			var counter = 0,
				img = item.img[0],
				mfpSetInterval = function(delay) {

					if(_imgInterval) {
						clearInterval(_imgInterval);
					}
					// decelerating interval that checks for size of an image
					_imgInterval = setInterval(function() {
						if(img.naturalWidth > 0) {
							mfp._onImageHasSize(item);
							return;
						}

						if(counter > 200) {
							clearInterval(_imgInterval);
						}

						counter++;
						if(counter === 3) {
							mfpSetInterval(10);
						} else if(counter === 40) {
							mfpSetInterval(50);
						} else if(counter === 100) {
							mfpSetInterval(500);
						}
					}, delay);
				};

			mfpSetInterval(1);
		},

		getImage: function(item, template) {

			var guard = 0,

				// image load complete handler
				onLoadComplete = function() {
					if(item) {
						if (item.img[0].complete) {
							item.img.off('.mfploader');
							
							if(item === mfp.currItem){
								mfp._onImageHasSize(item);

								mfp.updateStatus('ready');
							}

							item.hasSize = true;
							item.loaded = true;

							_mfpTrigger('ImageLoadComplete');
							
						}
						else {
							// if image complete check fails 200 times (20 sec), we assume that there was an error.
							guard++;
							if(guard < 200) {
								setTimeout(onLoadComplete,100);
							} else {
								onLoadError();
							}
						}
					}
				},

				// image error handler
				onLoadError = function() {
					if(item) {
						item.img.off('.mfploader');
						if(item === mfp.currItem){
							mfp._onImageHasSize(item);
							mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
						}

						item.hasSize = true;
						item.loaded = true;
						item.loadError = true;
					}
				},
				imgSt = mfp.st.image;


			var el = template.find('.mfp-img');
			if(el.length) {
				var img = document.createElement('img');
				img.className = 'mfp-img';
				item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
				img.src = item.src;

				// without clone() "error" event is not firing when IMG is replaced by new IMG
				// TODO: find a way to avoid such cloning
				if(el.is('img')) {
					item.img = item.img.clone();
				}

				img = item.img[0];
				if(img.naturalWidth > 0) {
					item.hasSize = true;
				} else if(!img.width) {										
					item.hasSize = false;
				}
			}

			mfp._parseMarkup(template, {
				title: _getTitle(item),
				img_replaceWith: item.img
			}, item);

			mfp.resizeImage();

			if(item.hasSize) {
				if(_imgInterval) clearInterval(_imgInterval);

				if(item.loadError) {
					template.addClass('mfp-loading');
					mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
				} else {
					template.removeClass('mfp-loading');
					mfp.updateStatus('ready');
				}
				return template;
			}

			mfp.updateStatus('loading');
			item.loading = true;

			if(!item.hasSize) {
				item.imgHidden = true;
				template.addClass('mfp-loading');
				mfp.findImageSize(item);
			} 

			return template;
		}
	}
});



/*>>image*/

/*>>zoom*/
var hasMozTransform,
	getHasMozTransform = function() {
		if(hasMozTransform === undefined) {
			hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
		}
		return hasMozTransform;		
	};

$.magnificPopup.registerModule('zoom', {

	options: {
		enabled: false,
		easing: 'ease-in-out',
		duration: 300,
		opener: function(element) {
			return element.is('img') ? element : element.find('img');
		}
	},

	proto: {

		initZoom: function() {
			var zoomSt = mfp.st.zoom,
				ns = '.zoom',
				image;
				
			if(!zoomSt.enabled || !mfp.supportsTransition) {
				return;
			}

			var duration = zoomSt.duration,
				getElToAnimate = function(image) {
					var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
						transition = 'all '+(zoomSt.duration/1000)+'s ' + zoomSt.easing,
						cssObj = {
							position: 'fixed',
							zIndex: 9999,
							left: 0,
							top: 0,
							'-webkit-backface-visibility': 'hidden'
						},
						t = 'transition';

					cssObj['-webkit-'+t] = cssObj['-moz-'+t] = cssObj['-o-'+t] = cssObj[t] = transition;

					newImg.css(cssObj);
					return newImg;
				},
				showMainContent = function() {
					mfp.content.css('visibility', 'visible');
				},
				openTimeout,
				animatedImg;

			_mfpOn('BuildControls'+ns, function() {
				if(mfp._allowZoom()) {

					clearTimeout(openTimeout);
					mfp.content.css('visibility', 'hidden');

					// Basically, all code below does is clones existing image, puts in on top of the current one and animated it
					
					image = mfp._getItemToZoom();

					if(!image) {
						showMainContent();
						return;
					}

					animatedImg = getElToAnimate(image); 
					
					animatedImg.css( mfp._getOffset() );

					mfp.wrap.append(animatedImg);

					openTimeout = setTimeout(function() {
						animatedImg.css( mfp._getOffset( true ) );
						openTimeout = setTimeout(function() {

							showMainContent();

							setTimeout(function() {
								animatedImg.remove();
								image = animatedImg = null;
								_mfpTrigger('ZoomAnimationEnded');
							}, 16); // avoid blink when switching images 

						}, duration); // this timeout equals animation duration

					}, 16); // by adding this timeout we avoid short glitch at the beginning of animation


					// Lots of timeouts...
				}
			});
			_mfpOn(BEFORE_CLOSE_EVENT+ns, function() {
				if(mfp._allowZoom()) {

					clearTimeout(openTimeout);

					mfp.st.removalDelay = duration;

					if(!image) {
						image = mfp._getItemToZoom();
						if(!image) {
							return;
						}
						animatedImg = getElToAnimate(image);
					}
					
					
					animatedImg.css( mfp._getOffset(true) );
					mfp.wrap.append(animatedImg);
					mfp.content.css('visibility', 'hidden');
					
					setTimeout(function() {
						animatedImg.css( mfp._getOffset() );
					}, 16);
				}

			});

			_mfpOn(CLOSE_EVENT+ns, function() {
				if(mfp._allowZoom()) {
					showMainContent();
					if(animatedImg) {
						animatedImg.remove();
					}
					image = null;
				}	
			});
		},

		_allowZoom: function() {
			return mfp.currItem.type === 'image';
		},

		_getItemToZoom: function() {
			if(mfp.currItem.hasSize) {
				return mfp.currItem.img;
			} else {
				return false;
			}
		},

		// Get element postion relative to viewport
		_getOffset: function(isLarge) {
			var el;
			if(isLarge) {
				el = mfp.currItem.img;
			} else {
				el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
			}

			var offset = el.offset();
			var paddingTop = parseInt(el.css('padding-top'),10);
			var paddingBottom = parseInt(el.css('padding-bottom'),10);
			offset.top -= ( $(window).scrollTop() - paddingTop );


			/*
			
			Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.

			 */
			var obj = {
				width: el.width(),
				// fix Zepto height+padding issue
				height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
			};

			// I hate to do this, but there is no another option
			if( getHasMozTransform() ) {
				obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
			} else {
				obj.left = offset.left;
				obj.top = offset.top;
			}
			return obj;
		}

	}
});



/*>>zoom*/

/*>>iframe*/

var IFRAME_NS = 'iframe',
	_emptyPage = '//about:blank',
	
	_fixIframeBugs = function(isShowing) {
		if(mfp.currTemplate[IFRAME_NS]) {
			var el = mfp.currTemplate[IFRAME_NS].find('iframe');
			if(el.length) { 
				// reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
				if(!isShowing) {
					el[0].src = _emptyPage;
				}

				// IE8 black screen bug fix
				if(mfp.isIE8) {
					el.css('display', isShowing ? 'block' : 'none');
				}
			}
		}
	};

$.magnificPopup.registerModule(IFRAME_NS, {

	options: {
		markup: '<div class="mfp-iframe-scaler">'+
					'<div class="mfp-close"></div>'+
					'<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>'+
				'</div>',

		srcAction: 'iframe_src',

		// we don't care and support only one default type of URL by default
		patterns: {
			youtube: {
				index: 'youtube.com', 
				id: 'v=', 
				src: '//www.youtube.com/embed/%id%?autoplay=1'
			},
			vimeo: {
				index: 'vimeo.com/',
				id: '/',
				src: '//player.vimeo.com/video/%id%?autoplay=1'
			},
			gmaps: {
				index: '//maps.google.',
				src: '%id%&output=embed'
			}
		}
	},

	proto: {
		initIframe: function() {
			mfp.types.push(IFRAME_NS);

			_mfpOn('BeforeChange', function(e, prevType, newType) {
				if(prevType !== newType) {
					if(prevType === IFRAME_NS) {
						_fixIframeBugs(); // iframe if removed
					} else if(newType === IFRAME_NS) {
						_fixIframeBugs(true); // iframe is showing
					} 
				}// else {
					// iframe source is switched, don't do anything
				//}
			});

			_mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function() {
				_fixIframeBugs();
			});
		},

		getIframe: function(item, template) {
			var embedSrc = item.src;
			var iframeSt = mfp.st.iframe;
				
			$.each(iframeSt.patterns, function() {
				if(embedSrc.indexOf( this.index ) > -1) {
					if(this.id) {
						if(typeof this.id === 'string') {
							embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id)+this.id.length, embedSrc.length);
						} else {
							embedSrc = this.id.call( this, embedSrc );
						}
					}
					embedSrc = this.src.replace('%id%', embedSrc );
					return false; // break;
				}
			});
			
			var dataObj = {};
			if(iframeSt.srcAction) {
				dataObj[iframeSt.srcAction] = embedSrc;
			}
			mfp._parseMarkup(template, dataObj, item);

			mfp.updateStatus('ready');

			return template;
		}
	}
});



/*>>iframe*/

/*>>gallery*/
/**
 * Get looped index depending on number of slides
 */
var _getLoopedId = function(index) {
		var numSlides = mfp.items.length;
		if(index > numSlides - 1) {
			return index - numSlides;
		} else  if(index < 0) {
			return numSlides + index;
		}
		return index;
	},
	_replaceCurrTotal = function(text, curr, total) {
		return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
	};

$.magnificPopup.registerModule('gallery', {

	options: {
		enabled: false,
		arrowMarkup: '<div title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></div>',
		preload: [0,2],
		navigateByImgClick: true,
		arrows: true,

		tPrev: 'Previous (Left arrow key)',
		tNext: 'Next (Right arrow key)',
		tCounter: '%curr% of %total%'
	},

	proto: {
		initGallery: function() {

			var gSt = mfp.st.gallery,
				ns = '.mfp-gallery',
				supportsFastClick = Boolean($.fn.mfpFastClick);

			mfp.direction = true; // true - next, false - prev
			
			if(!gSt || !gSt.enabled ) return false;

			_wrapClasses += ' mfp-gallery';

			_mfpOn(OPEN_EVENT+ns, function() {

				if(gSt.navigateByImgClick) {
					mfp.wrap.on('click'+ns, '.mfp-img', function() {
						if(mfp.items.length > 1) {
							mfp.next();
							return false;
						}
					});
				}

				_document.on('keydown'+ns, function(e) {
					if (e.keyCode === 37) {
						mfp.prev();
					} else if (e.keyCode === 39) {
						mfp.next();
					}
				});
			});

			_mfpOn('UpdateStatus'+ns, function(e, data) {
				if(data.text) {
					data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
				}
			});

			_mfpOn(MARKUP_PARSE_EVENT+ns, function(e, element, values, item) {
				var l = mfp.items.length;
				values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
			});

			_mfpOn('BuildControls' + ns, function() {
				if(mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
					var markup = gSt.arrowMarkup,
						arrowLeft = mfp.arrowLeft = $( markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left') ).addClass(PREVENT_CLOSE_CLASS),			
						arrowRight = mfp.arrowRight = $( markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right') ).addClass(PREVENT_CLOSE_CLASS);

					var eName = supportsFastClick ? 'mfpFastClick' : 'click';
					arrowLeft[eName](function() {
						mfp.prev();
					});			
					arrowRight[eName](function() {
						mfp.next();
					});	

					// Polyfill for :before and :after (adds elements with classes mfp-a and mfp-b)
					if(mfp.isIE7) {
						_getEl('b', arrowLeft[0], false, true);
						_getEl('a', arrowLeft[0], false, true);
						_getEl('b', arrowRight[0], false, true);
						_getEl('a', arrowRight[0], false, true);
					}

					mfp.container.append(arrowLeft.add(arrowRight));
				}
			});

			_mfpOn(CHANGE_EVENT+ns, function() {
				if(mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

				mfp._preloadTimeout = setTimeout(function() {
					mfp.preloadNearbyImages();
					mfp._preloadTimeout = null;
				}, 16);		
			});


			_mfpOn(CLOSE_EVENT+ns, function() {
				_document.off(ns);
				mfp.wrap.off('click'+ns);
			
				if(mfp.arrowLeft && supportsFastClick) {
					mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
				}
				mfp.arrowRight = mfp.arrowLeft = null;
			});

		}, 
		next: function() {
			mfp.direction = true;
			mfp.index = _getLoopedId(mfp.index + 1);
			mfp.updateItemHTML();
		},
		prev: function() {
			mfp.direction = false;
			mfp.index = _getLoopedId(mfp.index - 1);
			mfp.updateItemHTML();
		},
		goTo: function(newIndex) {
			mfp.direction = (newIndex >= mfp.index);
			mfp.index = newIndex;
			mfp.updateItemHTML();
		},
		preloadNearbyImages: function() {
			var p = mfp.st.gallery.preload,
				preloadBefore = Math.min(p[0], mfp.items.length),
				preloadAfter = Math.min(p[1], mfp.items.length),
				i;

			for(i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
				mfp._preloadItem(mfp.index+i);
			}
			for(i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
				mfp._preloadItem(mfp.index-i);
			}
		},
		_preloadItem: function(index) {
			index = _getLoopedId(index);

			if(mfp.items[index].preloaded) {
				return;
			}

			var item = mfp.items[index];
			if(!item.parsed) {
				item = mfp.parseEl( index );
			}

			_mfpTrigger('LazyLoad', item);

			if(item.type === 'image') {
				item.img = $('<img class="mfp-img" />').on('load.mfploader', function() {
					item.hasSize = true;
				}).on('error.mfploader', function() {
					item.hasSize = true;
					item.loadError = true;
					_mfpTrigger('LazyLoadError', item);
				}).attr('src', item.src);
			}


			item.preloaded = true;
		}
	}
});

/*
Touch Support that might be implemented some day

addSwipeGesture: function() {
	var startX,
		moved,
		multipleTouches;

		return;

	var namespace = '.mfp',
		addEventNames = function(pref, down, move, up, cancel) {
			mfp._tStart = pref + down + namespace;
			mfp._tMove = pref + move + namespace;
			mfp._tEnd = pref + up + namespace;
			mfp._tCancel = pref + cancel + namespace;
		};

	if(window.navigator.msPointerEnabled) {
		addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
	} else if('ontouchstart' in window) {
		addEventNames('touch', 'start', 'move', 'end', 'cancel');
	} else {
		return;
	}
	_window.on(mfp._tStart, function(e) {
		var oE = e.originalEvent;
		multipleTouches = moved = false;
		startX = oE.pageX || oE.changedTouches[0].pageX;
	}).on(mfp._tMove, function(e) {
		if(e.originalEvent.touches.length > 1) {
			multipleTouches = e.originalEvent.touches.length;
		} else {
			//e.preventDefault();
			moved = true;
		}
	}).on(mfp._tEnd + ' ' + mfp._tCancel, function(e) {
		if(moved && !multipleTouches) {
			var oE = e.originalEvent,
				diff = startX - (oE.pageX || oE.changedTouches[0].pageX);

			if(diff > 20) {
				mfp.next();
			} else if(diff < -20) {
				mfp.prev();
			}
		}
	});
},
*/


/*>>gallery*/

/*>>retina*/

var RETINA_NS = 'retina';

$.magnificPopup.registerModule(RETINA_NS, {
	options: {
		replaceSrc: function(item) {
			return item.src.replace(/\.\w+$/, function(m) { return '@2x' + m; });
		},
		ratio: 1 // Function or number.  Set to 1 to disable.
	},
	proto: {
		initRetina: function() {
			if(window.devicePixelRatio > 1) {

				var st = mfp.st.retina,
					ratio = st.ratio;

				ratio = !isNaN(ratio) ? ratio : ratio();

				if(ratio > 1) {
					_mfpOn('ImageHasSize' + '.' + RETINA_NS, function(e, item) {
						item.img.css({
							'max-width': item.img[0].naturalWidth / ratio,
							'width': '100%'
						});
					});
					_mfpOn('ElementParse' + '.' + RETINA_NS, function(e, item) {
						item.src = st.replaceSrc(item, ratio);
					});
				}
			}

		}
	}
});

/*>>retina*/

/*>>fastclick*/
/**
 * FastClick event implementation. (removes 300ms delay on touch devices)
 * Based on https://developers.google.com/mobile/articles/fast_buttons
 *
 * You may use it outside the Magnific Popup by calling just:
 *
 * $('.your-el').mfpFastClick(function() {
 *     console.log('Clicked!');
 * });
 *
 * To unbind:
 * $('.your-el').destroyMfpFastClick();
 * 
 * 
 * Note that it's a very basic and simple implementation, it blocks ghost click on the same element where it was bound.
 * If you need something more advanced, use plugin by FT Labs https://github.com/ftlabs/fastclick
 * 
 */

(function() {
	var ghostClickDelay = 1000,
		supportsTouch = 'ontouchstart' in window,
		unbindTouchMove = function() {
			_window.off('touchmove'+ns+' touchend'+ns);
		},
		eName = 'mfpFastClick',
		ns = '.'+eName;


	// As Zepto.js doesn't have an easy way to add custom events (like jQuery), so we implement it in this way
	$.fn.mfpFastClick = function(callback) {

		return $(this).each(function() {

			var elem = $(this),
				lock;

			if( supportsTouch ) {

				var timeout,
					startX,
					startY,
					pointerMoved,
					point,
					numPointers;

				elem.on('touchstart' + ns, function(e) {
					pointerMoved = false;
					numPointers = 1;

					point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
					startX = point.clientX;
					startY = point.clientY;

					_window.on('touchmove'+ns, function(e) {
						point = e.originalEvent ? e.originalEvent.touches : e.touches;
						numPointers = point.length;
						point = point[0];
						if (Math.abs(point.clientX - startX) > 10 ||
							Math.abs(point.clientY - startY) > 10) {
							pointerMoved = true;
							unbindTouchMove();
						}
					}).on('touchend'+ns, function(e) {
						unbindTouchMove();
						if(pointerMoved || numPointers > 1) {
							return;
						}
						lock = true;
						e.preventDefault();
						clearTimeout(timeout);
						timeout = setTimeout(function() {
							lock = false;
						}, ghostClickDelay);
						callback();
					});
				});

			}

			elem.on('click' + ns, function() {
				if(!lock) {
					callback();
				}
			});
		});
	};

	$.fn.destroyMfpFastClick = function() {
		$(this).off('touchstart' + ns + ' click' + ns);
		if(supportsTouch) _window.off('touchmove'+ns+' touchend'+ns);
	};
})();

/*>>fastclick*/
 _checkInstance(); })(window.jQuery || window.Zepto);
/*!
 * hoverIntent r7 // 2013.03.11 // jQuery 1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license.
 * Copyright 2007, 2013 Brian Cherne
 */
(function(e){e.fn.hoverIntent=function(t,n,r){var i={interval:100,sensitivity:7,timeout:0};if(typeof t==="object"){i=e.extend(i,t)}else if(e.isFunction(n)){i=e.extend(i,{over:t,out:n,selector:r})}else{i=e.extend(i,{over:t,out:t,selector:n})}var s,o,u,a;var f=function(e){s=e.pageX;o=e.pageY};var l=function(t,n){n.hoverIntent_t=clearTimeout(n.hoverIntent_t);if(Math.abs(u-s)+Math.abs(a-o)<i.sensitivity){e(n).off("mousemove.hoverIntent",f);n.hoverIntent_s=1;return i.over.apply(n,[t])}else{u=s;a=o;n.hoverIntent_t=setTimeout(function(){l(t,n)},i.interval)}};var c=function(e,t){t.hoverIntent_t=clearTimeout(t.hoverIntent_t);t.hoverIntent_s=0;return i.out.apply(t,[e])};var h=function(t){var n=jQuery.extend({},t);var r=this;if(r.hoverIntent_t){r.hoverIntent_t=clearTimeout(r.hoverIntent_t)}if(t.type=="mouseenter"){u=n.pageX;a=n.pageY;e(r).on("mousemove.hoverIntent",f);if(r.hoverIntent_s!=1){r.hoverIntent_t=setTimeout(function(){l(n,r)},i.interval)}}else{e(r).off("mousemove.hoverIntent",f);if(r.hoverIntent_s==1){r.hoverIntent_t=setTimeout(function(){c(n,r)},i.timeout)}}};return this.on({"mouseenter.hoverIntent":h,"mouseleave.hoverIntent":h},i.selector)}})(jQuery)
// NOTE: plugin has been changed by Oleksii An according to project needs

var jquerybindings_cache = {};
$.bindings = {};

$.fn.bindings = function (type) {
    var self = this;

    if (typeof (type) === 'undefined')
        type = 'model';

    var schema = self.attr('data-name');

    switch (type) {
        case 'create':
            return (function (model, template) { return bindings_create.call(self, model, template, schema); });
        case 'json':
            return (function (query, template) { return bindings_json.call(self, query, template, schema); });
        case 'download':
            return (function (url, template, options) { return bindings_download.call(self, url, template, options, schema); });
        case 'change':
            return (function (value) { if (typeof (value) !== 'boolean') return self.data('isChange') || false; return self.data('isChange', value); });
        case 'refresh':
            bindings_refresh.call(self, schema);
            return;
        case 'destroy':
            bindings_destroy.call(self, schema);
            return;
        case 'default':
            bindings_default.call(self, schema);
            return;
        case 'validate':
        case 'validation':
            return bindings_validate.call(self, schema);
        case 'set':
            return (function (path, value) { return bindings_set.call(self, path, value, schema); });
        case 'get':
            return (function (path) { return bindings_get.call(self, path, schema); });
        case 'update':
            return (function (model) { return bindings_create.call(self, model, schema); });
        case 'model':
            return bindings_create.call(self, null, null, schema);
        case 'send':
            return (function (url, options, callback) {
                if (typeof (options) === 'function') {
                    var tmp = callback;
                    callback = options;
                    options = callback;
                }
                return bindings_send.call(self, url, options, schema, callback);
            });
    }

    return self;
};

function bindings_create(model, template, schema) {
    var self = this;
    var $textFields = self.find('input[type=text][data-model], input[type=email][data-model], textarea[data-model]');

    if (typeof (model) === 'undefined' || model === null)
        return $.extend({}, self.data('model'));

    var tmp = self.data('model');

    self.data('isChange', false);

    if (typeof (tmp) !== 'undefined') {
        if (typeof (model) === 'function') {
            tmp = model(tmp);
            if (tmp)
                self.data('model', tmp);
        }
        else
            self.data('model', model);

        bindings_refresh.call(self, schema);
        self.trigger('model-update', [model, schema]);
        return self;
    }

    if (typeof (template) !== 'undefined') {
        if (template.substring(0, 1) === '/') {
            self.trigger('template-download-begin', [template]);
            $.get(template, {}, function (data) {
                self.trigger('template-download-end', [template, data]);
                bindings_create.call(self, self.data('model'), data);
            });
            return;
        }

        if (template.indexOf('>') !== -1 && template.indexOf('<') !== -1)
            self.html(template);
        else
            template = $(template).html();
    }

    self.data('default', $.extend(true, {}, model));
    self.data('model', model);

    self.on('change', 'input[data-model]', function (e) {
        bindings_internal_change.call(this, e, self, self.data('model'), schema);
    });

    self.on('change', 'textarea[data-model],select[data-model]', function (e) {
        bindings_internal_change.call(this, e, self, self.data('model'), schema);
    });

    self.on('focus', 'input[data-model],textarea[data-model]', function(e) {
        self.timer = setInterval(function() {
            $textFields.each(function() {
                var $el = $(this);
                if ($el.data('binding-memento') !== $el.val()) {
                    bindings_internal_change.call(this, e, self, self.data('model'), schema, true);
                }
            });
        }, 100);
    });

    self.on('blur', 'input[data-model],textarea[data-model]', function() {
        clearInterval(self.timer);
    });

    bindings_refresh.call(self, schema);

    bindings_delay(function() {
        self.trigger('model-create', [model, schema]);
    });

    return bindings_rebind.call(self);
}

function bindings_internal_change(e, self, model, schema, dontUpdateElement) {
    var el = $(this);
    var name = el.attr('data-model');
    var type = el.attr('type');
    var value = el.val();

    // NOTE: plugin has been changed by Oleksii An according to project needs
    if (!(/(MSIE\ [0-8]\.\d+)/.test(navigator.userAgent))) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }

    if (type === 'checkbox')
        value = this.checked;

    var prepare = el.attr('data-prepare');
    var value_new = $.bindings.prepare.call(el, name, value, prepare, model, schema);

    if (typeof (value_new) === 'undefined')
        value_new = $.bindings._prepare.call(el, name, value, prepare, model, schema);

    var r = $.bindings._validation.call(el, name, value_new, model, schema);
    $.bindings.watch.call(el, r, name, value_new, model, schema);

    if (!r)
        return;

    el.data('binding-memento', value_new);
    bindings_setvalue.call(el, model, name, value_new, schema);

    if (!dontUpdateElement) {
        if (type !== 'checkbox' && type !== 'radio') {
            switch (this.tagName.toLowerCase()) {
                case 'input':
                case 'textarea':
                    this.value = $.bindings.format.call(el, name, value_new, el.attr('data-format'), self.data('model'), schema);
                    break;
            }
        } else
            this.checked = value;
    }

    bindings_rebind.call(self, schema);
    self.data('isChange', true);

    bindings_delay(function() {
        self.trigger('model-change', [name, value_new, model, schema, el]);
        self.trigger('model-update', [model, name, schema]);
    });
}

function bindings_json(query, template, schema) {
    var el = this;
    var q = $(query);
    var tag = q.get(0).tagName.toLowerCase();

    switch (tag) {
        case 'input':
        case 'select':
        case 'textarea':
            bindings_create.call(el, $.parseJSON(q.val().replace(/\n/g, '\\n')), template, schema);
            return;
    }

    bindings_create.call(el, $.parseJSON(q.html().replace(/\n/g, '\\n')), template, schema);
    return el;
}

function bindings_download(url, template, options, schema) {
    var self = this;

    if (typeof (template) === 'object') {
        var tmp = options;
        options = template;
        template = options;
    }

    if (!options)
        options = {};

    if (!options.type)
        options.type = 'GET';

    if (!options.dataType)
        options.dataType = 'json';

    var key = url + JSON.stringify(options);
    if (jquerybindings_cache[key])
        return;

    self.trigger('model-download-begin', [url]);

    options.success = function (data) {
        self.trigger('model-download-end', [url, data, schema]);
        delete jquerybindings_cache[key];
        bindings_create.call(self, data, template, schema);
    };

    options.error = function (xhr, status) {
        self.trigger('model-download-end', [url, schema]);
        delete jquerybindings_cache[key];
        self.trigger('model-download-error', [status, url, schema]);
    };

    $.ajax(url, options);
    return self;
}

function bindings_destroy() {
    var self = this;
    var schema = self.attr('data-name');
    self.removeData('model');
    self.removeData('default');
    self.removeData('isChange');
    self.find('input[data-model],textarea[data-model],select[data-model]').unbind('change');
    self.trigger('model-destroy', [schema]);
    return self;
}

function bindings_default() {
    var self = this;
    var model = self.data('default');
    var schema = self.attr('data-name');
    self.data('model', $.extend({}, model));
    self.data('isChange', false);
    bindings_refresh.call(self, schema);
    bindings_delay(function() {
        self.trigger('model-default', [model, schema]);
    });
    return self;
}

function bindings_validate(schema) {
    var self = this;
    var model = self.data('model');
    var error = [];

    bindings_reflection(model, function (path, value, key) {
        var r = $.bindings._validation(path, value, schema);
        if (typeof (r) === 'undefined' || r === null || r)
            return;
        error.push({ path: path, value: value, element: self.find('input[data-model="' + path + '"],textarea[data-model="' + path + '"],select[data-model="' + path + '"]') });
    });

    self.trigger('validate', [error, schema]);
    self.trigger('validation', [error, schema]);
    self.trigger('model-validate', [error, schema]);
    self.trigger('model-validation', [error, schema]);
    return self;
}

function bindings_set(path, value, schema) {
    var self = this;
    var model = self.data('model');

    if (typeof (model) === 'undefined')
        return self;

    if (typeof (value) === 'function')
        value = value(bindings_getvalue(model, path, schema));

    var r = $.bindings._validation(path, value, model, schema);
    $.bindings.watch.call($('input[data-model="' + path + '"],textarea[data-model="' + path + '"],select[data-model="' + path + '"]'), r, path, value, model, schema);

    if (!r)
        return self;

    if (bindings_setvalue(model, path, value, schema))
        bindings_refresh.call(self, schema);

    self.data('isChange', true);
    self.trigger('model-update', [model, path, schema]);
    return self;
}

function bindings_get(path, schema) {
    var self = this;
    var model = self.data('model');
    if (typeof (model) === 'undefined')
        return;
    return bindings_getvalue(model, path, schema);
}

function bindings_rebind_force(schema) {
    var self = this;
    var model = self.data('model');

    if (typeof (model) === 'undefined')
        return self;

    self.find('[data-model]').each(function () {
        var tag = this.tagName.toLowerCase();
        if (tag === 'input' || tag === 'select' || tag === 'textarea')
            return;

        var el = $(this);
        var name = el.attr('data-model');
        var custom = el.attr('data-custom');
        var value = bindings_getvalue(model, name);

        if (typeof (custom) !== 'undefined') {
            $.bindings.custom.call(el, name, value, custom || '', model, schema);
            return;
        }

        var attr = el.attr('data-encode');
        var isRaw = typeof (attr) !== 'undefined' && attr === 'false';
        var val = $.bindings.format.call(el, name, value, el.attr('data-format'), model, schema);

        if (typeof (val) === 'undefined')
            val = '';

        if (typeof (val) !== 'string') {
            if (val instanceof Array)
                val = val.join(', ');
            else
                val = val === null ? '' : val.toString();
        }

        el.html(val);
    });

    return self;
}

function bindings_rebind(schema) {
    var self = this;
    var model = self.data('model');

    if (typeof (model) === 'undefined')
        return self;

    var timeout = self.data('timeout_rebind') || null;

    if (timeout !== null)
        clearTimeout(timeout);

    var timeout = setTimeout(function () {
        bindings_rebind_force.call(self, schema);
    }, 100);

    self.data('timeout_rebind', timeout);
    return self;
}

function bindings_refresh(schema) {
    var self = this;
    var model = self.data('model');

    if (typeof (model) === 'undefined')
        return self;

    var timeout = self.data('timeout_refresh') || null;
    if (timeout !== null)
        clearTimeout(timeout);

    var timeout = setTimeout(function () {
        bindings_refresh_force.call(self, schema);
    }, 100);

    self.data('timeout_refresh', timeout);
    return self;
}

function bindings_refresh_force(schema) {
    var self = this;

    var model = self.data('model');

    if (typeof (model) === 'undefined') {
        model = {};
        self.data('model', model);
    }

    self.find('[data-model]').each(function () {
        var el = $(this);
        var name = el.attr('data-model') || '';
        var isIO = false;

        switch (this.tagName.toLowerCase()) {
            case 'input':
            case 'textarea':
            case 'select':
                isIO = true;
                break;
        }

        var value = bindings_getvalue(model, name, schema);
        var format = el.attr('data-format');
        var custom = el.attr('data-custom');

        if (typeof (value) === 'undefined')
            value = el.attr('data-default');

        if (typeof (custom) !== 'undefined') {
            $.bindings.custom.call(el, name, value, custom || '', model, schema);
            return;
        }

        var val = $.bindings.format.call(self, name, value, format, model, schema);

        if (isIO) {
            var type = el.attr('type');
            if (type === 'checkbox')
                this.checked = value === true || value === 1 || value === 'true';
            else if (type === 'radio') {
                if (this.value == value)
                    this.checked = true;
                else
                    return;
            } else
                el.val(val);

            return;
        }

        var attr = el.attr('data-encode');
        var isRaw = typeof (attr) !== 'undefined' && attr === 'false';

        if (typeof (val) === 'undefined')
            val = '';

        if (typeof (val) !== 'string') {
            if (val instanceof Array)
                val = val.join(', ');
            else
                val = val === null ? '' : val.toString();
        }

        el.html(isRaw ? val : val.encode());
    });

    return self;
}

function bindings_send(url, options, schema, callback) {
    var self = this;
    var model = self.data('model');

    if (!model)
        return self;

    var self = this;

    if ($.isPlainObject(url)) {
        var tmp = options;
        options = url;
        url = tmp;
    }

    url = url || window.location.pathname;

    if (!options)
        options = {};

    if (!options.type)
        options.type = 'POST';

    if (!options.dataType)
        options.dataType = 'json';

    var key = url + JSON.stringify(options);
    if (jquerybindings_cache[key])
        return;

    self.trigger('model-send-begin', [url, model, schema]);

    options.contentType = 'application/json';
    options.data = JSON.stringify(model);

    options.success = function (data) {
        self.trigger('model-send-end', [url, model, schema]);
        delete jquerybindings_cache[key];
        self.trigger('send', [data, model, schema]);
        self.trigger('model-send', [data, model, schema]);
        if (callback)
            callback(null, data);
    };

    options.error = function (xhr, status) {
        self.trigger('model-send-end', [url, model, schema]);
        delete jquerybindings_cache[key];
        self.trigger('model-send-error', [status, url, model, schema]);
        if (callback)
            callback(status, null);
    };

    $.ajax(url, options);
    return self;
}

$.bindings.prepare = function (path, value, format, model, schema) { }

$.bindings._prepare = function (path, value, format, model, schema) {
    if (typeof (value) !== 'string')
        return value;

    if (bindings_getvalue(model, path) instanceof Array) {
        var arr = value.split(',');
        var length = arr.length;
        var tmp = [];
        for (var i = 0; i < length; i++) {
            var val = $.trim(arr[i]);
            if (val.length > 0)
                tmp.push(val);
        }
        return tmp;
    }

    if (!value.isNumber())
        return value;

    if (value[0] === '0' && value.length > 1)
        return value;

    value = value.replace(',', '.');
    if (value.indexOf('.') === -1)
        return parseInt(value);

    return parseFloat(value);
};

$.bindings.format = function (path, value, format, model, schema) {
    if (value instanceof Array)
        return value.join(', ');
    return value;
};

$.bindings.custom = function (path, value, custom, model, schema) { };
$.bindings.watch = function (isValid, path, value, model, schema) { };

$.bindings.validation = function (path, value, model, schema) {
    return true;
};

$.bindings._validation = function (path, value, model, schema) {
    var r = $.bindings.validation(path, value, model, schema);
    if (typeof (r) === 'undefined' || r === null)
        r = true;
    return r === true;
};

function bindings_setvalue(obj, path, value, schema) {

    path = path.split('.');
    var length = path.length;
    var current = obj;

    for (var i = 0; i < length - 1; i++) {
        current = bindings_findpipe(current, path[i]);
        if (typeof (current) === 'undefined')
            return false;
    }

    current = bindings_findpipe(current, path[length - 1], value);
    return true;
}

function bindings_findpipe(current, name, value) {
    var beg = name.lastIndexOf('[');
    var pipe;
    var index = -1;

    if (beg !== -1) {

        index = parseInt(name.substring(beg + 1).replace(/\]\[/g, ''));
        if (isNaN(index))
            return;

        name = name.substring(0, beg);
        pipe = current[name][index];

    } else
        pipe = current[name];

    if (typeof (pipe) === 'undefined')
        return;

    if (typeof(value) === 'undefined')
        return pipe;

    if (index !== -1) {
        current[name][index] = value;
        pipe = current[name][index];
    } else {
        current[name] = value;
        pipe = current[name];
    }

    return pipe;
}

function bindings_getvalue(obj, path, schema) {
    path = path.split('.');
    var length = path.length;
    var current = obj;
    for (var i = 0; i < path.length; i++) {
        current = bindings_findpipe(current, path[i]);
        if (typeof (current) === 'undefined')
            return;
    }
    return current;
}

if (!String.prototype.isNumber) {
    String.prototype.isNumber = function (isDecimal) {
        var self = this;
        var length = self.length;

        if (length === 0)
            return false;

        isDecimal = isDecimal || true;

        for (var i = 0; i < length; i++) {
            var ascii = self.charCodeAt(i);

            if (isDecimal) {
                if (ascii === 44 || ascii === 46) {
                    isDecimal = false;
                    continue;
                }
            }

            if (ascii < 48 || ascii > 57)
                return false;
        }

        return true;
    };
}

if (!String.prototype.encode) {
    String.prototype.encode = function () {
        return this.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    };
}

function bindings_reflection(obj, fn, path) {
    path = path || '';
    for (var k in obj) {
        if (typeof (k) !== 'string')
            continue;

        var current = path + (path !== '' ? '.' : '') + k;
        var type = typeof (obj[k]);

        if (type === 'function')
            continue;

        fn(current, obj[k], k);

        if (type === 'object')
            bindings_reflection(obj[k], fn, current);
    }
}

function bindings_delay(fn) {
    setTimeout(function() {
        fn();
    }, 120);
}
// Generated by CoffeeScript 1.6.2
/*!
jQuery Waypoints - v2.0.5
Copyright (c) 2011-2014 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/
(function(){var t=[].indexOf||function(t){for(var e=0,n=this.length;e<n;e++){if(e in this&&this[e]===t)return e}return-1},e=[].slice;(function(t,e){if(typeof define==="function"&&define.amd){return define("waypoints",["jquery"],function(n){return e(n,t)})}else{return e(t.jQuery,t)}})(window,function(n,r){var i,o,l,s,f,u,c,a,h,d,p,y,v,w,g,m;i=n(r);a=t.call(r,"ontouchstart")>=0;s={horizontal:{},vertical:{}};f=1;c={};u="waypoints-context-id";p="resize.waypoints";y="scroll.waypoints";v=1;w="waypoints-waypoint-ids";g="waypoint";m="waypoints";o=function(){function t(t){var e=this;this.$element=t;this.element=t[0];this.didResize=false;this.didScroll=false;this.id="context"+f++;this.oldScroll={x:t.scrollLeft(),y:t.scrollTop()};this.waypoints={horizontal:{},vertical:{}};this.element[u]=this.id;c[this.id]=this;t.bind(y,function(){var t;if(!(e.didScroll||a)){e.didScroll=true;t=function(){e.doScroll();return e.didScroll=false};return r.setTimeout(t,n[m].settings.scrollThrottle)}});t.bind(p,function(){var t;if(!e.didResize){e.didResize=true;t=function(){n[m]("refresh");return e.didResize=false};return r.setTimeout(t,n[m].settings.resizeThrottle)}})}t.prototype.doScroll=function(){var t,e=this;t={horizontal:{newScroll:this.$element.scrollLeft(),oldScroll:this.oldScroll.x,forward:"right",backward:"left"},vertical:{newScroll:this.$element.scrollTop(),oldScroll:this.oldScroll.y,forward:"down",backward:"up"}};if(a&&(!t.vertical.oldScroll||!t.vertical.newScroll)){n[m]("refresh")}n.each(t,function(t,r){var i,o,l;l=[];o=r.newScroll>r.oldScroll;i=o?r.forward:r.backward;n.each(e.waypoints[t],function(t,e){var n,i;if(r.oldScroll<(n=e.offset)&&n<=r.newScroll){return l.push(e)}else if(r.newScroll<(i=e.offset)&&i<=r.oldScroll){return l.push(e)}});l.sort(function(t,e){return t.offset-e.offset});if(!o){l.reverse()}return n.each(l,function(t,e){if(e.options.continuous||t===l.length-1){return e.trigger([i])}})});return this.oldScroll={x:t.horizontal.newScroll,y:t.vertical.newScroll}};t.prototype.refresh=function(){var t,e,r,i=this;r=n.isWindow(this.element);e=this.$element.offset();this.doScroll();t={horizontal:{contextOffset:r?0:e.left,contextScroll:r?0:this.oldScroll.x,contextDimension:this.$element.width(),oldScroll:this.oldScroll.x,forward:"right",backward:"left",offsetProp:"left"},vertical:{contextOffset:r?0:e.top,contextScroll:r?0:this.oldScroll.y,contextDimension:r?n[m]("viewportHeight"):this.$element.height(),oldScroll:this.oldScroll.y,forward:"down",backward:"up",offsetProp:"top"}};return n.each(t,function(t,e){return n.each(i.waypoints[t],function(t,r){var i,o,l,s,f;i=r.options.offset;l=r.offset;o=n.isWindow(r.element)?0:r.$element.offset()[e.offsetProp];if(n.isFunction(i)){i=i.apply(r.element)}else if(typeof i==="string"){i=parseFloat(i);if(r.options.offset.indexOf("%")>-1){i=Math.ceil(e.contextDimension*i/100)}}r.offset=o-e.contextOffset+e.contextScroll-i;if(r.options.onlyOnScroll&&l!=null||!r.enabled){return}if(l!==null&&l<(s=e.oldScroll)&&s<=r.offset){return r.trigger([e.backward])}else if(l!==null&&l>(f=e.oldScroll)&&f>=r.offset){return r.trigger([e.forward])}else if(l===null&&e.oldScroll>=r.offset){return r.trigger([e.forward])}})})};t.prototype.checkEmpty=function(){if(n.isEmptyObject(this.waypoints.horizontal)&&n.isEmptyObject(this.waypoints.vertical)){this.$element.unbind([p,y].join(" "));return delete c[this.id]}};return t}();l=function(){function t(t,e,r){var i,o;if(r.offset==="bottom-in-view"){r.offset=function(){var t;t=n[m]("viewportHeight");if(!n.isWindow(e.element)){t=e.$element.height()}return t-n(this).outerHeight()}}this.$element=t;this.element=t[0];this.axis=r.horizontal?"horizontal":"vertical";this.callback=r.handler;this.context=e;this.enabled=r.enabled;this.id="waypoints"+v++;this.offset=null;this.options=r;e.waypoints[this.axis][this.id]=this;s[this.axis][this.id]=this;i=(o=this.element[w])!=null?o:[];i.push(this.id);this.element[w]=i}t.prototype.trigger=function(t){if(!this.enabled){return}if(this.callback!=null){this.callback.apply(this.element,t)}if(this.options.triggerOnce){return this.destroy()}};t.prototype.disable=function(){return this.enabled=false};t.prototype.enable=function(){this.context.refresh();return this.enabled=true};t.prototype.destroy=function(){delete s[this.axis][this.id];delete this.context.waypoints[this.axis][this.id];return this.context.checkEmpty()};t.getWaypointsByElement=function(t){var e,r;r=t[w];if(!r){return[]}e=n.extend({},s.horizontal,s.vertical);return n.map(r,function(t){return e[t]})};return t}();d={init:function(t,e){var r;e=n.extend({},n.fn[g].defaults,e);if((r=e.handler)==null){e.handler=t}this.each(function(){var t,r,i,s;t=n(this);i=(s=e.context)!=null?s:n.fn[g].defaults.context;if(!n.isWindow(i)){i=t.closest(i)}i=n(i);r=c[i[0][u]];if(!r){r=new o(i)}return new l(t,r,e)});n[m]("refresh");return this},disable:function(){return d._invoke.call(this,"disable")},enable:function(){return d._invoke.call(this,"enable")},destroy:function(){return d._invoke.call(this,"destroy")},prev:function(t,e){return d._traverse.call(this,t,e,function(t,e,n){if(e>0){return t.push(n[e-1])}})},next:function(t,e){return d._traverse.call(this,t,e,function(t,e,n){if(e<n.length-1){return t.push(n[e+1])}})},_traverse:function(t,e,i){var o,l;if(t==null){t="vertical"}if(e==null){e=r}l=h.aggregate(e);o=[];this.each(function(){var e;e=n.inArray(this,l[t]);return i(o,e,l[t])});return this.pushStack(o)},_invoke:function(t){this.each(function(){var e;e=l.getWaypointsByElement(this);return n.each(e,function(e,n){n[t]();return true})});return this}};n.fn[g]=function(){var t,r;r=arguments[0],t=2<=arguments.length?e.call(arguments,1):[];if(d[r]){return d[r].apply(this,t)}else if(n.isFunction(r)){return d.init.apply(this,arguments)}else if(n.isPlainObject(r)){return d.init.apply(this,[null,r])}else if(!r){return n.error("jQuery Waypoints needs a callback function or handler option.")}else{return n.error("The "+r+" method does not exist in jQuery Waypoints.")}};n.fn[g].defaults={context:r,continuous:true,enabled:true,horizontal:false,offset:0,triggerOnce:false};h={refresh:function(){return n.each(c,function(t,e){return e.refresh()})},viewportHeight:function(){var t;return(t=r.innerHeight)!=null?t:i.height()},aggregate:function(t){var e,r,i;e=s;if(t){e=(i=c[n(t)[0][u]])!=null?i.waypoints:void 0}if(!e){return[]}r={horizontal:[],vertical:[]};n.each(r,function(t,i){n.each(e[t],function(t,e){return i.push(e)});i.sort(function(t,e){return t.offset-e.offset});r[t]=n.map(i,function(t){return t.element});return r[t]=n.unique(r[t])});return r},above:function(t){if(t==null){t=r}return h._filter(t,"vertical",function(t,e){return e.offset<=t.oldScroll.y})},below:function(t){if(t==null){t=r}return h._filter(t,"vertical",function(t,e){return e.offset>t.oldScroll.y})},left:function(t){if(t==null){t=r}return h._filter(t,"horizontal",function(t,e){return e.offset<=t.oldScroll.x})},right:function(t){if(t==null){t=r}return h._filter(t,"horizontal",function(t,e){return e.offset>t.oldScroll.x})},enable:function(){return h._invoke("enable")},disable:function(){return h._invoke("disable")},destroy:function(){return h._invoke("destroy")},extendFn:function(t,e){return d[t]=e},_invoke:function(t){var e;e=n.extend({},s.vertical,s.horizontal);return n.each(e,function(e,n){n[t]();return true})},_filter:function(t,e,r){var i,o;i=c[n(t)[0][u]];if(!i){return[]}o=[];n.each(i.waypoints[e],function(t,e){if(r(i,e)){return o.push(e)}});o.sort(function(t,e){return t.offset-e.offset});return n.map(o,function(t){return t.element})}};n[m]=function(){var t,n;n=arguments[0],t=2<=arguments.length?e.call(arguments,1):[];if(h[n]){return h[n].apply(null,t)}else{return h.aggregate.call(null,n)}};n[m].settings={resizeThrottle:100,scrollThrottle:30};return i.on("load.waypoints",function(){return n[m]("refresh")})})}).call(this);
/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.9
 *
 * Requires: jQuery 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.9',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        },

        getLineHeight: function(elem) {
            return parseInt($(elem)['offsetParent' in $.fn ? 'offsetParent' : 'parent']().css('fontSize'), 10);
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/* perfect-scrollbar v0.6.2 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var ps = require('../main')
      , psInstances = require('../plugin/instances');

  function mountJQuery(jQuery) {
    jQuery.fn.perfectScrollbar = function (settingOrCommand) {
      return this.each(function () {
        if (typeof settingOrCommand === 'object' ||
            typeof settingOrCommand === 'undefined') {
          // If it's an object or none, initialize.
          var settings = settingOrCommand;

          if (!psInstances.get(this)) {
            ps.initialize(this, settings);
          }
        } else {
          // Unless, it may be a command.
          var command = settingOrCommand;

          if (command === 'update') {
            ps.update(this);
          } else if (command === 'destroy') {
            ps.destroy(this);
          }
        }

        return jQuery(this);
      });
    };
  }

  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], mountJQuery);
  } else {
    var jq = window.jQuery ? window.jQuery : window.$;
    if (typeof jq !== 'undefined') {
      mountJQuery(jq);
    }
  }

  module.exports = mountJQuery;

},{"../main":7,"../plugin/instances":18}],2:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  function oldAdd(element, className) {
    var classes = element.className.split(' ');
    if (classes.indexOf(className) < 0) {
      classes.push(className);
    }
    element.className = classes.join(' ');
  }

  function oldRemove(element, className) {
    var classes = element.className.split(' ');
    var idx = classes.indexOf(className);
    if (idx >= 0) {
      classes.splice(idx, 1);
    }
    element.className = classes.join(' ');
  }

  exports.add = function (element, className) {
    if (element.classList) {
      element.classList.add(className);
    } else {
      oldAdd(element, className);
    }
  };

  exports.remove = function (element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else {
      oldRemove(element, className);
    }
  };

  exports.list = function (element) {
    if (element.classList) {
      return element.classList;
    } else {
      return element.className.split(' ');
    }
  };

},{}],3:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  exports.e = function (tagName, className) {
    var element = document.createElement(tagName);
    element.className = className;
    return element;
  };

  exports.appendTo = function (child, parent) {
    parent.appendChild(child);
    return child;
  };

  function cssGet(element, styleName) {
    return window.getComputedStyle(element)[styleName];
  }

  function cssSet(element, styleName, styleValue) {
    if (typeof styleValue === 'number') {
      styleValue = styleValue.toString() + 'px';
    }
    element.style[styleName] = styleValue;
    return element;
  }

  function cssMultiSet(element, obj) {
    for (var key in obj) {
      var val = obj[key];
      if (typeof val === 'number') {
        val = val.toString() + 'px';
      }
      element.style[key] = val;
    }
    return element;
  }

  exports.css = function (element, styleNameOrObject, styleValue) {
    if (typeof styleNameOrObject === 'object') {
      // multiple set with object
      return cssMultiSet(element, styleNameOrObject);
    } else {
      if (typeof styleValue === 'undefined') {
        return cssGet(element, styleNameOrObject);
      } else {
        return cssSet(element, styleNameOrObject, styleValue);
      }
    }
  };

  exports.matches = function (element, query) {
    if (typeof element.matches !== 'undefined') {
      return element.matches(query);
    } else {
      if (typeof element.matchesSelector !== 'undefined') {
        return element.matchesSelector(query);
      } else if (typeof element.webkitMatchesSelector !== 'undefined') {
        return element.webkitMatchesSelector(query);
      } else if (typeof element.mozMatchesSelector !== 'undefined') {
        return element.mozMatchesSelector(query);
      } else if (typeof element.msMatchesSelector !== 'undefined') {
        return element.msMatchesSelector(query);
      }
    }
  };

  exports.remove = function (element) {
    if (typeof element.remove !== 'undefined') {
      element.remove();
    } else {
      if (element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }
  };

},{}],4:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var EventElement = function (element) {
    this.element = element;
    this.events = {};
  };

  EventElement.prototype.bind = function (eventName, handler) {
    if (typeof this.events[eventName] === 'undefined') {
      this.events[eventName] = [];
    }
    this.events[eventName].push(handler);
    this.element.addEventListener(eventName, handler, false);
  };

  EventElement.prototype.unbind = function (eventName, handler) {
    var isHandlerProvided = (typeof handler !== 'undefined');
    this.events[eventName] = this.events[eventName].filter(function (hdlr) {
      if (isHandlerProvided && hdlr !== handler) {
        return true;
      }
      this.element.removeEventListener(eventName, hdlr, false);
      return false;
    }, this);
  };

  EventElement.prototype.unbindAll = function () {
    for (var name in this.events) {
      this.unbind(name);
    }
  };

  var EventManager = function () {
    this.eventElements = [];
  };

  EventManager.prototype.eventElement = function (element) {
    var ee = this.eventElements.filter(function (eventElement) {
      return eventElement.element === element;
    })[0];
    if (typeof ee === 'undefined') {
      ee = new EventElement(element);
      this.eventElements.push(ee);
    }
    return ee;
  };

  EventManager.prototype.bind = function (element, eventName, handler) {
    this.eventElement(element).bind(eventName, handler);
  };

  EventManager.prototype.unbind = function (element, eventName, handler) {
    this.eventElement(element).unbind(eventName, handler);
  };

  EventManager.prototype.unbindAll = function () {
    for (var i = 0; i < this.eventElements.length; i++) {
      this.eventElements[i].unbindAll();
    }
  };

  EventManager.prototype.once = function (element, eventName, handler) {
    var ee = this.eventElement(element);
    var onceHandler = function (e) {
      ee.unbind(eventName, onceHandler);
      handler(e);
    };
    ee.bind(eventName, onceHandler);
  };

  module.exports = EventManager;

},{}],5:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  module.exports = (function () {
    function s4() {
      return Math.floor((1 + Math.random()) * 0x10000)
          .toString(16)
          .substring(1);
    }
    return function () {
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
          s4() + '-' + s4() + s4() + s4();
    };
  })();

},{}],6:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var cls = require('./class')
      , d = require('./dom');

  exports.toInt = function (x) {
    if (typeof x === 'string') {
      return parseInt(x, 10);
    } else {
      return ~~x;
    }
  };

  exports.clone = function (obj) {
    if (obj === null) {
      return null;
    } else if (typeof obj === 'object') {
      var result = {};
      for (var key in obj) {
        result[key] = this.clone(obj[key]);
      }
      return result;
    } else {
      return obj;
    }
  };

  exports.extend = function (original, source) {
    var result = this.clone(original);
    for (var key in source) {
      result[key] = this.clone(source[key]);
    }
    return result;
  };

  exports.isEditable = function (el) {
    return d.matches(el, "input,[contenteditable]") ||
        d.matches(el, "select,[contenteditable]") ||
        d.matches(el, "textarea,[contenteditable]") ||
        d.matches(el, "button,[contenteditable]");
  };

  exports.removePsClasses = function (element) {
    var clsList = cls.list(element);
    for (var i = 0; i < clsList.length; i++) {
      var className = clsList[i];
      if (className.indexOf('ps-') === 0) {
        cls.remove(element, className);
      }
    }
  };

  exports.outerWidth = function (element) {
    return this.toInt(d.css(element, 'width')) +
        this.toInt(d.css(element, 'paddingLeft')) +
        this.toInt(d.css(element, 'paddingRight')) +
        this.toInt(d.css(element, 'borderLeftWidth')) +
        this.toInt(d.css(element, 'borderRightWidth'));
  };

  exports.startScrolling = function (element, axis) {
    cls.add(element, 'ps-in-scrolling');
    if (typeof axis !== 'undefined') {
      cls.add(element, 'ps-' + axis);
    } else {
      cls.add(element, 'ps-x');
      cls.add(element, 'ps-y');
    }
  };

  exports.stopScrolling = function (element, axis) {
    cls.remove(element, 'ps-in-scrolling');
    if (typeof axis !== 'undefined') {
      cls.remove(element, 'ps-' + axis);
    } else {
      cls.remove(element, 'ps-x');
      cls.remove(element, 'ps-y');
    }
  };

  exports.env = {
    isWebKit: 'WebkitAppearance' in document.documentElement.style,
    supportsTouch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),
    supportsIePointer: window.navigator.msMaxTouchPoints !== null
  };

},{"./class":2,"./dom":3}],7:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var destroy = require('./plugin/destroy')
      , initialize = require('./plugin/initialize')
      , update = require('./plugin/update');

  module.exports = {
    initialize: initialize,
    update: update,
    destroy: destroy
  };

},{"./plugin/destroy":9,"./plugin/initialize":17,"./plugin/update":20}],8:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  module.exports = {
    wheelSpeed: 1,
    wheelPropagation: false,
    swipePropagation: true,
    minScrollbarLength: null,
    maxScrollbarLength: null,
    useBothWheelAxes: false,
    useKeyboard: true,
    suppressScrollX: false,
    suppressScrollY: false,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0
  };

},{}],9:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var d = require('../lib/dom')
      , h = require('../lib/helper')
      , instances = require('./instances');

  module.exports = function (element) {
    var i = instances.get(element);

    i.event.unbindAll();
    d.remove(i.scrollbarX);
    d.remove(i.scrollbarY);
    d.remove(i.scrollbarXRail);
    d.remove(i.scrollbarYRail);
    h.removePsClasses(element);

    instances.remove(element);
  };

},{"../lib/dom":3,"../lib/helper":6,"./instances":18}],10:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var h = require('../../lib/helper')
      , instances = require('../instances')
      , updateGeometry = require('../update-geometry');

  function bindClickRailHandler(element, i) {
    function pageOffset(el) {
      return el.getBoundingClientRect();
    }
    var stopPropagation = window.Event.prototype.stopPropagation.bind;

    i.event.bind(i.scrollbarY, 'click', stopPropagation);
    i.event.bind(i.scrollbarYRail, 'click', function (e) {
      var halfOfScrollbarLength = h.toInt(i.scrollbarYHeight / 2);
      var positionTop = e.pageY - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength;
      var maxPositionTop = i.containerHeight - i.scrollbarYHeight;
      var positionRatio = positionTop / maxPositionTop;

      if (positionRatio < 0) {
        positionRatio = 0;
      } else if (positionRatio > 1) {
        positionRatio = 1;
      }

      element.scrollTop = (i.contentHeight - i.containerHeight) * positionRatio;
      updateGeometry(element);
    });

    i.event.bind(i.scrollbarX, 'click', stopPropagation);
    i.event.bind(i.scrollbarXRail, 'click', function (e) {
      var halfOfScrollbarLength = h.toInt(i.scrollbarXWidth / 2);
      var positionLeft = e.pageX - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength;
      console.log(e.pageX, i.scrollbarXRail.offsetLeft);
      var maxPositionLeft = i.containerWidth - i.scrollbarXWidth;
      var positionRatio = positionLeft / maxPositionLeft;

      if (positionRatio < 0) {
        positionRatio = 0;
      } else if (positionRatio > 1) {
        positionRatio = 1;
      }

      element.scrollLeft = (i.contentWidth - i.containerWidth) * positionRatio;
      updateGeometry(element);
    });
  }

  module.exports = function (element) {
    var i = instances.get(element);
    bindClickRailHandler(element, i);
  };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],11:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var d = require('../../lib/dom')
      , h = require('../../lib/helper')
      , instances = require('../instances')
      , updateGeometry = require('../update-geometry');

  function bindMouseScrollXHandler(element, i) {
    var currentLeft = null;
    var currentPageX = null;

    function updateScrollLeft(deltaX) {
      var newLeft = currentLeft + deltaX;
      var maxLeft = i.containerWidth - i.scrollbarXWidth;

      if (newLeft < 0) {
        i.scrollbarXLeft = 0;
      } else if (newLeft > maxLeft) {
        i.scrollbarXLeft = maxLeft;
      } else {
        i.scrollbarXLeft = newLeft;
      }

      var scrollLeft = h.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - i.scrollbarXWidth));
      element.scrollLeft = scrollLeft;
    }

    var mouseMoveHandler = function (e) {
      updateScrollLeft(e.pageX - currentPageX);
      updateGeometry(element);
      e.stopPropagation();
      e.preventDefault();
    };

    var mouseUpHandler = function () {
      h.stopScrolling(element, 'x');
      i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    };

    i.event.bind(i.scrollbarX, 'mousedown', function (e) {
      currentPageX = e.pageX;
      currentLeft = h.toInt(d.css(i.scrollbarX, 'left'));
      h.startScrolling(element, 'x');

      i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
      i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

      e.stopPropagation();
      e.preventDefault();
    });
  }

  function bindMouseScrollYHandler(element, i) {
    var currentTop = null;
    var currentPageY = null;

    function updateScrollTop(deltaY) {
      var newTop = currentTop + deltaY;
      var maxTop = i.containerHeight - i.scrollbarYHeight;

      if (newTop < 0) {
        i.scrollbarYTop = 0;
      } else if (newTop > maxTop) {
        i.scrollbarYTop = maxTop;
      } else {
        i.scrollbarYTop = newTop;
      }

      var scrollTop = h.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - i.scrollbarYHeight));
      element.scrollTop = scrollTop;
    }

    var mouseMoveHandler = function (e) {
      updateScrollTop(e.pageY - currentPageY);
      updateGeometry(element);
      e.stopPropagation();
      e.preventDefault();
    };

    var mouseUpHandler = function () {
      h.stopScrolling(element, 'y');
      i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    };

    i.event.bind(i.scrollbarY, 'mousedown', function (e) {
      currentPageY = e.pageY;
      currentTop = h.toInt(d.css(i.scrollbarY, 'top'));
      h.startScrolling(element, 'y');

      i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
      i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

      e.stopPropagation();
      e.preventDefault();
    });
  }

  module.exports = function (element) {
    var i = instances.get(element);
    bindMouseScrollXHandler(element, i);
    bindMouseScrollYHandler(element, i);
  };

},{"../../lib/dom":3,"../../lib/helper":6,"../instances":18,"../update-geometry":19}],12:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var h = require('../../lib/helper')
      , instances = require('../instances')
      , updateGeometry = require('../update-geometry');

  function bindKeyboardHandler(element, i) {
    var hovered = false;
    i.event.bind(element, 'mouseenter', function () {
      hovered = true;
    });
    i.event.bind(element, 'mouseleave', function () {
      hovered = false;
    });

    var shouldPrevent = false;
    function shouldPreventDefault(deltaX, deltaY) {
      var scrollTop = element.scrollTop;
      if (deltaX === 0) {
        if (!i.scrollbarYActive) {
          return false;
        }
        if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
          return !i.settings.wheelPropagation;
        }
      }

      var scrollLeft = element.scrollLeft;
      if (deltaY === 0) {
        if (!i.scrollbarXActive) {
          return false;
        }
        if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
          return !i.settings.wheelPropagation;
        }
      }
      return true;
    }

    i.event.bind(i.ownerDocument, 'keydown', function (e) {
      if (e.isDefaultPrevented && e.isDefaultPrevented()) {
        return;
      }

      if (!hovered) {
        return;
      }

      var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
      if (activeElement) {
        // go deeper if element is a webcomponent
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
        if (h.isEditable(activeElement)) {
          return;
        }
      }

      var deltaX = 0;
      var deltaY = 0;

      switch (e.which) {
        case 37: // left
          deltaX = -30;
          break;
        case 38: // up
          deltaY = 30;
          break;
        case 39: // right
          deltaX = 30;
          break;
        case 40: // down
          deltaY = -30;
          break;
        case 33: // page up
          deltaY = 90;
          break;
        case 32: // space bar
        case 34: // page down
          deltaY = -90;
          break;
        case 35: // end
          if (e.ctrlKey) {
            deltaY = -i.contentHeight;
          } else {
            deltaY = -i.containerHeight;
          }
          break;
        case 36: // home
          if (e.ctrlKey) {
            deltaY = element.scrollTop;
          } else {
            deltaY = i.containerHeight;
          }
          break;
        default:
          return;
      }

      element.scrollTop = element.scrollTop - deltaY;
      element.scrollLeft = element.scrollLeft + deltaX;
      updateGeometry(element);

      shouldPrevent = shouldPreventDefault(deltaX, deltaY);
      if (shouldPrevent) {
        e.preventDefault();
      }
    });
  }

  module.exports = function (element) {
    var i = instances.get(element);
    bindKeyboardHandler(element, i);
  };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],13:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var h = require('../../lib/helper')
      , instances = require('../instances')
      , updateGeometry = require('../update-geometry');

  function bindMouseWheelHandler(element, i) {
    var shouldPrevent = false;

    function shouldPreventDefault(deltaX, deltaY) {
      var scrollTop = element.scrollTop;
      if (deltaX === 0) {
        if (!i.scrollbarYActive) {
          return false;
        }
        if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
          return !i.settings.wheelPropagation;
        }
      }

      var scrollLeft = element.scrollLeft;
      if (deltaY === 0) {
        if (!i.scrollbarXActive) {
          return false;
        }
        if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
          return !i.settings.wheelPropagation;
        }
      }
      return true;
    }

    function getDeltaFromEvent(e) {
      var deltaX = e.deltaX;
      var deltaY = -1 * e.deltaY;

      if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
        // OS X Safari
        deltaX = -1 * e.wheelDeltaX / 6;
        deltaY = e.wheelDeltaY / 6;
      }

      if (e.deltaMode && e.deltaMode === 1) {
        // Firefox in deltaMode 1: Line scrolling
        deltaX *= 10;
        deltaY *= 10;
      }

      if (deltaX !== deltaX && deltaY !== deltaY/* NaN checks */) {
        // IE in some mouse drivers
        deltaX = 0;
        deltaY = e.wheelDelta;
      }

      return [deltaX, deltaY];
    }

    function shouldBeConsumedByTextarea(deltaX, deltaY) {
      var hoveredTextarea = element.querySelector('textarea:hover');
      if (hoveredTextarea) {
        var maxScrollTop = hoveredTextarea.scrollHeight - hoveredTextarea.clientHeight;
        if (maxScrollTop > 0) {
          if (!(hoveredTextarea.scrollTop === 0 && deltaY > 0) &&
              !(hoveredTextarea.scrollTop === maxScrollTop && deltaY < 0)) {
            return true;
          }
        }
        var maxScrollLeft = hoveredTextarea.scrollLeft - hoveredTextarea.clientWidth;
        if (maxScrollLeft > 0) {
          if (!(hoveredTextarea.scrollLeft === 0 && deltaX < 0) &&
              !(hoveredTextarea.scrollLeft === maxScrollLeft && deltaX > 0)) {
            return true;
          }
        }
      }
      return false;
    }

    function mousewheelHandler(e) {
      // FIXME: this is a quick fix for the select problem in FF and IE.
      // If there comes an effective way to deal with the problem,
      // this lines should be removed.
      if (!h.env.isWebKit && element.querySelector('select:focus')) {
        return;
      }

      var delta = getDeltaFromEvent(e);

      var deltaX = delta[0];
      var deltaY = delta[1];

      if (shouldBeConsumedByTextarea(deltaX, deltaY)) {
        return;
      }

      shouldPrevent = false;
      if (!i.settings.useBothWheelAxes) {
        // deltaX will only be used for horizontal scrolling and deltaY will
        // only be used for vertical scrolling - this is the default
        element.scrollTop = element.scrollTop - (deltaY * i.settings.wheelSpeed);
        element.scrollLeft = element.scrollLeft + (deltaX * i.settings.wheelSpeed);
      } else if (i.scrollbarYActive && !i.scrollbarXActive) {
        // only vertical scrollbar is active and useBothWheelAxes option is
        // active, so let's scroll vertical bar using both mouse wheel axes
        if (deltaY) {
          element.scrollTop = element.scrollTop - (deltaY * i.settings.wheelSpeed);
        } else {
          element.scrollTop = element.scrollTop + (deltaX * i.settings.wheelSpeed);
        }
        shouldPrevent = true;
      } else if (i.scrollbarXActive && !i.scrollbarYActive) {
        // useBothWheelAxes and only horizontal bar is active, so use both
        // wheel axes for horizontal bar
        if (deltaX) {
          element.scrollLeft = element.scrollLeft + (deltaX * i.settings.wheelSpeed);
        } else {
          element.scrollLeft = element.scrollLeft - (deltaY * i.settings.wheelSpeed);
        }
        shouldPrevent = true;
      }

      updateGeometry(element);

      shouldPrevent = (shouldPrevent || shouldPreventDefault(deltaX, deltaY));
      if (shouldPrevent) {
        e.stopPropagation();
        e.preventDefault();
      }
    }

    if (typeof window.onwheel !== "undefined") {
      i.event.bind(element, 'wheel', mousewheelHandler);
    } else if (typeof window.onmousewheel !== "undefined") {
      i.event.bind(element, 'mousewheel', mousewheelHandler);
    }
  }

  module.exports = function (element) {
    var i = instances.get(element);
    bindMouseWheelHandler(element, i);
  };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],14:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var instances = require('../instances')
      , updateGeometry = require('../update-geometry');

  function bindNativeScrollHandler(element, i) {
    i.event.bind(element, 'scroll', function () {
      updateGeometry(element);
    });
  }

  module.exports = function (element) {
    var i = instances.get(element);
    bindNativeScrollHandler(element, i);
  };

},{"../instances":18,"../update-geometry":19}],15:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var h = require('../../lib/helper')
      , instances = require('../instances')
      , updateGeometry = require('../update-geometry');

  function bindSelectionHandler(element, i) {
    function getRangeNode() {
      var selection = window.getSelection ? window.getSelection() :
          document.getSelection ? document.getSelection() : '';
      if (selection.toString().length === 0) {
        return null;
      } else {
        return selection.getRangeAt(0).commonAncestorContainer;
      }
    }

    var scrollingLoop = null;
    var scrollDiff = {top: 0, left: 0};
    function startScrolling() {
      if (!scrollingLoop) {
        scrollingLoop = setInterval(function () {
          if (!instances.get(element)) {
            clearInterval(scrollingLoop);
            return;
          }

          element.scrollTop = element.scrollTop + scrollDiff.top;
          element.scrollLeft = element.scrollLeft + scrollDiff.left;
          updateGeometry(element);
        }, 50); // every .1 sec
      }
    }
    function stopScrolling() {
      if (scrollingLoop) {
        clearInterval(scrollingLoop);
        scrollingLoop = null;
      }
      h.stopScrolling(element);
    }

    var isSelected = false;
    i.event.bind(i.ownerDocument, 'selectionchange', function () {
      if (element.contains(getRangeNode())) {
        isSelected = true;
      } else {
        isSelected = false;
        stopScrolling();
      }
    });
    i.event.bind(window, 'mouseup', function () {
      if (isSelected) {
        isSelected = false;
        stopScrolling();
      }
    });

    i.event.bind(window, 'mousemove', function (e) {
      if (isSelected) {
        var mousePosition = {x: e.pageX, y: e.pageY};
        var containerGeometry = {
          left: element.offsetLeft,
          right: element.offsetLeft + element.offsetWidth,
          top: element.offsetTop,
          bottom: element.offsetTop + element.offsetHeight
        };

        if (mousePosition.x < containerGeometry.left + 3) {
          scrollDiff.left = -5;
          h.startScrolling(element, 'x');
        } else if (mousePosition.x > containerGeometry.right - 3) {
          scrollDiff.left = 5;
          h.startScrolling(element, 'x');
        } else {
          scrollDiff.left = 0;
        }

        if (mousePosition.y < containerGeometry.top + 3) {
          if (containerGeometry.top + 3 - mousePosition.y < 5) {
            scrollDiff.top = -5;
          } else {
            scrollDiff.top = -20;
          }
          h.startScrolling(element, 'y');
        } else if (mousePosition.y > containerGeometry.bottom - 3) {
          if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
            scrollDiff.top = 5;
          } else {
            scrollDiff.top = 20;
          }
          h.startScrolling(element, 'y');
        } else {
          scrollDiff.top = 0;
        }

        if (scrollDiff.top === 0 && scrollDiff.left === 0) {
          stopScrolling();
        } else {
          startScrolling();
        }
      }
    });
  }

  module.exports = function (element) {
    var i = instances.get(element);
    bindSelectionHandler(element, i);
  };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],16:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var instances = require('../instances')
      , updateGeometry = require('../update-geometry');

  function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
    function shouldPreventDefault(deltaX, deltaY) {
      var scrollTop = element.scrollTop;
      var scrollLeft = element.scrollLeft;
      var magnitudeX = Math.abs(deltaX);
      var magnitudeY = Math.abs(deltaY);

      if (magnitudeY > magnitudeX) {
        // user is perhaps trying to swipe up/down the page

        if (((deltaY < 0) && (scrollTop === i.contentHeight - i.containerHeight)) ||
            ((deltaY > 0) && (scrollTop === 0))) {
          return !i.settings.swipePropagation;
        }
      } else if (magnitudeX > magnitudeY) {
        // user is perhaps trying to swipe left/right across the page

        if (((deltaX < 0) && (scrollLeft === i.contentWidth - i.containerWidth)) ||
            ((deltaX > 0) && (scrollLeft === 0))) {
          return !i.settings.swipePropagation;
        }
      }

      return true;
    }

    function applyTouchMove(differenceX, differenceY) {
      element.scrollTop = element.scrollTop - differenceY;
      element.scrollLeft = element.scrollLeft - differenceX;

      updateGeometry(element);
    }

    var startOffset = {};
    var startTime = 0;
    var speed = {};
    var easingLoop = null;
    var inGlobalTouch = false;
    var inLocalTouch = false;

    function globalTouchStart() {
      inGlobalTouch = true;
    }
    function globalTouchEnd() {
      inGlobalTouch = false;
    }

    function getTouch(e) {
      if (e.targetTouches) {
        return e.targetTouches[0];
      } else {
        // Maybe IE pointer
        return e;
      }
    }
    function shouldHandle(e) {
      if (e.targetTouches && e.targetTouches.length === 1) {
        return true;
      }
      if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
        return true;
      }
      return false;
    }
    function touchStart(e) {
      if (shouldHandle(e)) {
        inLocalTouch = true;

        var touch = getTouch(e);

        startOffset.pageX = touch.pageX;
        startOffset.pageY = touch.pageY;

        startTime = (new Date()).getTime();

        if (easingLoop !== null) {
          clearInterval(easingLoop);
        }

        e.stopPropagation();
      }
    }
    function touchMove(e) {
      if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
        var touch = getTouch(e);

        var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

        var differenceX = currentOffset.pageX - startOffset.pageX;
        var differenceY = currentOffset.pageY - startOffset.pageY;

        applyTouchMove(differenceX, differenceY);
        startOffset = currentOffset;

        var currentTime = (new Date()).getTime();

        var timeGap = currentTime - startTime;
        if (timeGap > 0) {
          speed.x = differenceX / timeGap;
          speed.y = differenceY / timeGap;
          startTime = currentTime;
        }

        if (shouldPreventDefault(differenceX, differenceY)) {
          e.stopPropagation();
          e.preventDefault();
        }
      }
    }
    function touchEnd() {
      if (!inGlobalTouch && inLocalTouch) {
        inLocalTouch = false;

        clearInterval(easingLoop);
        easingLoop = setInterval(function () {
          if (!instances.get(element)) {
            clearInterval(easingLoop);
            return;
          }

          if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
            clearInterval(easingLoop);
            return;
          }

          applyTouchMove(speed.x * 30, speed.y * 30);

          speed.x *= 0.8;
          speed.y *= 0.8;
        }, 10);
      }
    }

    if (supportsTouch) {
      i.event.bind(window, 'touchstart', globalTouchStart);
      i.event.bind(window, 'touchend', globalTouchEnd);
      i.event.bind(element, 'touchstart', touchStart);
      i.event.bind(element, 'touchmove', touchMove);
      i.event.bind(element, 'touchend', touchEnd);
    }

    if (supportsIePointer) {
      if (window.PointerEvent) {
        i.event.bind(window, 'pointerdown', globalTouchStart);
        i.event.bind(window, 'pointerup', globalTouchEnd);
        i.event.bind(element, 'pointerdown', touchStart);
        i.event.bind(element, 'pointermove', touchMove);
        i.event.bind(element, 'pointerup', touchEnd);
      } else if (window.MSPointerEvent) {
        i.event.bind(window, 'MSPointerDown', globalTouchStart);
        i.event.bind(window, 'MSPointerUp', globalTouchEnd);
        i.event.bind(element, 'MSPointerDown', touchStart);
        i.event.bind(element, 'MSPointerMove', touchMove);
        i.event.bind(element, 'MSPointerUp', touchEnd);
      }
    }
  }

  module.exports = function (element, supportsTouch, supportsIePointer) {
    var i = instances.get(element);
    bindTouchHandler(element, i, supportsTouch, supportsIePointer);
  };

},{"../instances":18,"../update-geometry":19}],17:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var cls = require('../lib/class')
      , h = require('../lib/helper')
      , instances = require('./instances')
      , updateGeometry = require('./update-geometry');

// Handlers
  var clickRailHandler = require('./handler/click-rail')
      , dragScrollbarHandler = require('./handler/drag-scrollbar')
      , keyboardHandler = require('./handler/keyboard')
      , mouseWheelHandler = require('./handler/mouse-wheel')
      , nativeScrollHandler = require('./handler/native-scroll')
      , selectionHandler = require('./handler/selection')
      , touchHandler = require('./handler/touch');

  module.exports = function (element, userSettings) {
    userSettings = typeof userSettings === 'object' ? userSettings : {};

    cls.add(element, 'ps-container');

    // Create a plugin instance.
    var i = instances.add(element);

    i.settings = h.extend(i.settings, userSettings);

    clickRailHandler(element);
    dragScrollbarHandler(element);
    mouseWheelHandler(element);
    nativeScrollHandler(element);
    selectionHandler(element);

    if (h.env.supportsTouch || h.env.supportsIePointer) {
      touchHandler(element, h.env.supportsTouch, h.env.supportsIePointer);
    }
    if (i.settings.useKeyboard) {
      keyboardHandler(element);
    }

    updateGeometry(element);
  };

},{"../lib/class":2,"../lib/helper":6,"./handler/click-rail":10,"./handler/drag-scrollbar":11,"./handler/keyboard":12,"./handler/mouse-wheel":13,"./handler/native-scroll":14,"./handler/selection":15,"./handler/touch":16,"./instances":18,"./update-geometry":19}],18:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var d = require('../lib/dom')
      , defaultSettings = require('./default-setting')
      , EventManager = require('../lib/event-manager')
      , guid = require('../lib/guid')
      , h = require('../lib/helper');

  var instances = {};

  function Instance(element) {
    var i = this;

    i.settings = h.clone(defaultSettings);
    i.containerWidth = null;
    i.containerHeight = null;
    i.contentWidth = null;
    i.contentHeight = null;

    i.isRtl = d.css(element, 'direction') === "rtl";
    i.event = new EventManager();
    i.ownerDocument = element.ownerDocument || document;

    i.scrollbarXRail = d.appendTo(d.e('div', 'ps-scrollbar-x-rail'), element);
    i.scrollbarX = d.appendTo(d.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
    i.scrollbarXActive = null;
    i.scrollbarXWidth = null;
    i.scrollbarXLeft = null;
    i.scrollbarXBottom = h.toInt(d.css(i.scrollbarXRail, 'bottom'));
    i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
    i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : h.toInt(d.css(i.scrollbarXRail, 'top'));
    i.railBorderXWidth = h.toInt(d.css(i.scrollbarXRail, 'borderLeftWidth')) + h.toInt(d.css(i.scrollbarXRail, 'borderRightWidth'));
    i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
    i.railXWidth = null;

    i.scrollbarYRail = d.appendTo(d.e('div', 'ps-scrollbar-y-rail'), element);
    i.scrollbarY = d.appendTo(d.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
    i.scrollbarYActive = null;
    i.scrollbarYHeight = null;
    i.scrollbarYTop = null;
    i.scrollbarYRight = h.toInt(d.css(i.scrollbarYRail, 'right'));
    i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
    i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : h.toInt(d.css(i.scrollbarYRail, 'left'));
    i.scrollbarYOuterWidth = i.isRtl ? h.outerWidth(i.scrollbarY) : null;
    i.railBorderYWidth = h.toInt(d.css(i.scrollbarYRail, 'borderTopWidth')) + h.toInt(d.css(i.scrollbarYRail, 'borderBottomWidth'));
    i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));
    i.railYHeight = null;
  }

  function getId(element) {
    if (typeof element.dataset === 'undefined') {
      return element.getAttribute('data-ps-id');
    } else {
      return element.dataset.psId;
    }
  }

  function setId(element, id) {
    if (typeof element.dataset === 'undefined') {
      element.setAttribute('data-ps-id', id);
    } else {
      element.dataset.psId = id;
    }
  }

  function removeId(element) {
    if (typeof element.dataset === 'undefined') {
      element.removeAttribute('data-ps-id');
    } else {
      delete element.dataset.psId;
    }
  }

  exports.add = function (element) {
    var newId = guid();
    setId(element, newId);
    instances[newId] = new Instance(element);
    return instances[newId];
  };

  exports.remove = function (element) {
    delete instances[getId(element)];
    removeId(element);
  };

  exports.get = function (element) {
    return instances[getId(element)];
  };

},{"../lib/dom":3,"../lib/event-manager":4,"../lib/guid":5,"../lib/helper":6,"./default-setting":8}],19:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var cls = require('../lib/class')
      , d = require('../lib/dom')
      , h = require('../lib/helper')
      , instances = require('./instances');

  function getThumbSize(i, thumbSize) {
    if (i.settings.minScrollbarLength) {
      thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
    }
    if (i.settings.maxScrollbarLength) {
      thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
    }
    return thumbSize;
  }

  function updateCss(element, i) {
    var xRailOffset = {width: i.railXWidth};
    if (i.isRtl) {
      xRailOffset.left = element.scrollLeft + i.containerWidth - i.contentWidth;
    } else {
      xRailOffset.left = element.scrollLeft;
    }
    if (i.isScrollbarXUsingBottom) {
      xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
    } else {
      xRailOffset.top = i.scrollbarXTop + element.scrollTop;
    }
    d.css(i.scrollbarXRail, xRailOffset);

    var yRailOffset = {top: element.scrollTop, height: i.railYHeight};
    if (i.isScrollbarYUsingRight) {
      if (i.isRtl) {
        yRailOffset.right = i.contentWidth - element.scrollLeft - i.scrollbarYRight - i.scrollbarYOuterWidth;
      } else {
        yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
      }
    } else {
      if (i.isRtl) {
        yRailOffset.left = element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
      } else {
        yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
      }
    }
    d.css(i.scrollbarYRail, yRailOffset);

    d.css(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth});
    d.css(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
  }

  module.exports = function (element) {
    var i = instances.get(element);

    i.containerWidth = element.clientWidth;
    i.containerHeight = element.clientHeight;
    i.contentWidth = element.scrollWidth;
    i.contentHeight = element.scrollHeight;

    if (!element.contains(i.scrollbarXRail)) {
      d.appendTo(i.scrollbarXRail, element);
    }
    if (!element.contains(i.scrollbarYRail)) {
      d.appendTo(i.scrollbarYRail, element);
    }

    if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
      i.scrollbarXActive = true;
      i.railXWidth = i.containerWidth - i.railXMarginWidth;
      i.scrollbarXWidth = getThumbSize(i, h.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
      i.scrollbarXLeft = h.toInt(element.scrollLeft * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
    } else {
      i.scrollbarXActive = false;
      i.scrollbarXWidth = 0;
      i.scrollbarXLeft = 0;
      element.scrollLeft = 0;
    }

    if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
      i.scrollbarYActive = true;
      i.railYHeight = i.containerHeight - i.railYMarginHeight;
      i.scrollbarYHeight = getThumbSize(i, h.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
      i.scrollbarYTop = h.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
    } else {
      i.scrollbarYActive = false;
      i.scrollbarYHeight = 0;
      i.scrollbarYTop = 0;
      element.scrollTop = 0;
    }

    if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
      i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
    }
    if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
      i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
    }

    updateCss(element, i);

    cls[i.scrollbarXActive ? 'add' : 'remove'](element, 'ps-active-x');
    cls[i.scrollbarYActive ? 'add' : 'remove'](element, 'ps-active-y');
  };

},{"../lib/class":2,"../lib/dom":3,"../lib/helper":6,"./instances":18}],20:[function(require,module,exports){
  /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
   * Licensed under the MIT License
   */
  'use strict';

  var d = require('../lib/dom')
      , instances = require('./instances')
      , updateGeometry = require('./update-geometry');

  module.exports = function (element) {
    var i = instances.get(element);

    // Hide scrollbars not to affect scrollWidth and scrollHeight
    d.css(i.scrollbarXRail, 'display', 'none');
    d.css(i.scrollbarYRail, 'display', 'none');

    updateGeometry(element);

    d.css(i.scrollbarXRail, 'display', 'block');
    d.css(i.scrollbarYRail, 'display', 'block');
  };

},{"../lib/dom":3,"./instances":18,"./update-geometry":19}]},{},[1]);

/*
 * File: jquery.adobe.autocomplete.js
 * Version: 1.4
 * Author: Kevin Scally <kscally@adobe.com>
 * Description:  This is an extension to the jQuery-UI autocomplete plug-in that helps facilitate Adobe related functionality.
 * Documenation: 
 */

(function($) {

	if (!$) return; 


	var defaults = {
		autocomplete : true,
		sayt : false,
		account: "",
		inputElement: "",
		inputFormElement: "",
		delay: 150,
		minLength: 3,
		maxResults: 10,
		browserAutocomplete: false,
		submitOnSelect: true,
		queryCaseSensitive: false,
		startsWith: false,
		highlightWords : true,		
		highlightWordsBegin : false,
		zindex : 0,
		header : "",
		footer : ""
	}



	$.fn.AdobeAutocomplete = function(s)
	{

		s = $.extend(true,defaults,s);

		
		// Extend Autocomplete to allow for highlighting words
		$.extend($.ui.autocomplete.prototype, {
		
			highlightMatches: function(q,t)
			{
				if (s.highlightWords || s.highlightWordsBegin)
				{
					var st = (s.highlightWordsBegin) ? "^" : "";
					var re = new RegExp("(" + st + q + ")","i");
					t = t.replace(re,"<b>" + "$1" + "</b>");
				}		
				return t;
			
			}
		
		});
		
		// Assign Autocomplete Callback functions
		var _ops = {
		
			getAutocompleteRequest : function(s,query)
			{
				var g_staged = ($("#sp_staged") ? $("sp_staged").val() : 0);
				var protocol = (document.location.protocol == "https:" ? "https:" : "http:");
				var postfix = (g_staged ? "-stage/" : "/");
				var acct = s.account.split("");
				var spid = "";
				var j = 0;
				for (var i = 0; i < acct.length ; i++)
				{
					if (i >= 2)
					{
						j++;
						if (j == 2) 
						{
							j = 0;
							spid += (i != (acct.length - 1)) ? acct[i] + "/" : acct[i];
						}
						else
						{
							spid += acct[i];
						}
					}
					else
					{
							spid += acct[i];
					}
		
				}
				return protocol + "//content.atomz.com/autocomplete/" + spid + postfix + "?query=" + query + "&max_results=" + s.maxResults + "&callback=?";
			
			},
	
			source: function(request,response)
			{
				if (!request.term) request.term = "";
				var req = this.options.getAutocompleteRequest(s,request.term);

				if (!s.browserAutocomplete)
				{
					$(s.inputFormElement).attr("autocomplete","off");
				}
	
				if (request.term)
				{

					var o = this;

					$.getJSON(req,function(data,txt,req) {  
		
						var matcher = null;
						var matchcase = (s && s.queryCaseSensitive) ? "" : "i";
						var res = 0;
						var max = (s.maxResults) ? s.maxResults : 10000;
			
						if (s.startsWith)
						{
							matcher = new RegExp( "^" + $.ui.autocomplete.escapeRegex(request.term), matchcase );
						}
						else
						{
							matcher = new RegExp( $.ui.autocomplete.escapeRegex(request.term), matchcase );
						
						}
						response($.map(data, function(item) {
							if (matcher.test(item) && res < max)
							{
								res++;
								return {
									label: o.highlightMatches(request.term,item),
									value: item
								}
							}
							
							
						}));							  
		
						if (s.maxResults)
						{
							data.length = s.maxResults;
						}
		
		
					  });
				}		
		
			},
	
	
			open : function(event,ui)
			{
			
				if (event.keyCode != 40 && event.keyCode != 38) 
				{			
					var acdiv = ".ui-autocomplete.ui-menu.ui-widget.ui-widget-content.ui-corner-all";
					$(acdiv + " > li:first").prepend(s.header);
					$(acdiv + " > li:last").append(s.footer);



					// Autocomplete uses text() method, fix any escaped > <
					$(acdiv + " li").each( function() {
						t = $(this).find("a").html();
						t = t.replace(/\&lt;b\&gt;/g,"<b>");	
						t = t.replace(/\&lt;\/b\&gt;/g,"</b>");	
						$(this).find("a").html(t);
					});

					if (s.zindex)
					{
						jQuery(acdiv).css("z-index",s.zindex);
					}

				}
			
			},

			
			select: function(event, ui) 
			{
				$(s.inputElement).val(ui.item.value);

				if (typeof s.onSelect === "function") { s.onSelect(event,ui); } 

				if (s.submitOnSelect)
				{
					$(s.inputFormElement).submit();
				}
			},
			
			search: function(event,ui)
			{

				var str = "";
				if (typeof s.onSearch === "function") { 
					s.onSearch("","",event,ui); 
				} 
				if (s.sayt) { return false; }
				return s.autocomplete;

			}
			
				
		};
			
		_ops = $.extend(true,_ops, s);
		$.extend($.ui.autocomplete.prototype.options, _ops);
		return this.autocomplete(s);
	
	};

})(jQuery);


/**@preserve
$.fn.noUiSlider - WTFPL - refreshless.com/nouislider/ */

/*jslint browser: true */
/*jslint sub: true */
/*jslint white: true */
/*jslint continue: true */
/*jslint plusplus: true */

(function( $ ){

  'use strict';

  var
  // Cache the document selector;
  /** @const */
  doc = $(document),
  // Make a backup of the original jQuery/Zepto .val() method.
  /** @const */
  $val = $.fn.val,
  // Namespace for binding and unbinding slider events;
  /** @const */
  namespace = '.nui',
  // Determine the events to bind. IE11 implements pointerEvents without
  // a prefix, which breaks compatibility with the IE10 implementation.
  /** @const */
  actions = window.navigator['pointerEnabled'] ? {
    start: 'pointerdown',
    move: 'pointermove',
    end: 'pointerup'
  } : window.navigator['msPointerEnabled'] ? {
    start: 'MSPointerDown',
    move: 'MSPointerMove',
    end: 'MSPointerUp'
  } : {
    start: 'mousedown touchstart',
    move: 'mousemove touchmove',
    end: 'mouseup touchend'
  },
  // Re-usable list of classes;
  /** @const */
  Classes = [
/*  0 */  'noUi-target'
/*  1 */ ,'noUi-base'
/*  2 */ ,'noUi-origin'
/*  3 */ ,'noUi-handle'
/*  4 */ ,'noUi-horizontal'
/*  5 */ ,'noUi-vertical'
/*  6 */ ,'noUi-background'
/*  7 */ ,'noUi-connect'
/*  8 */ ,'noUi-ltr'
/*  9 */ ,'noUi-rtl'
/* 10 */ ,'noUi-dragable'
/* 11 */ ,''
/* 12 */ ,'noUi-state-drag'
/* 13 */ ,''
/* 14 */ ,'noUi-state-tap'
/* 15 */ ,'noUi-active'
/* 16 */ ,'noUi-extended'
/* 17 */ ,'noUi-stacking'
  ];


// General helpers

  // Limits a value to 0 - 100
  function limit ( a ) {
    return Math.max(Math.min(a, 100), 0);
  }

  // Round a value to the closest 'to'.
  function closest ( value, to ) {
    return Math.round(value / to) * to;
  }

  // Determine the size of a sub-range in relation to a full range.
  function subRangeRatio ( pa, pb ) {
    return (100 / (pb - pa));
  }


// Type validation

  // Checks whether a value is numerical.
  function isNumeric ( a ) {
    return typeof a === 'number' && !isNaN( a ) && isFinite( a );
  }

  // Wraps a variable as an array, if it isn't one yet.
  function asArray ( a ) {
    return $.isArray(a) ? a : [a];
  }


// Class handling

  // Sets a class and removes it after [duration] ms.
  function addClassFor ( element, className, duration ) {
    element.addClass(className);
    setTimeout(function(){
      element.removeClass(className);
    }, duration);
  }


// Value calculation

  // (percentage) How many percent is this value of this range?
  function fromPercentage ( range, value ) {
    return (value * 100) / ( range[1] - range[0] );
  }

  // (percentage) Where is this value on this range?
  function toPercentage ( range, value ) {
    return fromPercentage( range, range[0] < 0 ?
      value + Math.abs(range[0]) :
        value - range[0] );
  }

  // (value) How much is this percentage on this range?
  function isPercentage ( range, value ) {
    return ((value * ( range[1] - range[0] )) / 100) + range[0];
  }

  // (percentage)
  function toStepping ( options, value ) {

    if ( value >= options.xVal.slice(-1)[0] ){
      return 100;
    }

    var j = 1, va, vb, pa, pb;
    while ( value >= options.xVal[j] ){
      j++;
    }

    va = options.xVal[j-1];
    vb = options.xVal[j];
    pa = options.xPct[j-1];
    pb = options.xPct[j];

    return pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));
  }

  // (value)
  function fromStepping ( options, value ) {

    // There is no range group that fits 100
    if ( value >= 100 ){
      return options.xVal.slice(-1)[0];
    }

    var j = 1, va, vb, pa, pb;
    while ( value >= options.xPct[j] ){
      j++;
    }

    va = options.xVal[j-1];
    vb = options.xVal[j];
    pa = options.xPct[j-1];
    pb = options.xPct[j];

    return isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));
  }

  // (percentage) Get the step that applies at a certain value.
  function getStep ( options, value ){

    var j = 1, a, b;

    // Find the proper step for rtl sliders by search in inverse direction.
    // Fixes issue #262.
    while ( (options.dir ? (100 - value) : value) >= options.xPct[j] ){
      j++;
    }

    if ( options.snap ) {

      a = options.xPct[j-1];
      b = options.xPct[j];

      if ((value - a) > ((b-a)/2)){
        return b;
      }

      return a;
    }

    if ( !options.xSteps[j-1] ){
      return value;
    }

    return options.xPct[j-1] + closest(
      value - options.xPct[j-1],
      options.xSteps[j-1]
    );
  }


// Event handling

  // Provide a clean event with standardized offset values.
  function fixEvent ( e ) {

    // Prevent scrolling and panning on touch events, while
    // attempting to slide. The tap event also depends on this.
    e.preventDefault();

    // Filter the event to register the type, which can be
    // touch, mouse or pointer. Offset changes need to be
    // made on an event specific basis.
    var  touch = e.type.indexOf('touch') === 0
      ,mouse = e.type.indexOf('mouse') === 0
      ,pointer = e.type.indexOf('pointer') === 0
      ,x,y, event = e;

    // IE10 implemented pointer events with a prefix;
    if ( e.type.indexOf('MSPointer') === 0 ) {
      pointer = true;
    }

    // Get the originalEvent, if the event has been wrapped
    // by jQuery. Zepto doesn't wrap the event.
    if ( e.originalEvent ) {
      e = e.originalEvent;
    }

    if ( touch ) {
      // noUiSlider supports one movement at a time,
      // so we can select the first 'changedTouch'.
      x = e.changedTouches[0].pageX;
      y = e.changedTouches[0].pageY;
    }

    if ( mouse || pointer ) {

      // Polyfill the pageXOffset and pageYOffset
      // variables for IE7 and IE8;
      if( !pointer && window.pageXOffset === undefined ){
        window.pageXOffset = document.documentElement.scrollLeft;
        window.pageYOffset = document.documentElement.scrollTop;
      }

      x = e.clientX + window.pageXOffset;
      y = e.clientY + window.pageYOffset;
    }

    event.points = [x, y];
    event.cursor = mouse;

    return event;
  }


// Input validation

  function testStep ( parsed, entry ) {

    if ( !isNumeric( entry ) ) {
      throw new Error("noUiSlider: 'step' is not numeric.");
    }

    // The step option can still be used to set stepping
    // for linear sliders. Overwritten if set in 'range'.
    parsed.xSteps[0] = entry;
  }

  function testRange ( parsed, entry ) {

    // Filter incorrect input.
    if ( typeof entry !== 'object' || $.isArray(entry) ) {
      throw new Error("noUiSlider: 'range' is not an object.");
    }

    // Catch missing start or end.
    if ( entry['min'] === undefined ||
        entry['max'] === undefined ) {
      throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
    }

    // Loop all entries.
    $.each( entry, function ( index, value ) {

      var percentage;

      // Wrap numerical input in an array.
      if ( typeof value === "number" ) {
        value = [value];
      }

      // Reject any invalid input.
      if ( !$.isArray( value ) ){
        throw new Error("noUiSlider: 'range' contains invalid value.");
      }

      // Covert min/max syntax to 0 and 100.
      if ( index === 'min' ) {
        percentage = 0;
      } else if ( index === 'max' ) {
        percentage = 100;
      } else {
        percentage = parseFloat( index );
      }

      // Check for correct input.
      if ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {
        throw new Error("noUiSlider: 'range' value isn't numeric.");
      }

      // Store values.
      parsed.xPct.push( percentage );
      parsed.xVal.push( value[0] );

      // NaN will evaluate to false too, but to keep
      // logging clear, set step explicitly. Make sure
      // not to override the 'step' setting with false.
      if ( !percentage ) {
        if ( !isNaN( value[1] ) ) {
          parsed.xSteps[0] = value[1];
        }
      } else {
        parsed.xSteps.push( isNaN(value[1]) ? false : value[1] );
      }
    });

    $.each(parsed.xSteps, function(i,n){

      // Ignore 'false' stepping.
      if ( !n ) {
        return true;
      }

      // Check if step fits. Not required, but this might serve some goal.
      // !((parsed.xVal[i+1] - parsed.xVal[i]) % n);

      // Factor to range ratio
      parsed.xSteps[i] = fromPercentage([
         parsed.xVal[i]
        ,parsed.xVal[i+1]
      ], n) / subRangeRatio (
        parsed.xPct[i],
        parsed.xPct[i+1] );
    });
  }

  function testStart ( parsed, entry ) {

    if ( typeof entry === "number" ) {
      entry = [entry];
    }

    // Validate input. Values aren't tested, the internal Link will do
    // that and provide a valid location.
    if ( !$.isArray( entry ) || !entry.length || entry.length > 2 ) {
      throw new Error("noUiSlider: 'start' option is incorrect.");
    }

    // Store the number of handles.
    parsed.handles = entry.length;

    // When the slider is initialized, the .val method will
    // be called with the start options.
    parsed.start = entry;
  }

  function testSnap ( parsed, entry ) {

    // Enforce 100% stepping within subranges.
    parsed.snap = entry;

    if ( typeof entry !== 'boolean' ){
      throw new Error("noUiSlider: 'snap' option must be a boolean.");
    }
  }

  function testConnect ( parsed, entry ) {

    if ( entry === 'lower' && parsed.handles === 1 ) {
      parsed.connect = 1;
    } else if ( entry === 'upper' && parsed.handles === 1 ) {
      parsed.connect = 2;
    } else if ( entry === true && parsed.handles === 2 ) {
      parsed.connect = 3;
    } else if ( entry === false ) {
      parsed.connect = 0;
    } else {
      throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
    }
  }

  function testOrientation ( parsed, entry ) {

    // Set orientation to an a numerical value for easy
    // array selection.
    switch ( entry ){
      case 'horizontal':
      parsed.ort = 0;
      break;
      case 'vertical':
      parsed.ort = 1;
      break;
      default:
      throw new Error("noUiSlider: 'orientation' option is invalid.");
    }
  }

  function testMargin ( parsed, entry ) {

    if ( parsed.xPct.length > 2 ) {
      throw new Error("noUiSlider: 'margin' option is only supported on linear sliders.");
    }

    // Parse value to range and store. As xVal is checked
    // to be no bigger than 2, use it as range.
    parsed.margin = fromPercentage(parsed.xVal, entry);

    if ( !isNumeric(entry) ){
      throw new Error("noUiSlider: 'margin' option must be numeric.");
    }
  }

  function testDirection ( parsed, entry ) {

    // Set direction as a numerical value for easy parsing.
    // Invert connection for RTL sliders, so that the proper
    // handles get the connect/background classes.
    switch ( entry ) {
      case 'ltr':
      parsed.dir = 0;
      break;
      case 'rtl':
      parsed.dir = 1;
      parsed.connect = [0,2,1,3][parsed.connect];
      break;
      default:
      throw new Error("noUiSlider: 'direction' option was not recognized.");
    }
  }

  function testBehaviour ( parsed, entry ) {

    // Make sure the input is a string.
    if ( typeof entry !== 'string' ) {
      throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
    }

    // Check if the string contains any keywords.
    // None are required.
    var tap = entry.indexOf('tap') >= 0,
      extend = entry.indexOf('extend') >= 0,
      drag = entry.indexOf('drag') >= 0,
      fixed = entry.indexOf('fixed') >= 0,
      snap = entry.indexOf('snap') >= 0;

    parsed.events = {
      tap: tap || snap,
      extend: extend,
      drag: drag,
      fixed: fixed,
      snap: snap
    };
  }

  function testSerialization ( parsed, entry, sliders ) {

    parsed.ser = [ entry['lower'], entry['upper'] ];
    parsed.formatting = entry['format'];

    $.each( parsed.ser, function( index, linkInstances ){

      // Check if the provided option is an array.
      if ( !$.isArray(linkInstances) ) {
        throw new Error("noUiSlider: 'serialization."+(!index ? 'lower' : 'upper')+"' must be an array.");
      }

      $.each(linkInstances, function(){

        // Check if entry is a Link.
        if ( !(this instanceof $.Link) ) {
          throw new Error("noUiSlider: 'serialization."+(!index ? 'lower' : 'upper')+"' can only contain Link instances.");
        }

        // Assign properties.
        this.setIndex ( index );
        this.setObject( sliders );
        this.setFormatting( entry['format'] );
      });
    });

    // If the slider has two handles and is RTL,
    // reverse the serialization input. For one handle,
    // lower is still lower.
    if ( parsed.dir && parsed.handles > 1 ) {
      parsed.ser.reverse();
    }
  }

  // Test all developer settings and parse to assumption-safe values.
  function test ( options, sliders ){

  /*  Every input option is tested and parsed. This'll prevent
    endless validation in internal methods. These tests are
    structured with an item for every option available. An
    option can be marked as required by setting the 'r' flag.
    The testing function is provided with three arguments:
      - The provided value for the option;
      - A reference to the options object;
      - The name for the option;

    The testing function returns false when an error is detected,
    or true when everything is OK. It can also modify the option
    object, to make sure all values can be correctly looped elsewhere. */

    var parsed = {
       xPct: []
      ,xVal: []
      ,xSteps: [ false ]
      ,margin: 0
    }, tests;

    // Tests are executed in the order they are presented here.
    tests = {
      'step': { r: false, t: testStep },
      'start': { r: true, t: testStart },
      'connect': { r: true, t: testConnect },
      'direction': { r: true, t: testDirection },
      'range': { r: true, t: testRange },
      'snap': { r: false, t: testSnap },
      'orientation': { r: false, t: testOrientation },
      'margin': { r: false, t: testMargin },
      'behaviour': { r: true, t: testBehaviour },
      'serialization': { r: true, t: testSerialization }
    };

    // Set defaults where applicable.
    options = $.extend({
      'connect': false,
      'direction': 'ltr',
      'behaviour': 'tap',
      'orientation': 'horizontal'
    }, options);

    // Make sure the test for serialization runs.
    options['serialization'] = $.extend({
       'lower': []
      ,'upper': []
      ,'format': {}
    }, options['serialization']);

    // Run all options through a testing mechanism to ensure correct
    // input. It should be noted that options might get modified to
    // be handled properly. E.g. wrapping integers in arrays.
    $.each( tests, function( name, test ){

      if ( options[name] === undefined ) {

        if ( test.r ) {
          throw new Error("noUiSlider: '" + name + "' is required.");
        }

        return true;
      }

      test.t( parsed, options[name], sliders );
    });

    // Pre-define the styles.
    parsed.style = parsed.ort ? 'top' : 'left';

    return parsed;
  }


// DOM additions

  // Append a handle to the base.
  function addHandle ( options, index ) {

    var handle = $('<div><div/></div>').addClass( Classes[2] ),
      additions = [ '-lower', '-upper' ];

    if ( options.dir ) {
      additions.reverse();
    }

    handle.children().addClass(
      Classes[3] + " " + Classes[3]+additions[index]
    );

    return handle;
  }

  // Create a copy of an element-creating Link.
  function addElement ( handle, link ) {

    // If the Link requires creation of a new element,
    // create this element and return a new Link instance.
    if ( link.el ) {

      link = new $.Link({
        'target': $(link.el).clone().appendTo( handle ),
        'method': link.method,
        'format': link.formatting
      }, true);
    }

    // Otherwise, return the reference.
    return link;
  }

  // Loop all links for a handle.
  function addElements ( elements, handle, formatting ) {

    var index, list = [], standard = new $.Link({}, true);

    // Use the Link interface to provide unified
    // formatting for the .val() method.
    standard.setFormatting(formatting);

    // The list now contains at least one element.
    list.push( standard );

    // Loop all links in either 'lower' or 'upper'.
    for ( index = 0; index < elements.length; index++ ) {
      list.push(addElement(handle, elements[index]));
    }

    return list;
  }

  // Go over all Links and assign them to a handle.
  function addLinks ( options, handles ) {

    var index, links = [];

    // Copy the links into a new array, instead of modifying
    // the 'options.ser' list. This allows replacement of the invalid
    // '.el' Links, while the others are still passed by reference.
    for ( index = 0; index < options.handles; index++ ) {

      // Append a new array.
      links[index] = addElements(
        options.ser[index],
        handles[index].children(),
        options.formatting
      );
    }

    return links;
  }

  // Add the proper connection classes.
  function addConnection ( connect, target, handles ) {

    // Apply the required connection classes to the elements
    // that need them. Some classes are made up for several
    // segments listed in the class list, to allow easy
    // renaming and provide a minor compression benefit.
    switch ( connect ) {
      case 1: target.addClass( Classes[7] );
          handles[0].addClass( Classes[6] );
          break;
      case 3: handles[1].addClass( Classes[6] );
          /* falls through */
      case 2: handles[0].addClass( Classes[7] );
          /* falls through */
      case 0: target.addClass(Classes[6]);
          break;
    }
  }

  // Add handles and loop Link elements.
  function addHandles ( options, base ) {

    var index, handles = [];

    // Append handles.
    for ( index = 0; index < options.handles; index++ ) {

      // Keep a list of all added handles.
      handles.push( addHandle( options, index ).appendTo(base) );
    }

    return handles;
  }

  // Initialize a single slider.
  function addSlider ( options, target ) {

    // Apply classes and data to the target.
    target.addClass([
      Classes[0],
      Classes[8 + options.dir],
      Classes[4 + options.ort]
    ].join(' '));

    return $('<div/>').appendTo(target).addClass( Classes[1] );
  }


// Slider scope

function closure ( target, options, originalOptions ){

// Internal variables

  // All variables local to 'closure' are marked $.
  var $Target = $(target),
    $Locations = [-1, -1],
    $Base,
    $Serialization,
    $Handles;

  // Shorthand for base dimensions.
  function baseSize ( ) {
    return $Base[['width', 'height'][options.ort]]();
  }


// External event handling

  function fireEvents ( events ) {

    // Use the external api to get the values.
    // Wrap the values in an array, as .trigger takes
    // only one additional argument.
    var index, values = [ $Target.val() ];

    for ( index = 0; index < events.length; index++ ){
      $Target.trigger(events[index], values);
    }
  }


// Handle placement

  // Test suggested values and apply margin, step.
  function setHandle ( handle, to, delimit ) {

    var n = handle[0] !== $Handles[0][0] ? 1 : 0,
      lower = $Locations[0] + options.margin,
      upper = $Locations[1] - options.margin;

    // Don't delimit range dragging.
    if ( delimit && $Handles.length > 1 ) {
      to = n ? Math.max( to, lower ) : Math.min( to, upper );
    }

    // Handle the step option.
    if ( to < 100 ){
      to = getStep(options, to);
    }

    // Limit to 0/100 for .val input, trim anything beyond 7 digits, as
    // JavaScript has some issues in its floating point implementation.
    to = limit(parseFloat(to.toFixed(7)));

    // Return falsy if handle can't move. False for 0 or 100 limit,
    // '0' for limiting by another handle.
    if ( to === $Locations[n] ) {
      if ( $Handles.length === 1 ) {
        return false;
      }
      return ( to === lower || to === upper ) ? 0 : false;
    }

    // Set the handle to the new position.
    handle.css( options.style, to + '%' );

    // Force proper handle stacking
    if ( handle.is(':first-child') ) {
      handle.toggleClass(Classes[17], to > 50 );
    }

    // Update locations.
    $Locations[n] = to;

    // Invert the value if this is a right-to-left slider.
    if ( options.dir ) {
      to = 100 - to;
    }

    // Write values to serialization Links.
    // Convert the value to the correct relative representation.
    // Convert the value to the slider stepping/range.
    $($Serialization[n]).each(function(){
      this.write( fromStepping( options, to ), handle.children(), $Target );
    });

    return true;
  }

  // Delimit proposed values for handle positions.
  function getPositions ( a, b, delimit ) {

    // Add movement to current position.
    var c = a + b[0], d = a + b[1];

    // Only alter the other position on drag,
    // not on standard sliding.
    if ( delimit ) {
      if ( c < 0 ) {
        d += Math.abs(c);
      }
      if ( d > 100 ) {
        c -= ( d - 100 );
      }

      // Limit values to 0 and 100.
      return [limit(c), limit(d)];
    }

    return [c,d];
  }

  // Handles movement by tapping.
  function jump ( handle, to, instant ) {

    if ( !instant ) {
      // Flag the slider as it is now in a transitional state.
      // Transition takes 300 ms, so re-enable the slider afterwards.
      addClassFor( $Target, Classes[14], 300 );
    }

    // Move the handle to the new position.
    setHandle( handle, to, false );

    fireEvents(['slide', 'set', 'change']);
  }


// Events

  // Handler for attaching events trough a proxy.
  function attach ( events, element, callback, data ) {

    // Add the noUiSlider namespace to all events.
    events = events.replace( /\s/g, namespace + ' ' ) + namespace;

    // Bind a closure on the target.
    return element.on( events, function( e ){

      // jQuery and Zepto handle unset attributes differently.
      var disabled = $Target.attr('disabled');
        disabled = !( disabled === undefined || disabled === null );

      // Test if there is anything that should prevent an event
      // from being handled, such as a disabled state or an active
      // 'tap' transition.
      if( $Target.hasClass( Classes[14] ) || disabled ) {
        return false;
      }

      e = fixEvent(e);
      e.calcPoint = e.points[ options.ort ];

      // Call the event handler with the event [ and additional data ].
      callback ( e, data );
    });
  }

  // Handle movement on document for handle and range drag.
  function move ( event, data ) {

    var handles = data.handles || $Handles, positions, state = false,
      proposal = ((event.calcPoint - data.start) * 100) / baseSize(),
      h = handles[0][0] !== $Handles[0][0] ? 1 : 0;

    // Calculate relative positions for the handles.
    positions = getPositions( proposal, data.positions, handles.length > 1);

    state = setHandle ( handles[0], positions[h], handles.length === 1 );

    if ( handles.length > 1 ) {
      state = setHandle ( handles[1], positions[h?0:1], false ) || state;
    }

    // Fire the 'slide' event if any handle moved.
    if ( state ) {
      fireEvents(['slide']);
    }
  }

  // Unbind move events on document, call callbacks.
  function end ( event ) {

    // The handle is no longer active, so remove the class.
    $('.' + Classes[15]).removeClass(Classes[15]);

    // Remove cursor styles and text-selection events bound to the body.
    if ( event.cursor ) {
      $('body').css('cursor', '').off( namespace );
    }

    // Unbind the move and end events, which are added on 'start'.
    doc.off( namespace );

    // Remove dragging class.
    $Target.removeClass(Classes[12]);

    // Fire the change and set events.
    fireEvents(['set', 'change']);
  }

  // Bind move events on document.
  function start ( event, data ) {

    // Mark the handle as 'active' so it can be styled.
    if( data.handles.length === 1 ) {
      data.handles[0].children().addClass(Classes[15]);
    }

    // A drag should never propagate up to the 'tap' event.
    event.stopPropagation();

    // Attach the move event.
    attach ( actions.move, doc, move, {
      start: event.calcPoint,
      handles: data.handles,
      positions: [
        $Locations[0],
        $Locations[$Handles.length - 1]
      ]
    });

    // Unbind all movement when the drag ends.
    attach ( actions.end, doc, end, null );

    // Text selection isn't an issue on touch devices,
    // so adding cursor styles can be skipped.
    if ( event.cursor ) {

      // Prevent the 'I' cursor and extend the range-drag cursor.
      $('body').css('cursor', $(event.target).css('cursor'));

      // Mark the target with a dragging state.
      if ( $Handles.length > 1 ) {
        $Target.addClass(Classes[12]);
      }

      // Prevent text selection when dragging the handles.
      $('body').on('selectstart' + namespace, false);
    }
  }

  // Move closest handle to tapped location.
  function tap ( event ) {

    var location = event.calcPoint, total = 0, to;

    // The tap event shouldn't propagate up and cause 'edge' to run.
    event.stopPropagation();

    // Add up the handle offsets.
    $.each( $Handles, function(){
      total += this.offset()[ options.style ];
    });

    // Find the handle closest to the tapped position.
    total = ( location < total/2 || $Handles.length === 1 ) ? 0 : 1;

    location -= $Base.offset()[ options.style ];

    // Calculate the new position.
    to = ( location * 100 ) / baseSize();

    // Find the closest handle and calculate the tapped point.
    // The set handle to the new position.
    jump( $Handles[total], to, options.events.snap );

    if ( options.events.snap ) {
      start(event, { handles: [$Handles[total]] });
    }
  }

  // Move handle to edges when target gets tapped.
  function edge ( event ) {

    var i = event.calcPoint < $Base.offset()[ options.style ],
      to = i ? 0 : 100;

    i = i ? 0 : $Handles.length - 1;

    jump( $Handles[i], to, false );
  }

  // Attach events to several slider parts.
  function events ( behaviour ) {

    var i, drag;

    // Attach the standard drag event to the handles.
    if ( !behaviour.fixed ) {

      for ( i = 0; i < $Handles.length; i++ ) {

        // These events are only bound to the visual handle
        // element, not the 'real' origin element.
        attach ( actions.start, $Handles[i].children(), start, {
          handles: [ $Handles[i] ]
        });
      }
    }

    // Attach the tap event to the slider base.
    if ( behaviour.tap ) {
      attach ( actions.start, $Base, tap, {
        handles: $Handles
      });
    }

    // Extend tapping behaviour to target
    if ( behaviour.extend ) {

      $Target.addClass( Classes[16] );

      if ( behaviour.tap ) {
        attach ( actions.start, $Target, edge, {
          handles: $Handles
        });
      }
    }

    // Make the range dragable.
    if ( behaviour.drag ){

      drag = $Base.find( '.' + Classes[7] ).addClass( Classes[10] );

      // When the range is fixed, the entire range can
      // be dragged by the handles. The handle in the first
      // origin will propagate the start event upward,
      // but it needs to be bound manually on the other.
      if ( behaviour.fixed ) {
        drag = drag.add($Base.children().not( drag ).children());
      }

      attach ( actions.start, drag, start, {
        handles: $Handles
      });
    }
  }


// Initialize slider

  // Throw an error if the slider was already initialized.
  if ( $Target.hasClass(Classes[0]) ) {
    throw new Error('Slider was already initialized.');
  }

  // Create the base element, initialise HTML and set classes.
  // Add handles and links.
  $Base = addSlider( options, $Target );
  $Handles = addHandles( options, $Base );
  $Serialization = addLinks( options, $Handles );

  // Set the connect classes.
  addConnection ( options.connect, $Target, $Handles );

  // Attach user events.
  events( options.events );


// Methods

  // Set the slider value.
  /** @expose */
  target.vSet = function ( ) {

    var args = Array.prototype.slice.call( arguments, 0 ),
      callback, link, update, animate,
      i, count, actual, to, values = asArray( args[0] );

    // Extract modifiers for value method.
    if ( typeof args[1] === 'object' ) {
      callback = args[1]['set'];
      link = args[1]['link'];
      update = args[1]['update'];
      animate = args[1]['animate'];

    // Support the 'true' option.
    } else if ( args[1] === true ) {
      callback = true;
    }

    // The RTL settings is implemented by reversing the front-end,
    // internal mechanisms are the same.
    if ( options.dir && options.handles > 1 ) {
      values.reverse();
    }

    // Animation is optional.
    if ( animate ) {
      addClassFor( $Target, Classes[14], 300 );
    }

    // Determine how often to set the handles.
    count = $Handles.length > 1 ? 3 : 1;
    if ( values.length === 1 ) {
      count = 1;
    }

    // If there are multiple handles to be set run the setting
    // mechanism twice for the first handle, to make sure it
    // can be bounced of the second one properly.
    for ( i = 0; i < count; i++ ) {

      to = link || $Serialization[i%2][0];
      to = to.getValue( values[i%2] );

      if ( to === false ) {
        continue;
      }

      // Calculate the new handle position
      to = toStepping( options, to );

      // Invert the value if this is a right-to-left slider.
      if ( options.dir ) {
        to = 100 - to;
      }

      // Force delimitation.
      if ( setHandle( $Handles[i%2], to, true ) === true ) {
        continue;
      }

      // Reset the input if it doesn't match the slider.
      $($Serialization[i%2]).each(function(index){

        if (!index) {
          actual = this.actual;
          return true;
        }

        this.write(
          actual,
          $Handles[i%2].children(),
          $Target,
          update
        );
      });
    }

    // Optionally fire the 'set' event.
    if( callback === true ) {
      fireEvents(['set']);
    }

    return this;
  };

  // Get the slider value.
  /** @expose */
  target.vGet = function ( ) {

    var i, retour = [];

    // Get the value from all handles.
    for ( i = 0; i < options.handles; i++ ){
      retour[i] = $Serialization[i][0].saved;
    }

    // If only one handle is used, return a single value.
    if ( retour.length === 1 ){
      return retour[0];
    }

    if ( options.dir ) {
      return retour.reverse();
    }

    return retour;
  };

  // Destroy the slider and unbind all events.
  /** @expose */
  target.destroy = function ( ) {

    // Loop all linked serialization objects and unbind all
    // events in the noUiSlider namespace.
    $.each($Serialization, function(){
      $.each(this, function(){
        // Won't remove 'change' when bound implicitly.
        if ( this.target ) {
          this.target.off( namespace );
        }
      });
    });

    // Unbind events on the slider, remove all classes and child elements.
    $(this).off(namespace)
      .removeClass(Classes.join(' '))
      .empty();

    // Return the original options from the closure.
    return originalOptions;
  };


// Value setting

  // Use the public value method to set the start values.
  $Target.val( options.start );
}


// Access points

  // Run the standard initializer
  function initialize ( originalOptions ) {

    // Throw error if group is empty.
    if ( !this.length ){
      throw new Error("noUiSlider: Can't initialize slider on empty selection.");
    }

    // Test the options once, not for every slider.
    var options = test( originalOptions, this );

    // Loop all items, and provide a new closed-scope environment.
    return this.each(function(){
      closure(this, options, originalOptions);
    });
  }

  // Destroy the slider, then re-enter initialization.
  function rebuild ( options ) {

    return this.each(function(){

      // Get the current values from the slider,
      // including the initialization options.
      var values = $(this).val(),
        originalOptions = this.destroy(),

        // Extend the previous options with the newly provided ones.
        newOptions = $.extend( {}, originalOptions, options );

      // Run the standard initializer.
      $(this).noUiSlider( newOptions );

      // If the start option hasn't changed,
      // reset the previous values.
      if ( originalOptions.start === newOptions.start ) {
        $(this).val(values);
      }
    });
  }

  // Access the internal getting and setting methods based on argument count.
  function value ( ) {
    return this[0][ !arguments.length ? 'vGet' : 'vSet' ].apply(this[0], arguments);
  }

  // Override the .val() method. Test every element. Is it a slider? Go to
  // the slider value handling. No? Use the standard method.
  // Note how $.fn.val extects 'this' to be an instance of $. For convenience,
  // the above 'value' function does too.
  $.fn.val = function ( ) {

    // this === instanceof $

    function valMethod( a ){
      return a.hasClass(Classes[0]) ? value : $val;
    }

    var args = arguments,
      first = $(this[0]);

    if ( !arguments.length ) {
      return valMethod(first).call(first);
    }

    // Return the set so it remains chainable
    return this.each(function(){
      valMethod($(this)).apply($(this), args);
    });
  };

// Remap the serialization constructor for legacy support.
  /** @expose */
  $.noUiSlider = { 'Link': $.Link };

// Extend jQuery/Zepto with the noUiSlider method.
  /** @expose */
  $.fn.noUiSlider = function ( options, re ) {
    return ( re ? rebuild : initialize ).call(this, options);
  };

}( window['jQuery'] || window['Zepto'] ));
/**@preserve
$.Link (part of noUiSlider) - WTFPL */

/*jslint browser: true */
/*jslint sub: true */
/*jslint white: true */

(function( $ ){

	'use strict';

	// Throw an error if formatting options are incompatible.
	function throwEqualError( F, a, b ) {
		if ( (F[a] || F[b]) && (F[a] === F[b]) ) {
			throw new Error("(Link) '"+a+"' can't match '"+b+"'.'");
		}
	}

	// Test in an object is an instance of jQuery or Zepto.
	function isInstance ( a ) {
		return a instanceof $ || ( $['zepto'] && $['zepto']['isZ'](a) );
	}

var
/** @const */ Formatting = [
/*  0 */  'decimals'
/*  1 */ ,'mark'
/*  2 */ ,'thousand'
/*  3 */ ,'prefix'
/*  4 */ ,'postfix'
/*  5 */ ,'encoder'
/*  6 */ ,'decoder'
/*  7 */ ,'negative'
/*  8 */ ,'negativeBefore'
/*  9 */ ,'to'
/* 10 */ ,'from'
	],
/** @const */ FormatDefaults = [
/*  0 */  2
/*  1 */ ,'.'
/*  2 */ ,''
/*  3 */ ,''
/*  4 */ ,''
/*  5 */ ,function(a){ return a; }
/*  6 */ ,function(a){ return a; }
/*  7 */ ,'-'
/*  8 */ ,''
/*  9 */ ,function(a){ return a; }
/* 10 */ ,function(a){ return a; }
	];


	/** @constructor */
	function Format( options ){

		// If no settings where provided, the defaults will be loaded.
		if ( options === undefined ){
			options = {};
		}

		if ( typeof options !== 'object' ){
			throw new Error("(Format) 'format' option must be an object.");
		}

		var settings = {};

		// Copy all values into a new object.
		$(Formatting).each(function(i, val){

			if ( options[val] === undefined ){

				settings[val] = FormatDefaults[i];

			// When we aren't loading defaults, validate the entry.
			} else if ( (typeof options[val]) === (typeof FormatDefaults[i]) ) {

				// Support for up to 7 decimals.
				// More can't be guaranteed due to floating point issues.
				if ( val === 'decimals' ){
					if ( options[val] < 0 || options[val] > 7 ){
						throw new Error("(Format) 'format.decimals' option must be between 0 and 7.");
					}
				}

				settings[val] = options[val];

			// If the value isn't valid, emit an error.
			} else {
				throw new Error("(Format) 'format."+val+"' must be a " + typeof FormatDefaults[i] + ".");
			}
		});

		// Some values can't be extracted from a
		// string if certain combinations are present.
		throwEqualError(settings, 'mark', 'thousand');
		throwEqualError(settings, 'prefix', 'negative');
		throwEqualError(settings, 'prefix', 'negativeBefore');

		this.settings = settings;
	}

	// Shorthand for internal value get
	Format.prototype.v = function ( a ) {
		return this.settings[a];
	};

	Format.prototype.to = function ( number ) {

		function reverse ( a ) {
			return a.split('').reverse().join('');
		}

		number = this.v('encoder')( number );

		var decimals = this.v('decimals'),
			negative = '', preNegative = '', base = '', mark = '';

		// Rounding away decimals might cause a value of -0
		// when using very small ranges. Remove those cases.
		if ( parseFloat(number.toFixed(decimals)) === 0 ) {
			number = '0';
		}

		if ( number < 0 ) {
			negative = this.v('negative');
			preNegative = this.v('negativeBefore');
		}

		// Round to proper decimal count
		number = Math.abs(number).toFixed(decimals).toString();
		number = number.split('.');

		// Group numbers in sets of three.
		if ( this.v('thousand') ) {
			base = reverse(number[0]).match(/.{1,3}/g);
			base = reverse(base.join(reverse( this.v('thousand') )));
		} else {
			base = number[0];
		}

		// Ignore the decimal separator if decimals are set to 0.
		if ( this.v('mark') && number.length > 1 ) {
			mark = this.v('mark') + number[1];
		}

		// Return the finalized formatted number.
		return this.v('to')(preNegative +
			this.v('prefix') +
			negative +
			base +
			mark +
			this.v('postfix'));
	};

	Format.prototype.from = function ( input ) {

		function esc(s){
			return s.replace(/[\-\/\\\^$*+?.()|\[\]{}]/g, '\\$&');
		}

		var isNeg;
		// The set request might want to ignore this handle.
		// Test for 'undefined' too, as a two-handle slider
		// can still be set with an integer.
		if ( input === null || input === undefined ) {
			return false;
		}

		input = this.v('from')(input);

		// Remove formatting and set period for float parsing.
		input = input.toString();

		// Replace the preNegative indicator.
		isNeg = input.replace(new RegExp('^' + esc( this.v('negativeBefore') )), '');

		// Check if the value changed by removing the negativeBefore symbol.
		if( input !== isNeg ) {
			input = isNeg;
			isNeg = '-';
		} else {
			isNeg = '';
		}

		// If prefix is set and the number is actually prefixed.
		input = input.replace(new RegExp('^'+esc( this.v('prefix') )), '');

		// Only replace if a negative sign is set.
		if ( this.v('negative') ) {

			// Reset isNeg to prevent double '-' insertion.
			isNeg = '';

			// Reset the negative sign to '-'
			input = input.replace(new RegExp('^'+esc( this.v('negative') )), '-');
		}

		// Clean the input string
		input = input
		// If postfix is set and the number is postfixed.
			.replace( new RegExp(esc( this.v('postfix') ) + '$'), '')
		// Remove the separator every three digits.
			.replace( new RegExp(esc( this.v('thousand') ), 'g'), '')
		// Set the decimal separator back to period.
			.replace( this.v('mark'), '.');

		// Run the user defined decoder. Returns input by default.
		input = this.v('decoder')( parseFloat( isNeg + input ) );

		// Ignore invalid input
		if (isNaN( input )) {
			return false;
		}

		return input;
	};


/** @expose */
/** @constructor */
	function Link ( entry, update ) {

		if ( typeof entry !== "object" ) {
			$.error("(Link) Initialize with an object.");
		}

		// Make sure Link isn't called as a function, in which case
		// the 'this' scope would be the window.
		return new Link.prototype.init( entry['target']||function(){}, entry['method'], entry['format']||{}, update );
	}

	Link.prototype.setTooltip = function ( target, method ) {

		// By default, use the 'html' method.
		this.method = method || 'html';

		// Use jQuery to create the element
		this.el = $( target.replace('-tooltip-', '') || '<div/>' )[0];
	};

	Link.prototype.setHidden = function ( target ) {

		this.method = 'val';

		this.el = document.createElement('input');
		this.el.name = target;
		this.el.type = 'hidden';
	};

	Link.prototype.setField = function ( target ) {

		// Returns nulled array.
		function at(a,b,c){
			return [c?a:b, c?b:a];
		}

		// In IE < 9, .bind() isn't available, need this link in .change().
		var that = this;

		// Default to .val if this is an input element.
		this.method = 'val';
		// Set the slider to a new value on change.
		this.target = target.on('change', function( e ){
			that.obj.val(
				at(null, $(e.target).val(), that.N),
				{ 'link': that, 'set': true }
			);
		});
	};


	// Initialisor
	/** @constructor */
	Link.prototype.init = function ( target, method, format, update ) {

		// Write all formatting to this object.
		// No validation needed, as we'll merge these with the parent
		// format options first.
		this.formatting = format;

		// Store the update option.
		this.update = !update;

		// If target is a string, a new hidden input will be created.
		if ( typeof target === 'string' && target.indexOf('-tooltip-') === 0 ) {
			this.setTooltip( target, method );
			return;
		}

		// If the string doesn't begin with '-', which is reserved, add a new hidden input.
		if ( typeof target === 'string' && target.indexOf('-') !== 0 ) {
			this.setHidden( target );
			return;
		}

		// The target can also be a function, which will be called.
		if ( typeof target === 'function' ) {
			this.target = false;
			this.method = target;
			return;
		}

		if ( isInstance(target) ) {
			// If a jQuery/Zepto input element is provided, but no method is set,
			// the element can assume it needs to respond to 'change'...

			if ( !method ) {

				if ( target.is('input, select, textarea') ) {
					this.setField( target );
					return;
				}

				// If no method is set, and we are not auto-binding an input, default to 'html'.
				method = 'html';
			}

			// The method must exist on the element.
			if ( typeof method === 'function' || (typeof method === 'string' && target[method]) ) {
				this.method = method;
				this.target = target;
				return;
			}
		}

		// Nothing matched, throw error.
		throw new RangeError("(Link) Invalid Link.");
	};

	// Provides external items with the slider value.
	Link.prototype.write = function ( value, handle, slider, update ) {

		// Don't synchronize this Link.
		if ( this.update && update === false ) {
			return;
		}

		this.actual = value;

		// Format values for display.
		value = this.format( value );

		// Store the numerical value.
		this.saved = value;

		// Branch between serialization to a function or an object.
		if ( typeof this.method === 'function' ) {
			// When target is undefined, the target was a function.
			// In that case, provided the slider as the calling scope.
			// Use [0] to get the DOM element, not the $ instance.
			this.method.call( this.target[0] || slider[0], value, handle, slider );
		} else {
			this.target[ this.method ]( value, handle, slider );
		}
	};

	// Set formatting options.
	Link.prototype.setFormatting = function ( options ) {
		this.formatting = new Format($.extend({},
			options,
			this.formatting instanceof Format ? this.formatting.settings : this.formatting
		));
	};

	Link.prototype.setObject = function ( obj ) {
		this.obj = obj;
	};

	Link.prototype.setIndex = function ( index ) {
		this.N = index;
	};

	// Parses slider value to user defined display.
	Link.prototype.format = function ( a ) {
		return this.formatting.to(a);
	};

	// Converts a formatted value back to a real number.
	Link.prototype.getValue = function ( a ) {
		return this.formatting.from(a);
	};

	// We can now test for Link.init to be an instance of Link.
	Link.prototype.init.prototype = Link.prototype;

	/** @expose */
	$.Link = Link;

}( window['jQuery'] || window['Zepto'] ));
/*! Normalized address bar hiding for iOS & Android (c) @scottjehl MIT License */
(function( win ){
	var doc = win.document;
	
	// If there's a hash, or addEventListener is undefined, stop here
	if( !location.hash && win.addEventListener ){
		
		//scroll to 1
		win.scrollTo( 0, 1 );
		var scrollTop = 1,
			getScrollTop = function(){
				return win.pageYOffset || doc.compatMode === "CSS1Compat" && doc.documentElement.scrollTop || doc.body.scrollTop || 0;
			},
		
			//reset to 0 on bodyready, if needed
			bodycheck = setInterval(function(){
				if( doc.body ){
					clearInterval( bodycheck );
					scrollTop = getScrollTop();
					win.scrollTo( 0, scrollTop === 1 ? 0 : 1 );
				}	
			}, 15 );
		
		win.addEventListener( "load", function(){
			setTimeout(function(){
				//at load, if user hasn't scrolled more than 20 or so...
				if( getScrollTop() < 20 ){
					//reset to hide addr bar at onload
					win.scrollTo( 0, scrollTop === 1 ? 0 : 1 );
				}
			}, 0);
		}, false );
	}
})( this );
/*! A fix for the iOS orientationchange zoom bug.
 Script by @scottjehl, rebound by @wilto.
 MIT / GPLv2 License.
*/
(function(w){
	
	// This fix addresses an iOS bug, so return early if the UA claims it's something else.
	var ua = navigator.userAgent;
	if( !( /iPhone|iPad|iPod/.test( navigator.platform ) && /OS [1-5]_[0-9_]* like Mac OS X/i.test(ua) && ua.indexOf( "AppleWebKit" ) > -1 ) ){
		return;
	}

    var doc = w.document;

    if( !doc.querySelector ){ return; }

    var meta = doc.querySelector( "meta[name=viewport]" ),
        initialContent = meta && meta.getAttribute( "content" ),
        disabledZoom = initialContent + ",maximum-scale=1",
        enabledZoom = initialContent + ",maximum-scale=10",
        enabled = true,
		x, y, z, aig;

    if( !meta ){ return; }

    function restoreZoom(){
        meta.setAttribute( "content", enabledZoom );
        enabled = true;
    }

    function disableZoom(){
        meta.setAttribute( "content", disabledZoom );
        enabled = false;
    }
	
    function checkTilt( e ){
		aig = e.accelerationIncludingGravity;
		x = Math.abs( aig.x );
		y = Math.abs( aig.y );
		z = Math.abs( aig.z );
				
		// If portrait orientation and in one of the danger zones
        if( (!w.orientation || w.orientation === 180) && ( x > 7 || ( ( z > 6 && y < 8 || z < 8 && y > 6 ) && x > 5 ) ) ){
			if( enabled ){
				disableZoom();
			}        	
        }
		else if( !enabled ){
			restoreZoom();
        }
    }
	
	w.addEventListener( "orientationchange", restoreZoom, false );
	w.addEventListener( "devicemotion", checkTilt, false );

})( this );
window.google = window.google || {};

google.infoBox = function infoBox() {
/**
 * @name InfoBox
 * @version 1.1.12 [December 11, 2012]
 * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
 * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]
 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
 *  <p>
 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
 *  <p>
 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
 */

/*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint browser:true */
/*global google */

/**
 * @name InfoBoxOptions
 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
 *  to the map pixel corresponding to <tt>position</tt>.
 * @property {LatLng} position The geographic location at which to display the InfoBox.
 * @property {number} zIndex The CSS z-index style value for the InfoBox.
 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the InfoBox. Style values defined here override those that may
 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the InfoBox before the new style values are applied.
 * @property {string} closeBoxMargin The CSS margin style value for the close box.
 *  The default is "2px" (a 2-pixel margin on all sides).
 * @property {string} closeBoxURL The URL of the image representing the close box.
 *  Note: The default is the URL for Google's standard close box.
 *  Set this property to "" if no close box is required.
 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
 *  map edge after an auto-pan.
 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
 *  [Deprecated in favor of the <tt>visible</tt> property.]
 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
 */

/**
 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
 *  Call <tt>InfoBox.open</tt> to add the box to the map.
 * @constructor
 * @param {InfoBoxOptions} [opt_opts]
 */
var InfoBox = function InfoBox(opt_opts) {

  opt_opts = opt_opts || {};

  google.maps.OverlayView.apply(this, arguments);

  // Standard options (in common with google.maps.InfoWindow):
  //
  this.content_ = opt_opts.content || "";
  this.disableAutoPan_ = opt_opts.disableAutoPan || false;
  this.maxWidth_ = opt_opts.maxWidth || 0;
  this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
  this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
  this.zIndex_ = opt_opts.zIndex || null;

  // Additional options (unique to InfoBox):
  //
  this.boxClass_ = opt_opts.boxClass || "infoBox";
  this.boxStyle_ = opt_opts.boxStyle || {};
  this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
  this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
  if (opt_opts.closeBoxURL === "") {
    this.closeBoxURL_ = "";
  }
  this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);

  if (typeof opt_opts.visible === "undefined") {
    if (typeof opt_opts.isHidden === "undefined") {
      opt_opts.visible = true;
    } else {
      opt_opts.visible = !opt_opts.isHidden;
    }
  }
  this.isHidden_ = !opt_opts.visible;

  this.alignBottom_ = opt_opts.alignBottom || false;
  this.pane_ = opt_opts.pane || "floatPane";
  this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;

  this.div_ = null;
  this.closeListener_ = null;
  this.moveListener_ = null;
  this.contextListener_ = null;
  this.eventListeners_ = null;
  this.fixedWidthSet_ = null;
}

/* InfoBox extends OverlayView in the Google Maps API v3.
 */
InfoBox.prototype = new google.maps.OverlayView();

/**
 * Creates the DIV representing the InfoBox.
 * @private
 */
InfoBox.prototype.createInfoBoxDiv_ = function () {

  var i;
  var events;
  var bw;
  var me = this;

  // This handler prevents an event in the InfoBox from being passed on to the map.
  //
  var cancelHandler = function (e) {
    e.cancelBubble = true;
    if (e.stopPropagation) {
      e.stopPropagation();
    }
  };

  // This handler ignores the current event in the InfoBox and conditionally prevents
  // the event from being passed on to the map. It is used for the contextmenu event.
  //
  var ignoreHandler = function (e) {

    e.returnValue = false;

    if (e.preventDefault) {

      e.preventDefault();
    }

    if (!me.enableEventPropagation_) {

      cancelHandler(e);
    }
  };

  if (!this.div_) {

    this.div_ = document.createElement("div");

    this.setBoxStyle_();

    if (typeof this.content_.nodeType === "undefined") {
      this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
    } else {
      this.div_.innerHTML = this.getCloseBoxImg_();
      this.div_.appendChild(this.content_);
    }

    // Add the InfoBox DIV to the DOM
    this.getPanes()[this.pane_].appendChild(this.div_);

    this.addClickHandler_();

    if (this.div_.style.width) {

      this.fixedWidthSet_ = true;

    } else {

      if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {

        this.div_.style.width = this.maxWidth_;
        this.div_.style.overflow = "auto";
        this.fixedWidthSet_ = true;

      } else { // The following code is needed to overcome problems with MSIE

        bw = this.getBoxWidths_();

        this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
        this.fixedWidthSet_ = false;
      }
    }

    this.panBox_(this.disableAutoPan_);

    if (!this.enableEventPropagation_) {

      this.eventListeners_ = [];

      // Cancel event propagation.
      //
      // Note: mousemove not included (to resolve Issue 152)
      events = ["mousedown", "mouseover", "mouseout", "mouseup",
      "click", "dblclick", "touchstart", "touchend", "touchmove"];

      for (i = 0; i < events.length; i++) {

        this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
      }
      
      // Workaround for Google bug that causes the cursor to change to a pointer
      // when the mouse moves over a marker underneath InfoBox.
      this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function (e) {
        this.style.cursor = "default";
      }));
    }

    this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);

    /**
     * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
     * @name InfoBox#domready
     * @event
     */
    google.maps.event.trigger(this, "domready");
  }
};

/**
 * Returns the HTML <IMG> tag for the close box.
 * @private
 */
InfoBox.prototype.getCloseBoxImg_ = function () {

  var img = "";

  if (this.closeBoxURL_ !== "") {

    img  = "<img";
    img += " src='" + this.closeBoxURL_ + "'";
    img += " align=right"; // Do this because Opera chokes on style='float: right;'
    img += " style='";
    img += " position: relative;"; // Required by MSIE
    img += " cursor: pointer;";
    img += " margin: " + this.closeBoxMargin_ + ";";
    img += "'>";
  }

  return img;
};

/**
 * Adds the click handler to the InfoBox close box.
 * @private
 */
InfoBox.prototype.addClickHandler_ = function () {

  var closeBox;

  if (this.closeBoxURL_ !== "") {

    closeBox = this.div_.firstChild;
    this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());

  } else {

    this.closeListener_ = null;
  }
};

/**
 * Returns the function to call when the user clicks the close box of an InfoBox.
 * @private
 */
InfoBox.prototype.getCloseClickHandler_ = function () {

  var me = this;

  return function (e) {

    // 1.0.3 fix: Always prevent propagation of a close box click to the map:
    e.cancelBubble = true;

    if (e.stopPropagation) {

      e.stopPropagation();
    }

    /**
     * This event is fired when the InfoBox's close box is clicked.
     * @name InfoBox#closeclick
     * @event
     */
    google.maps.event.trigger(me, "closeclick");

    me.close();
  };
};

/**
 * Pans the map so that the InfoBox appears entirely within the map's visible area.
 * @private
 */
InfoBox.prototype.panBox_ = function (disablePan) {

  var map;
  var bounds;
  var xOffset = 0, yOffset = 0;

  if (!disablePan) {

    map = this.getMap();

    if (map instanceof google.maps.Map) { // Only pan if attached to map, not panorama

      if (!map.getBounds().contains(this.position_)) {
      // Marker not in visible area of map, so set center
      // of map to the marker position first.
        map.setCenter(this.position_);
      }

      bounds = map.getBounds();

      var mapDiv = map.getDiv();
      var mapWidth = mapDiv.offsetWidth;
      var mapHeight = mapDiv.offsetHeight;
      var iwOffsetX = this.pixelOffset_.width;
      var iwOffsetY = this.pixelOffset_.height;
      var iwWidth = this.div_.offsetWidth;
      var iwHeight = this.div_.offsetHeight;
      var padX = this.infoBoxClearance_.width;
      var padY = this.infoBoxClearance_.height;
      var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);

      if (pixPosition.x < (-iwOffsetX + padX)) {
        xOffset = pixPosition.x + iwOffsetX - padX;
      } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
        xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
      }
      if (this.alignBottom_) {
        if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
          yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
        } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
          yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
        }
      } else {
        if (pixPosition.y < (-iwOffsetY + padY)) {
          yOffset = pixPosition.y + iwOffsetY - padY;
        } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
          yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
        }
      }

      if (!(xOffset === 0 && yOffset === 0)) {

        // Move the map to the shifted center.
        //
        var c = map.getCenter();
        map.panBy(xOffset, yOffset);
      }
    }
  }
};

/**
 * Sets the style of the InfoBox by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
InfoBox.prototype.setBoxStyle_ = function () {

  var i, boxStyle;

  if (this.div_) {

    // Apply style values from the style sheet defined in the boxClass parameter:
    this.div_.className = this.boxClass_;

    // Clear existing inline style values:
    this.div_.style.cssText = "";

    // Apply style values defined in the boxStyle parameter:
    boxStyle = this.boxStyle_;
    for (i in boxStyle) {

      if (boxStyle.hasOwnProperty(i)) {

        this.div_.style[i] = boxStyle[i];
      }
    }

    // Fix up opacity style for benefit of MSIE:
    //
    if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {

      this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
    }

    // Apply required styles:
    //
    this.div_.style.position = "absolute";
    this.div_.style.visibility = 'hidden';
    if (this.zIndex_ !== null) {

      this.div_.style.zIndex = this.zIndex_;
    }
  }
};

/**
 * Get the widths of the borders of the InfoBox.
 * @private
 * @return {Object} widths object (top, bottom left, right)
 */
InfoBox.prototype.getBoxWidths_ = function () {

  var computedStyle;
  var bw = {top: 0, bottom: 0, left: 0, right: 0};
  var box = this.div_;

  if (document.defaultView && document.defaultView.getComputedStyle) {

    computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");

    if (computedStyle) {

      // The computed styles are always in pixel units (good!)
      bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
      bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
      bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
      bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
    }

  } else if (document.documentElement.currentStyle) { // MSIE

    if (box.currentStyle) {

      // The current styles may not be in pixel units, but assume they are (bad!)
      bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
      bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
      bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
      bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
    }
  }

  return bw;
};

/**
 * Invoked when <tt>close</tt> is called. Do not call it directly.
 */
InfoBox.prototype.onRemove = function () {

  if (this.div_) {

    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};

/**
 * Draws the InfoBox based on the current map projection and zoom level.
 */
InfoBox.prototype.draw = function () {

  this.createInfoBoxDiv_();

  var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);

  this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";
  
  if (this.alignBottom_) {
    this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
  } else {
    this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
  }

  if (this.isHidden_) {

    this.div_.style.visibility = 'hidden';

  } else {

    this.div_.style.visibility = "visible";
  }
};

/**
 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
 *  is <tt>open</tt>ed.
 * @param {InfoBoxOptions} opt_opts
 */
InfoBox.prototype.setOptions = function (opt_opts) {
  if (typeof opt_opts.boxClass !== "undefined") { // Must be first

    this.boxClass_ = opt_opts.boxClass;
    this.setBoxStyle_();
  }
  if (typeof opt_opts.boxStyle !== "undefined") { // Must be second

    this.boxStyle_ = opt_opts.boxStyle;
    this.setBoxStyle_();
  }
  if (typeof opt_opts.content !== "undefined") {

    this.setContent(opt_opts.content);
  }
  if (typeof opt_opts.disableAutoPan !== "undefined") {

    this.disableAutoPan_ = opt_opts.disableAutoPan;
  }
  if (typeof opt_opts.maxWidth !== "undefined") {

    this.maxWidth_ = opt_opts.maxWidth;
  }
  if (typeof opt_opts.pixelOffset !== "undefined") {

    this.pixelOffset_ = opt_opts.pixelOffset;
  }
  if (typeof opt_opts.alignBottom !== "undefined") {

    this.alignBottom_ = opt_opts.alignBottom;
  }
  if (typeof opt_opts.position !== "undefined") {

    this.setPosition(opt_opts.position);
  }
  if (typeof opt_opts.zIndex !== "undefined") {

    this.setZIndex(opt_opts.zIndex);
  }
  if (typeof opt_opts.closeBoxMargin !== "undefined") {

    this.closeBoxMargin_ = opt_opts.closeBoxMargin;
  }
  if (typeof opt_opts.closeBoxURL !== "undefined") {

    this.closeBoxURL_ = opt_opts.closeBoxURL;
  }
  if (typeof opt_opts.infoBoxClearance !== "undefined") {

    this.infoBoxClearance_ = opt_opts.infoBoxClearance;
  }
  if (typeof opt_opts.isHidden !== "undefined") {

    this.isHidden_ = opt_opts.isHidden;
  }
  if (typeof opt_opts.visible !== "undefined") {

    this.isHidden_ = !opt_opts.visible;
  }
  if (typeof opt_opts.enableEventPropagation !== "undefined") {

    this.enableEventPropagation_ = opt_opts.enableEventPropagation;
  }

  if (this.div_) {

    this.draw();
  }
};

/**
 * Sets the content of the InfoBox.
 *  The content can be plain text or an HTML DOM node.
 * @param {string|Node} content
 */
InfoBox.prototype.setContent = function (content) {
  this.content_ = content;

  if (this.div_) {

    if (this.closeListener_) {

      google.maps.event.removeListener(this.closeListener_);
      this.closeListener_ = null;
    }

    // Odd code required to make things work with MSIE.
    //
    if (!this.fixedWidthSet_) {

      this.div_.style.width = "";
    }

    if (typeof content.nodeType === "undefined") {
      this.div_.innerHTML = this.getCloseBoxImg_() + content;
    } else {
      this.div_.innerHTML = this.getCloseBoxImg_();
      this.div_.appendChild(content);
    }

    // Perverse code required to make things work with MSIE.
    // (Ensures the close box does, in fact, float to the right.)
    //
    if (!this.fixedWidthSet_) {
      this.div_.style.width = this.div_.offsetWidth + "px";
      if (typeof content.nodeType === "undefined") {
        this.div_.innerHTML = this.getCloseBoxImg_() + content;
      } else {
        this.div_.innerHTML = this.getCloseBoxImg_();
        this.div_.appendChild(content);
      }
    }

    this.addClickHandler_();
  }

  /**
   * This event is fired when the content of the InfoBox changes.
   * @name InfoBox#content_changed
   * @event
   */
  google.maps.event.trigger(this, "content_changed");
};

/**
 * Sets the geographic location of the InfoBox.
 * @param {LatLng} latlng
 */
InfoBox.prototype.setPosition = function (latlng) {

  this.position_ = latlng;

  if (this.div_) {

    this.draw();
  }

  /**
   * This event is fired when the position of the InfoBox changes.
   * @name InfoBox#position_changed
   * @event
   */
  google.maps.event.trigger(this, "position_changed");
};

/**
 * Sets the zIndex style for the InfoBox.
 * @param {number} index
 */
InfoBox.prototype.setZIndex = function (index) {

  this.zIndex_ = index;

  if (this.div_) {

    this.div_.style.zIndex = index;
  }

  /**
   * This event is fired when the zIndex of the InfoBox changes.
   * @name InfoBox#zindex_changed
   * @event
   */
  google.maps.event.trigger(this, "zindex_changed");
};

/**
 * Sets the visibility of the InfoBox.
 * @param {boolean} isVisible
 */
InfoBox.prototype.setVisible = function (isVisible) {

  this.isHidden_ = !isVisible;
  if (this.div_) {
    this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
  }
};

/**
 * Returns the content of the InfoBox.
 * @returns {string}
 */
InfoBox.prototype.getContent = function () {

  return this.content_;
};

/**
 * Returns the geographic location of the InfoBox.
 * @returns {LatLng}
 */
InfoBox.prototype.getPosition = function () {

  return this.position_;
};

/**
 * Returns the zIndex for the InfoBox.
 * @returns {number}
 */
InfoBox.prototype.getZIndex = function () {

  return this.zIndex_;
};

/**
 * Returns a flag indicating whether the InfoBox is visible.
 * @returns {boolean}
 */
InfoBox.prototype.getVisible = function () {

  var isVisible;

  if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
    isVisible = false;
  } else {
    isVisible = !this.isHidden_;
  }
  return isVisible;
};

/**
 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.show = function () {

  this.isHidden_ = false;
  if (this.div_) {
    this.div_.style.visibility = "visible";
  }
};

/**
 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.hide = function () {

  this.isHidden_ = true;
  if (this.div_) {
    this.div_.style.visibility = "hidden";
  }
};

/**
 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
 *  anchor is dragged to a new location, the InfoBox moves as well.
 * @param {Map|StreetViewPanorama} map
 * @param {MVCObject} [anchor]
 */
InfoBox.prototype.open = function (map, anchor) {

  var me = this;

  if (anchor) {

    this.position_ = anchor.getPosition();
    this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function () {
      me.setPosition(this.getPosition());
    });
  }

  this.setMap(map);

  if (this.div_) {

    this.panBox_();
  }
};

/**
 * Removes the InfoBox from the map.
 */
InfoBox.prototype.close = function () {

  var i;

  if (this.closeListener_) {

    google.maps.event.removeListener(this.closeListener_);
    this.closeListener_ = null;
  }

  if (this.eventListeners_) {
    
    for (i = 0; i < this.eventListeners_.length; i++) {

      google.maps.event.removeListener(this.eventListeners_[i]);
    }
    this.eventListeners_ = null;
  }

  if (this.moveListener_) {

    google.maps.event.removeListener(this.moveListener_);
    this.moveListener_ = null;
  }

  if (this.contextListener_) {

    google.maps.event.removeListener(this.contextListener_);
    this.contextListener_ = null;
  }

  this.setMap(null);
};

  google.InfoBox = InfoBox;
};
window.google = window.google || {};

google.markerClusterer = function() {
/**
 * @name MarkerClustererPlus for Google Maps V3
 * @version 2.1.1 [November 4, 2013]
 * @author Gary Little
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of markers.
 * <p>
 * This is an enhanced V3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the
 * <a href="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/"
 * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.
 * <p>
 * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It
 *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>batchSizeIE</code>,
 *  and <code>calculator</code> properties as well as support for four more events. It also allows
 *  greater control over the styling of the text that appears on the cluster marker. The
 *  documentation has been significantly improved and the overall code has been simplified and
 *  polished. Very large numbers of markers can now be managed without causing Javascript timeout
 *  errors on Internet Explorer. Note that the name of the <code>clusterclick</code> event has been
 *  deprecated. The new name is <code>click</code>, so please change your application code now.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @name ClusterIconStyle
 * @class This class represents the object for values in the <code>styles</code> array passed
 *  to the {@link MarkerClusterer} constructor. The element in this array that is used to
 *  style the cluster icon is determined by calling the <code>calculator</code> function.
 *
 * @property {string} url The URL of the cluster icon image file. Required.
 * @property {number} height The display height (in pixels) of the cluster icon. Required.
 * @property {number} width The display width (in pixels) of the cluster icon. Required.
 * @property {Array} [anchorText] The position (in pixels) from the center of the cluster icon to
 *  where the text label is to be centered and drawn. The format is <code>[yoffset, xoffset]</code>
 *  where <code>yoffset</code> increases as you go down from center and <code>xoffset</code>
 *  increases to the right of center. The default is <code>[0, 0]</code>.
 * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the
 *  spot on the cluster icon that is to be aligned with the cluster position. The format is
 *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and
 *  <code>xoffset</code> increases to the right of the top-left corner of the icon. The default
 *  anchor position is the center of the cluster icon.
 * @property {string} [textColor="black"] The color of the label text shown on the
 *  cluster icon.
 * @property {number} [textSize=11] The size (in pixels) of the label text shown on the
 *  cluster icon.
 * @property {string} [textDecoration="none"] The value of the CSS <code>text-decoration</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontWeight="bold"] The value of the CSS <code>font-weight</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontStyle="normal"] The value of the CSS <code>font-style</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontFamily="Arial,sans-serif"] The value of the CSS <code>font-family</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [backgroundPosition="0 0"] The position of the cluster icon image
 *  within the image defined by <code>url</code>. The format is <code>"xpos ypos"</code>
 *  (the same format as for the CSS <code>background-position</code> property). You must set
 *  this property appropriately when the image defined by <code>url</code> represents a sprite
 *  containing multiple images. Note that the position <i>must</i> be specified in px units.
 */
/**
 * @name ClusterIconInfo
 * @class This class is an object containing general information about a cluster icon. This is
 *  the object that a <code>calculator</code> function returns.
 *
 * @property {string} text The text of the label to be shown on the cluster icon.
 * @property {number} index The index plus 1 of the element in the <code>styles</code>
 *  array to be used to style the cluster icon.
 * @property {string} title The tooltip to display when the mouse moves over the cluster icon.
 *  If this value is <code>undefined</code> or <code>""</code>, <code>title</code> is set to the
 *  value of the <code>title</code> property passed to the MarkerClusterer.
 */
/**
 * A cluster icon.
 *
 * @constructor
 * @extends google.maps.OverlayView
 * @param {Cluster} cluster The cluster with which the icon is to be associated.
 * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons
 *  to use for various cluster sizes.
 * @private
 */
var ClusterIcon = function ClusterIcon(cluster, styles) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.cluster_ = cluster;
  this.className_ = cluster.getMarkerClusterer().getClusterClass();
  this.styles_ = styles;
  this.center_ = null;
  this.div_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(cluster.getMap()); // Note: this causes onAdd to be called
}

/**
 * Adds the icon to the DOM.
 */
ClusterIcon.prototype.onAdd = function () {
  var cClusterIcon = this;
  var cMouseDownInCluster;
  var cDraggingMapByCluster;

  this.div_ = document.createElement("div");
  this.div_.className = this.className_;
  if (this.visible_) {
    this.show();
  }

  this.getPanes().overlayMouseTarget.appendChild(this.div_);

  // Fix for Issue 157
  this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function () {
    cDraggingMapByCluster = cMouseDownInCluster;
  });

  google.maps.event.addDomListener(this.div_, "mousedown", function () {
    cMouseDownInCluster = true;
    cDraggingMapByCluster = false;
  });

  google.maps.event.addDomListener(this.div_, "click", function (e) {
    cMouseDownInCluster = false;
    if (!cDraggingMapByCluster) {
      var theBounds;
      var mz;
      var mc = cClusterIcon.cluster_.getMarkerClusterer();
      /**
       * This event is fired when a cluster marker is clicked.
       * @name MarkerClusterer#click
       * @param {Cluster} c The cluster that was clicked.
       * @event
       */
      google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
      google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_); // deprecated name

      // The default click handler follows. Disable it by setting
      // the zoomOnClick property to false.
      if (mc.getZoomOnClick()) {
        // Zoom into the cluster.
        mz = mc.getMaxZoom();
        theBounds = cClusterIcon.cluster_.getBounds();
        mc.getMap().fitBounds(theBounds);
        // There is a fix for Issue 170 here:
        setTimeout(function () {
          mc.getMap().fitBounds(theBounds);
          // Don't zoom beyond the max zoom level
          if (mz !== null && (mc.getMap().getZoom() > mz)) {
            mc.getMap().setZoom(mz + 1);
          }
        }, 100);
      }

      // Prevent event propagation to the map:
      e.cancelBubble = true;
      if (e.stopPropagation) {
        e.stopPropagation();
      }
    }
  });

  google.maps.event.addDomListener(this.div_, "mouseover", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves over a cluster marker.
     * @name MarkerClusterer#mouseover
     * @param {Cluster} c The cluster that the mouse moved over.
     * @event
     */
    google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
  });

  google.maps.event.addDomListener(this.div_, "mouseout", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves out of a cluster marker.
     * @name MarkerClusterer#mouseout
     * @param {Cluster} c The cluster that the mouse moved out of.
     * @event
     */
    google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
  });
};


/**
 * Removes the icon from the DOM.
 */
ClusterIcon.prototype.onRemove = function () {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    google.maps.event.removeListener(this.boundsChangedListener_);
    google.maps.event.clearInstanceListeners(this.div_);
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};


/**
 * Draws the icon.
 */
ClusterIcon.prototype.draw = function () {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + "px";
    this.div_.style.left = pos.x + "px";
  }
};


/**
 * Hides the icon.
 */
ClusterIcon.prototype.hide = function () {
  if (this.div_) {
    this.div_.style.display = "none";
  }
  this.visible_ = false;
};


/**
 * Positions and shows the icon.
 */
ClusterIcon.prototype.show = function () {
  if (this.div_) {
    var img = "";
    // NOTE: values must be specified in px units
    var bp = this.backgroundPosition_.split(" ");
    var spriteH = parseInt(bp[0].trim(), 10);
    var spriteV = parseInt(bp[1].trim(), 10);
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
    if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
      img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " +
          ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
    }
    img += "'>";
    this.div_.innerHTML = img + "<div style='" +
        "position: absolute;" +
        "top: " + this.anchorText_[0] + "px;" +
        "left: " + this.anchorText_[1] + "px;" +
        "color: " + this.textColor_ + ";" +
        "font-size: " + this.textSize_ + "px;" +
        "font-family: " + this.fontFamily_ + ";" +
        "font-weight: " + this.fontWeight_ + ";" +
        "font-style: " + this.fontStyle_ + ";" +
        "text-decoration: " + this.textDecoration_ + ";" +
        "text-align: center;" +
        "width: " + this.width_ + "px;" +
        "line-height:" + this.height_ + "px;" +
        "'>" + this.sums_.text + "</div>";
    if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
      this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
    } else {
      this.div_.title = this.sums_.title;
    }
    this.div_.style.display = "";
  }
  this.visible_ = true;
};


/**
 * Sets the icon styles to the appropriate element in the styles array.
 *
 * @param {ClusterIconInfo} sums The icon label text and styles index.
 */
ClusterIcon.prototype.useStyle = function (sums) {
  this.sums_ = sums;
  var index = Math.max(0, sums.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style.url;
  this.height_ = style.height;
  this.width_ = style.width;
  this.anchorText_ = style.anchorText || [0, 0];
  this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];
  this.textColor_ = style.textColor || "black";
  this.textSize_ = style.textSize || 11;
  this.textDecoration_ = style.textDecoration || "none";
  this.fontWeight_ = style.fontWeight || "bold";
  this.fontStyle_ = style.fontStyle || "normal";
  this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
  this.backgroundPosition_ = style.backgroundPosition || "0 0";
};


/**
 * Sets the position at which to center the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function (center) {
  this.center_ = center;
};


/**
 * Creates the cssText style parameter based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position of the icon.
 * @return {string} The CSS style text.
 */
ClusterIcon.prototype.createCss = function (pos) {
  var style = [];
  style.push("cursor: pointer;");
  style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
  style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
  return style.join("");
};


/**
 * Returns the position at which to place the DIV depending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 */
ClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
  pos.x -= this.anchorIcon_[1];
  pos.y -= this.anchorIcon_[0];
  pos.x = parseInt(pos.x, 10);
  pos.y = parseInt(pos.y, 10);
  return pos;
};


/**
 * Creates a single cluster that manages a group of proximate markers.
 *  Used internally, do not call this constructor directly.
 * @constructor
 * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this
 *  cluster is associated.
 */
var Cluster = function Cluster(mc) {
  this.markerClusterer_ = mc;
  this.map_ = mc.getMap();
  this.gridSize_ = mc.getGridSize();
  this.minClusterSize_ = mc.getMinimumClusterSize();
  this.averageCenter_ = mc.getAverageCenter();
  this.markers_ = [];
  this.center_ = null;
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
}


/**
 * Returns the number of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {number} The number of markers in the cluster.
 */
Cluster.prototype.getSize = function () {
  return this.markers_.length;
};


/**
 * Returns the array of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {Array} The array of markers in the cluster.
 */
Cluster.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 * Returns the center of the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {google.maps.LatLng} The center of the cluster.
 */
Cluster.prototype.getCenter = function () {
  return this.center_;
};


/**
 * Returns the map with which the cluster is associated.
 *
 * @return {google.maps.Map} The map.
 * @ignore
 */
Cluster.prototype.getMap = function () {
  return this.map_;
};


/**
 * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 * @ignore
 */
Cluster.prototype.getMarkerClusterer = function () {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 * @ignore
 */
Cluster.prototype.getBounds = function () {
  var i;
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster from the map.
 *
 * @ignore
 */
Cluster.prototype.remove = function () {
  this.clusterIcon_.setMap(null);
  this.markers_ = [];
  delete this.markers_;
};


/**
 * Adds a marker to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to be added.
 * @return {boolean} True if the marker was added.
 * @ignore
 */
Cluster.prototype.addMarker = function (marker) {
  var i;
  var mCount;
  var mz;

  if (this.isMarkerAlreadyAdded_(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  mCount = this.markers_.length;
  mz = this.markerClusterer_.getMaxZoom();
  if (mz !== null && this.map_.getZoom() > mz) {
    // Zoomed in past max zoom, so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount < this.minClusterSize_) {
    // Min cluster size not reached so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount === this.minClusterSize_) {
    // Hide the markers that were showing.
    for (i = 0; i < mCount; i++) {
      this.markers_[i].setMap(null);
    }
  } else {
    marker.setMap(null);
  }

  this.updateIcon_();
  return true;
};


/**
 * Determines if a marker lies within the cluster's bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 * @ignore
 */
Cluster.prototype.isMarkerInClusterBounds = function (marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Calculates the extended bounds of the cluster with the grid.
 */
Cluster.prototype.calculateBounds_ = function () {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Updates the cluster icon.
 */
Cluster.prototype.updateIcon_ = function () {
  var mCount = this.markers_.length;
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz !== null && this.map_.getZoom() > mz) {
    this.clusterIcon_.hide();
    return;
  }

  if (mCount < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.useStyle(sums);
  this.clusterIcon_.show();
};


/**
 * Determines if a marker has already been added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker has already been added.
 */
Cluster.prototype.isMarkerAlreadyAdded_ = function (marker) {
  var i;
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) !== -1;
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        return true;
      }
    }
  }
  return false;
};


/**
 * @name MarkerClustererOptions
 * @class This class represents the optional parameter passed to
 *  the {@link MarkerClusterer} constructor.
 * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.
 * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or
 *  <code>null</code> if clustering is to be enabled at all zoom levels.
 * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is
 *  clicked. You may want to set this to <code>false</code> if you have installed a handler
 *  for the <code>click</code> event and it deals with zooming on its own.
 * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be
 *  the average position of all markers in the cluster. If set to <code>false</code>, the
 *  cluster marker is positioned at the location of the first marker added to the cluster.
 * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster
 *  before the markers are hidden and a cluster marker appears.
 * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You
 *  may want to set this to <code>true</code> to ensure that hidden markers are not included
 *  in the marker count that appears on a cluster marker (this count is the value of the
 *  <code>text</code> property of the result returned by the default <code>calculator</code>).
 *  If set to <code>true</code> and you change the visibility of a marker being clustered, be
 *  sure to also call <code>MarkerClusterer.repaint()</code>.
 * @property {string} [title=""] The tooltip to display when the mouse moves over a cluster
 *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a
 *  different tooltip for each cluster marker.)
 * @property {function} [calculator=MarkerClusterer.CALCULATOR] The function used to determine
 *  the text to be displayed on a cluster marker and the index indicating which style to use
 *  for the cluster marker. The input parameters for the function are (1) the array of markers
 *  represented by a cluster marker and (2) the number of cluster icon styles. It returns a
 *  {@link ClusterIconInfo} object. The default <code>calculator</code> returns a
 *  <code>text</code> property which is the number of markers in the cluster and an
 *  <code>index</code> property which is one higher than the lowest integer such that
 *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles
 *  array, whichever is less. The <code>styles</code> array element used has an index of
 *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a
 *  <code>text</code> value of <code>"125"</code> and an <code>index</code> of <code>3</code>
 *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>
 *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>
 *  property that contains the text of the tooltip to be used for the cluster marker. If
 *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>
 *   property for the MarkerClusterer.
 * @property {string} [clusterClass="cluster"] The name of the CSS class defining general styles
 *  for the cluster markers. Use this class to define CSS styles that are not set up by the code
 *  that processes the <code>styles</code> array.
 * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles
 *  of the cluster markers to be used. The element to be used to style a given cluster marker
 *  is determined by the function defined by the <code>calculator</code> property.
 *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived
 *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and
 *  <code>imageSizes</code>.
 * @property {boolean} [enableRetinaIcons=false] Whether to allow the use of cluster icons that
 * have sizes that are some multiple (typically double) of their actual display size. Icons such
 * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.
 * Note: if this property is <code>true</code>, sprites cannot be used as cluster icons.
 * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the
 *  number of markers to be processed in a single batch when using a browser other than
 *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).
 * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is
 *  being used, markers are processed in several batches with a small delay inserted between
 *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the
 *  number of markers to be processed in a single batch; select as high a number as you can
 *  without causing a timeout error in the browser. This number might need to be as low as 100
 *  if 15,000 markers are being managed, for example.
 * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]
 *  The full URL of the root name of the group of image files to use for cluster icons.
 *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>
 *  where n is the image file number (1, 2, etc.).
 * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]
 *  The extension name for the cluster icon image files (e.g., <code>"png"</code> or
 *  <code>"jpg"</code>).
 * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]
 *  An array of numbers containing the widths of the group of
 *  <code>imagePath</code>n.<code>imageExtension</code> image files.
 *  (The images are assumed to be square.)
 */
/**
 * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.
 * @param {MarkerClustererOptions} [opt_options] The optional parameters.
 */
var MarkerClusterer = function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);

  opt_markers = opt_markers || [];
  opt_options = opt_options || {};

  this.markers_ = [];
  this.clusters_ = [];
  this.listeners_ = [];
  this.activeMap_ = null;
  this.ready_ = false;

  this.gridSize_ = opt_options.gridSize || 60;
  this.minClusterSize_ = opt_options.minimumClusterSize || 2;
  this.maxZoom_ = opt_options.maxZoom || null;
  this.styles_ = opt_options.styles || [];
  this.title_ = opt_options.title || "";
  this.zoomOnClick_ = true;
  if (opt_options.zoomOnClick !== undefined) {
    this.zoomOnClick_ = opt_options.zoomOnClick;
  }
  this.averageCenter_ = false;
  if (opt_options.averageCenter !== undefined) {
    this.averageCenter_ = opt_options.averageCenter;
  }
  this.ignoreHidden_ = false;
  if (opt_options.ignoreHidden !== undefined) {
    this.ignoreHidden_ = opt_options.ignoreHidden;
  }
  this.enableRetinaIcons_ = false;
  if (opt_options.enableRetinaIcons !== undefined) {
    this.enableRetinaIcons_ = opt_options.enableRetinaIcons;
  }
  this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
  this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
  this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
  this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
  this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
  this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
  this.clusterClass_ = opt_options.clusterClass || "cluster";

  if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
    // Try to avoid IE timeout when processing a huge number of markers:
    this.batchSize_ = this.batchSizeIE_;
  }

  this.setupStyles_();

  this.addMarkers(opt_markers, true);
  this.setMap(map); // Note: this causes onAdd to be called
}


/**
 * Implementation of the onAdd interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function () {
  var cMarkerClusterer = this;

  this.activeMap_ = this.getMap();
  this.ready_ = true;

  this.repaint();

  // Add the map event listeners
  this.listeners_ = [
    google.maps.event.addListener(this.getMap(), "zoom_changed", function () {
      cMarkerClusterer.resetViewport_(false);
      // Workaround for this Google bug: when map is at level 0 and "-" of
      // zoom slider is clicked, a "zoom_changed" event is fired even though
      // the map doesn't zoom out any further. In this situation, no "idle"
      // event is triggered so the cluster markers that have been removed
      // do not get redrawn. Same goes for a zoom in at maxZoom.
      if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
        google.maps.event.trigger(this, "idle");
      }
    }),
    google.maps.event.addListener(this.getMap(), "idle", function () {
      cMarkerClusterer.redraw_();
    })
  ];
};


/**
 * Implementation of the onRemove interface method.
 * Removes map event listeners and all cluster icons from the DOM.
 * All managed markers are also put back on the map.
 * @ignore
 */
MarkerClusterer.prototype.onRemove = function () {
  var i;

  // Put all the managed markers back on the map:
  for (i = 0; i < this.markers_.length; i++) {
    if (this.markers_[i].getMap() !== this.activeMap_) {
      this.markers_[i].setMap(this.activeMap_);
    }
  }

  // Remove all clusters:
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Remove map event listeners:
  for (i = 0; i < this.listeners_.length; i++) {
    google.maps.event.removeListener(this.listeners_[i]);
  }
  this.listeners_ = [];

  this.activeMap_ = null;
  this.ready_ = false;
};


/**
 * Implementation of the draw interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function () {};


/**
 * Sets up the styles object.
 */
MarkerClusterer.prototype.setupStyles_ = function () {
  var i, size;
  if (this.styles_.length > 0) {
    return;
  }

  for (i = 0; i < this.imageSizes_.length; i++) {
    size = this.imageSizes_[i];
    this.styles_.push({
      url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
      height: size,
      width: size
    });
  }
};


/**
 *  Fits the map to the bounds of the markers managed by the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function () {
  var i;
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }

  this.getMap().fitBounds(bounds);
};


/**
 * Returns the value of the <code>gridSize</code> property.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function () {
  return this.gridSize_;
};


/**
 * Sets the value of the <code>gridSize</code> property.
 *
 * @param {number} gridSize The grid size.
 */
MarkerClusterer.prototype.setGridSize = function (gridSize) {
  this.gridSize_ = gridSize;
};


/**
 * Returns the value of the <code>minimumClusterSize</code> property.
 *
 * @return {number} The minimum cluster size.
 */
MarkerClusterer.prototype.getMinimumClusterSize = function () {
  return this.minClusterSize_;
};

/**
 * Sets the value of the <code>minimumClusterSize</code> property.
 *
 * @param {number} minimumClusterSize The minimum cluster size.
 */
MarkerClusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {
  this.minClusterSize_ = minimumClusterSize;
};


/**
 *  Returns the value of the <code>maxZoom</code> property.
 *
 *  @return {number} The maximum zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function () {
  return this.maxZoom_;
};


/**
 *  Sets the value of the <code>maxZoom</code> property.
 *
 *  @param {number} maxZoom The maximum zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function (maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Returns the value of the <code>styles</code> property.
 *
 *  @return {Array} The array of styles defining the cluster markers to be used.
 */
MarkerClusterer.prototype.getStyles = function () {
  return this.styles_;
};


/**
 *  Sets the value of the <code>styles</code> property.
 *
 *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.
 */
MarkerClusterer.prototype.setStyles = function (styles) {
  this.styles_ = styles;
};


/**
 * Returns the value of the <code>title</code> property.
 *
 * @return {string} The content of the title text.
 */
MarkerClusterer.prototype.getTitle = function () {
  return this.title_;
};


/**
 *  Sets the value of the <code>title</code> property.
 *
 *  @param {string} title The value of the title property.
 */
MarkerClusterer.prototype.setTitle = function (title) {
  this.title_ = title;
};


/**
 * Returns the value of the <code>zoomOnClick</code> property.
 *
 * @return {boolean} True if zoomOnClick property is set.
 */
MarkerClusterer.prototype.getZoomOnClick = function () {
  return this.zoomOnClick_;
};


/**
 *  Sets the value of the <code>zoomOnClick</code> property.
 *
 *  @param {boolean} zoomOnClick The value of the zoomOnClick property.
 */
MarkerClusterer.prototype.setZoomOnClick = function (zoomOnClick) {
  this.zoomOnClick_ = zoomOnClick;
};


/**
 * Returns the value of the <code>averageCenter</code> property.
 *
 * @return {boolean} True if averageCenter property is set.
 */
MarkerClusterer.prototype.getAverageCenter = function () {
  return this.averageCenter_;
};


/**
 *  Sets the value of the <code>averageCenter</code> property.
 *
 *  @param {boolean} averageCenter The value of the averageCenter property.
 */
MarkerClusterer.prototype.setAverageCenter = function (averageCenter) {
  this.averageCenter_ = averageCenter;
};


/**
 * Returns the value of the <code>ignoreHidden</code> property.
 *
 * @return {boolean} True if ignoreHidden property is set.
 */
MarkerClusterer.prototype.getIgnoreHidden = function () {
  return this.ignoreHidden_;
};


/**
 *  Sets the value of the <code>ignoreHidden</code> property.
 *
 *  @param {boolean} ignoreHidden The value of the ignoreHidden property.
 */
MarkerClusterer.prototype.setIgnoreHidden = function (ignoreHidden) {
  this.ignoreHidden_ = ignoreHidden;
};


/**
 * Returns the value of the <code>enableRetinaIcons</code> property.
 *
 * @return {boolean} True if enableRetinaIcons property is set.
 */
MarkerClusterer.prototype.getEnableRetinaIcons = function () {
  return this.enableRetinaIcons_;
};


/**
 *  Sets the value of the <code>enableRetinaIcons</code> property.
 *
 *  @param {boolean} enableRetinaIcons The value of the enableRetinaIcons property.
 */
MarkerClusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {
  this.enableRetinaIcons_ = enableRetinaIcons;
};


/**
 * Returns the value of the <code>imageExtension</code> property.
 *
 * @return {string} The value of the imageExtension property.
 */
MarkerClusterer.prototype.getImageExtension = function () {
  return this.imageExtension_;
};


/**
 *  Sets the value of the <code>imageExtension</code> property.
 *
 *  @param {string} imageExtension The value of the imageExtension property.
 */
MarkerClusterer.prototype.setImageExtension = function (imageExtension) {
  this.imageExtension_ = imageExtension;
};


/**
 * Returns the value of the <code>imagePath</code> property.
 *
 * @return {string} The value of the imagePath property.
 */
MarkerClusterer.prototype.getImagePath = function () {
  return this.imagePath_;
};


/**
 *  Sets the value of the <code>imagePath</code> property.
 *
 *  @param {string} imagePath The value of the imagePath property.
 */
MarkerClusterer.prototype.setImagePath = function (imagePath) {
  this.imagePath_ = imagePath;
};


/**
 * Returns the value of the <code>imageSizes</code> property.
 *
 * @return {Array} The value of the imageSizes property.
 */
MarkerClusterer.prototype.getImageSizes = function () {
  return this.imageSizes_;
};


/**
 *  Sets the value of the <code>imageSizes</code> property.
 *
 *  @param {Array} imageSizes The value of the imageSizes property.
 */
MarkerClusterer.prototype.setImageSizes = function (imageSizes) {
  this.imageSizes_ = imageSizes;
};


/**
 * Returns the value of the <code>calculator</code> property.
 *
 * @return {function} the value of the calculator property.
 */
MarkerClusterer.prototype.getCalculator = function () {
  return this.calculator_;
};


/**
 * Sets the value of the <code>calculator</code> property.
 *
 * @param {function(Array.<google.maps.Marker>, number)} calculator The value
 *  of the calculator property.
 */
MarkerClusterer.prototype.setCalculator = function (calculator) {
  this.calculator_ = calculator;
};


/**
 * Returns the value of the <code>batchSizeIE</code> property.
 *
 * @return {number} the value of the batchSizeIE property.
 */
MarkerClusterer.prototype.getBatchSizeIE = function () {
  return this.batchSizeIE_;
};


/**
 * Sets the value of the <code>batchSizeIE</code> property.
 *
 *  @param {number} batchSizeIE The value of the batchSizeIE property.
 */
MarkerClusterer.prototype.setBatchSizeIE = function (batchSizeIE) {
  this.batchSizeIE_ = batchSizeIE;
};


/**
 * Returns the value of the <code>clusterClass</code> property.
 *
 * @return {string} the value of the clusterClass property.
 */
MarkerClusterer.prototype.getClusterClass = function () {
  return this.clusterClass_;
};


/**
 * Sets the value of the <code>clusterClass</code> property.
 *
 *  @param {string} clusterClass The value of the clusterClass property.
 */
MarkerClusterer.prototype.setClusterClass = function (clusterClass) {
  this.clusterClass_ = clusterClass;
};


/**
 *  Returns the array of markers managed by the clusterer.
 *
 *  @return {Array} The array of markers managed by the clusterer.
 */
MarkerClusterer.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 *  Returns the number of markers managed by the clusterer.
 *
 *  @return {number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function () {
  return this.markers_.length;
};


/**
 * Returns the current array of clusters formed by the clusterer.
 *
 * @return {Array} The array of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getClusters = function () {
  return this.clusters_;
};


/**
 * Returns the number of clusters formed by the clusterer.
 *
 * @return {number} The number of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getTotalClusters = function () {
  return this.clusters_.length;
};


/**
 * Adds a marker to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Adds an array of markers to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {
  var key;
  for (key in markers) {
    if (markers.hasOwnProperty(key)) {
      this.pushMarkerTo_(markers[key]);
    }
  }
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.pushMarkerTo_ = function (marker) {
  // If the marker is draggable add a listener so we can update the clusters on the dragend:
  if (marker.getDraggable()) {
    var cMarkerClusterer = this;
    google.maps.event.addListener(marker, "dragend", function () {
      if (cMarkerClusterer.ready_) {
        this.isAdded = false;
        cMarkerClusterer.repaint();
      }
    });
  }
  marker.isAdded = false;
  this.markers_.push(marker);
};


/**
 * Removes a marker from the cluster.  The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the
 *  marker was removed from the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if the marker was removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes an array of markers from the cluster. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers
 *  were removed from the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if markers were removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {
  var i, r;
  var removed = false;

  for (i = 0; i < markers.length; i++) {
    r = this.removeMarker_(markers[i]);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes a marker and returns true if removed, false if not.
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 */
MarkerClusterer.prototype.removeMarker_ = function (marker) {
  var i;
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        index = i;
        break;
      }
    }
  }

  if (index === -1) {
    // Marker is not in our list of markers, so do nothing:
    return false;
  }

  marker.setMap(null);
  this.markers_.splice(index, 1); // Remove the marker from the list of managed markers
  return true;
};


/**
 * Removes all clusters and markers from the map and also removes all markers
 *  managed by the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function () {
  this.resetViewport_(true);
  this.markers_ = [];
};


/**
 * Recalculates and redraws all the marker clusters from scratch.
 *  Call this after changing any properties.
 */
MarkerClusterer.prototype.repaint = function () {
  var oldClusters = this.clusters_.slice();
  this.clusters_ = [];
  this.resetViewport_(false);
  this.redraw_();

  // Remove the old clusters.
  // Do it in a timeout to prevent blinking effect.
  setTimeout(function () {
    var i;
    for (i = 0; i < oldClusters.length; i++) {
      oldClusters[i].remove();
    }
  }, 0);
};


/**
 * Returns the current bounds extended by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 * @ignore
 */
MarkerClusterer.prototype.getExtendedBounds = function (bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Redraws all the clusters.
 */
MarkerClusterer.prototype.redraw_ = function () {
  this.createClusters_(0);
};


/**
 * Removes all clusters from the map. The markers are also removed from the map
 *  if <code>opt_hide</code> is set to <code>true</code>.
 *
 * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
 *  from the map.
 */
MarkerClusterer.prototype.resetViewport_ = function (opt_hide) {
  var i, marker;
  // Remove all the clusters
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Reset the markers to not be added and to be removed from the map.
  for (i = 0; i < this.markers_.length; i++) {
    marker = this.markers_[i];
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }
};


/**
 * Calculates the distance between two latlng locations in km.
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {
  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Determines if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Adds a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.addToClosestCluster_ = function (marker) {
  var i, d, cluster, center;
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  for (i = 0; i < this.clusters_.length; i++) {
    cluster = this.clusters_[i];
    center = cluster.getCenter();
    if (center) {
      d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters. This is done in batches to avoid timeout errors
 *  in some browsers when there is a huge number of markers.
 *
 * @param {number} iFirst The index of the first marker in the batch of
 *  markers to be added to clusters.
 */
MarkerClusterer.prototype.createClusters_ = function (iFirst) {
  var i, marker;
  var mapBounds;
  var cMarkerClusterer = this;
  if (!this.ready_) {
    return;
  }

  // Cancel previous batch processing if we're working on the first batch:
  if (iFirst === 0) {
    /**
     * This event is fired when the <code>MarkerClusterer</code> begins
     *  clustering markers.
     * @name MarkerClusterer#clusteringbegin
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringbegin", this);

    if (typeof this.timerRefStatic !== "undefined") {
      clearTimeout(this.timerRefStatic);
      delete this.timerRefStatic;
    }
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  //
  // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
  if (this.getMap().getZoom() > 3) {
    mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),
      this.getMap().getBounds().getNorthEast());
  } else {
    mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
  }
  var bounds = this.getExtendedBounds(mapBounds);

  var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);

  for (i = iFirst; i < iLast; i++) {
    marker = this.markers_[i];
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
        this.addToClosestCluster_(marker);
      }
    }
  }

  if (iLast < this.markers_.length) {
    this.timerRefStatic = setTimeout(function () {
      cMarkerClusterer.createClusters_(iLast);
    }, 0);
  } else {
    delete this.timerRefStatic;

    /**
     * This event is fired when the <code>MarkerClusterer</code> stops
     *  clustering markers.
     * @name MarkerClusterer#clusteringend
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringend", this);
  }
};


/**
 * Extends an object's prototype by another's.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function (obj1, obj2) {
  return (function (object) {
    var property;
    for (property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * The default function for determining the label text and style
 * for a cluster icon.
 *
 * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.
 * @param {number} numStyles The number of marker styles available.
 * @return {ClusterIconInfo} The information resource for the cluster.
 * @constant
 * @ignore
 */
MarkerClusterer.CALCULATOR = function (markers, numStyles) {
  var index = 0;
  var title = "";
  var count = markers.length.toString();

  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index,
    title: title
  };
};


/**
 * The number of markers to process in one batch.
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE = 2000;


/**
 * The number of markers to process in one batch (IE only).
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE_IE = 500;


/**
 * The default root name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";


/**
 * The default extension name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_EXTENSION = "png";


/**
 * The default array of sizes for the marker cluster images.
 *
 * @type {Array.<number>}
 * @constant
 */
MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];

if (typeof String.prototype.trim !== 'function') {
  /**
   * IE hack since trim() doesn't exist in all browsers
   * @return {string} The string with removed whitespace
   */
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, '');
  }
}

    google.ClusterIcon = ClusterIcon;
    google.Cluster = Cluster;
    google.MarkerClusterer = MarkerClusterer;
};

window.google = window.google || {};

google.markerClustererExtend = function() {
    /**
     * Adds a marker to the cluster.
     *
     * @param {google.maps.Marker} marker The marker to be added.
     * @return {boolean} True if the marker was added.
     * @ignore
     */
    google.Cluster.prototype.addMarker = function (marker) {
        var i;
        var mCount;
        var mz;

        if (this.isMarkerAlreadyAdded_(marker)) {
            return false;
        }

        if (!this.center_) {
            this.center_ = marker.getPosition();
            this.calculateBounds_();
        } else {
            if (this.averageCenter_) {
                var l = this.markers_.length + 1;
                var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
                var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                this.center_ = new google.maps.LatLng(lat, lng);
                this.calculateBounds_();
            }
        }

        marker.isAdded = true;
        this.markers_.push(marker);

        mCount = this.markers_.length;
        mz = this.markerClusterer_.getMaxZoom();
        if (mz !== null && this.map_.getZoom() > mz) {
            // Zoomed in past max zoom, so show the marker.
            if (marker.getMap() !== this.map_) {
                marker.setMap(this.map_);
                if (marker.infoBox) {
                    marker.infoBox.open(this.map_);
                }
            }
        } else if (mCount < this.minClusterSize_) {
            // Min cluster size not reached so show the marker.
            if (marker.getMap() !== this.map_) {
                marker.setMap(this.map_);
                if (marker.infoBox) {
                    marker.infoBox.open(this.map_);
                }
            }
        } else if (mCount === this.minClusterSize_) {
            // Hide the markers that were showing.
            for (i = 0; i < mCount; i++) {
                this.markers_[i].setMap(null);
                if (this.markers_[i].infoBox) {
                    this.markers_[i].infoBox.close();
                }
            }
        } else {
            marker.setMap(null);
            if (marker.infoBox) {
                marker.infoBox.close();
            }
        }

        this.updateIcon_();
        return true;
    };


    /**
     * Removes all clusters from the map. The markers are also removed from the map
     *  if <code>opt_hide</code> is set to <code>true</code>.
     *
     * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
     *  from the map.
     */
    google.MarkerClusterer.prototype.resetViewport_ = function (opt_hide) {
        var i, marker;
        // Remove all the clusters
        for (i = 0; i < this.clusters_.length; i++) {
            this.clusters_[i].remove();
        }
        this.clusters_ = [];

        // Reset the markers to not be added and to be removed from the map.
        for (i = 0; i < this.markers_.length; i++) {
            marker = this.markers_[i];
            marker.isAdded = false;
            if (opt_hide) {
                marker.setMap(null);
                if (marker.infoBox) {
                    marker.infoBox.close();
                }
            }
        }
    };

};
;(function(window) {
    // Make it safe to use console.log always

    (function(a) {
        function b() {}
        var c = 'assert,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,time,timeEnd,trace,warn';
        var d;

        for (c = c.split(','); Boolean(d = c.pop());) {
            a[d] = a[d] || b;
        }
    })(function() {
        try {
            console.log();

            return window.console;
        } catch (a) {
            return (window.console = {});
        }
    }());
}(window));
;(function(window) {
    // A fix for window.location.origin in internet explorer

    if (!window.location.origin) {
        window.location.origin = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
    }
})(window);
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

/**
 * polyfill for :checked pseudo class. Created for support custom checkboxes and radios in ie8
 *
 * checkbox/radio DOM examples:
 * 1.   <input type="checkbox" class="hidden-input" id="input-id"/><label class="checkbox" for="input-id"></label>
 * 2.   <label>
 *          <input type="checkbox" class="hidden-input"/><span class="checkbox"></span>
 *      </label>
 */

;(function($, Modernizr) {
    if (isCheckedSupported()) {
        return ;
    }

    var DEFAULTS = {
        SELECTORS: {
            CHECKBOX: 'input:checkbox',
            RADIO: 'input:radio',
            CUSTOM_ELEMENTS: '.checkbox, .radio'
        },

        CHECKED_CLASS: 'checked',
        NOT_CHECKED_CLASS: 'not-checked'
    };

    $(document).on('change', DEFAULTS.SELECTORS.CHECKBOX, toggleCheckedClass)
        .on('change', DEFAULTS.SELECTORS.RADIO, toggleRadioCheckedClass);

    // Change checked state with $.prop method
    // don't trigger change event
    // so we need to toggle class after $.prop method executed
    var oldProp = $.fn.prop;

    $.fn.prop = function() {
        var result = oldProp.apply(this, arguments);

        if (arguments[0] === 'checked' && arguments[1]) {
            this.each(function() {
                if (this.type === 'radio') {
                    toggleRadioCheckedClass.call(this);
                } else {
                    toggleCheckedClass.call(this);
                }
            });
        }

        return result;
    };

    // Test was taken from https://github.com/Modernizr/Modernizr/pull/767
    function isCheckedSupported() {
        function testChecked(elem) {
            var cb = document.createElement('input');
            cb.setAttribute('type', 'checkbox');
            cb.setAttribute('checked', 'checked');
            elem.appendChild(cb);

            return cb.offsetLeft === 20;
        }

        var testCheckedStyles = '#modernizr {position:absolute} #modernizr input {margin-left:10px} #modernizr :checked {margin-left:20px;display:block}';

        return Modernizr.testStyles(testCheckedStyles, testChecked);
    }

    function toggleCheckedClass() {
        var $input = $(this);
        var checked = $input.prop('checked');

        $input.toggleClass(DEFAULTS.CHECKED_CLASS, checked);

        // Need for overwrite input[checked] styles
        $input.toggleClass(DEFAULTS.NOT_CHECKED_CLASS, !checked);

        // Force repaint
        // IE8 don't properly repaint elements with '+' selector.
        // For ex. input.checked + .checkbox
        $input.next(DEFAULTS.SELECTORS.CUSTOM_ELEMENTS)
            .css('display', 'none')
            .css('display', '');
    }

    function toggleRadioCheckedClass() {
        // 'this' is radio input
        $('input[name="' + this.name + '"]', this.form).each(toggleCheckedClass);
    }
})(window.jQuery, window.Modernizr);
;(function() {

    var app = this;

    app.COOKIES = {
        LOGGED_IN: 'SPC.loggedIn',
        COMPARE_LIST: 'SPC.compareList',
        MINI_CART: 'SPC.miniCart',
        REFERRER_URL: 'SPC.referrerUrl',
        REVIEW_VOTES_FOR_HELPFULNESS: 'SPC.reviewVotesForHelpfulness',
        PAGE_DATA: 'SPC.pageData',
        PREVIOUS_PAGE_DATA: 'SPC.previousPageData',
        QUEBEC_SHOWN: 'SPC.quebecShown',
        CTFS_REJECT: 'SPC.ctfsReject',
        LAST_PAYMENT_ATTEMPT_ORDER_ID: 'SPC.lastPaymentAttemptOrderId',
        COOKIE_ENABLED: 'SPC.cookieEnabled',
        FIND_IN_STORE_PREV_STORE: 'SPC.previousStore',
        SYNONYM_SEARCH: 'SPC.synonymSearch'
    };

    app.EVENTS = {
        LOG_IN: 'logIn',
        LOG_OUT: 'logOut',
        CONTINUE_CHECKOUT: 'continueCheckout',
        PRODUCT_GRID_LOADED: 'productGridLoaded',
        MY_ACCOUNT_SIDEBAR_READY: 'myAccountSidebarReady',
        UPDATE_CART: 'updateCart',
        UPDATE_CART_STATUS: 'updateCartStatus',
        CHANGE_PRODUCT_SKU: 'changeProductSku',
        CHANGE_PRODUCT_COLOR: 'changeProductColor',
        ADD_TO_COMPARE_LIST: 'addToCompareList',
        REMOVE_FROM_COMPARE_LIST: 'removeFromCompareList',
        MAP_LOADED: 'mapLoaded',
        SHOW_APPOINTMENT_STORE: 'showAppointmentStore',
        SHOW_SBA_FORM: 'showSbaForm',
        CHANGE_SHIPPING_SHIP_TO: 'changeShippingShipTo',
        BUNDLE_LIST_LOADED: 'bundleListLoaded',
        UPDATE_ORDER: 'updateOrder',
        UPDATE_CHECKOUT_ADDRESSES: 'updateCheckoutAddresses',
        SHOPPING_CART_INCONSISTENT: 'shoppingCartInconsistent',
        CLOSE_QUICK_VIEW: 'closeQuickView',
        SEARCH_LOCATION_ERROR: 'locationSearchError',
        SEARCH_LOCATION_SUCCESS: 'locationSearchSuccess',
        CLOSE_DRAWER: 'closeDrawer',
        VALIDATE_SKU_SELECTION: 'validateSkuSelection',
        PRICE_READY: 'priceReady',
        UPDATE_SUBS_DATA: 'subsData',
        OPEN_UNSUBSCRIBE_SECTION: 'openUnsubscribe',
        SET_SKU_UNSELLABLE: 'setSkuUnsellable',
        SET_AVAILABILITY_STATUS: 'setAvailabilityStatus',

        ANALYTICS: {
            PROCESS_CHECKOUT: 'analyticsProcessCheckout',
            PROCESS_EXPRESS_CHECKOUT: 'analyticsProcessExpressCheckout',
            PROCESS_PAYPAL_CHECKOUT: 'analyticsProcessPayPalCheckout',
            SHOPPING_CART_LOADED: 'analyticsShoppingCartLoaded',
            SUMMARY_ORDER: 'analyticsSummaryOrder',
            REMOVE_FROM_CART: 'analyticsRemoveFromCart',
            SHOW_REGISTER_MODAL: 'showRegisterModal',
            COMPLETE_REGISTER_MODAL: 'completeRegisterModal',
            SHOW_SIGNUP_MODAL: 'analyticsShowSignUpModal',
            SUBSCRIPTION_COMPLETE: 'analyticsSubscriptionComplete',
            PRODUCT_GRID_LOADED: 'analyticProductGridLoaded',
            FIND_IN_STORE: 'analyticsFindInStore',
            ADD_TO_CART: 'analyticsAddToCart',
            ADD_TO_WISHLIST: 'analyticsAddToWishlist',
            SHOW_WRITE_REVIEW_MODAL: 'analyticsShowWriteReviewModal',
            COMPLETE_WRITE_REVIEW_MODAL: 'analyticsCompleteWriteReviewModal',
            QUICK_VIEW_CLICKED: 'quickViewClicked'
        }
    };

    app.SESSION_VARS = {
        IS_WIDE_BANNER_CLOSED: 'isWideBannerClosed'
    };

    app.LOCAL_STORAGE = {
        SHIPPING_CONSIGNMENT_ADDRESSES: 'shippingConsignmentAddresses'
    };

}).call(window.SPC = window.SPC || {});

;(function(CQ, SPC, _, moment) {

    var helpers = this;

    var renderParameter = function(name, chunk, context, bodies, params) {
        if (params && params[name]) {
            if (typeof params[name] === 'function') {
                var output = '';

                chunk.tap(function(data) {
                    output += data;

                    return '';
                }).render(params[name], context).untap();

                return output;
            } else {
                return params[name];
            }
        }

        return '';
    };

    /**
     * {@i18n key="translateText" /}
     *
     * @param chunk
     * @param context
     * @param bodies
     * @param {Object} params
     * @returns {String}
     * @constructor
     */
    helpers.i18n = function(chunk, context, bodies, params) {
        var key = renderParameter('key', chunk, context, bodies, params);
        var snippets = renderParameter('snippets', chunk, context, bodies, params);
        var translation = CQ.I18n.get(key, snippets);

        return chunk.write(translation);
    };

    helpers.getFormattedPhoneNumber = function(chunk, context, bodies, params) {
        var fieldName = params && params.field || 'phone';
        var currentContext = context.current();
        var phone = currentContext[fieldName] || currentContext;

        phone = phone.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');

        return chunk.write(phone);
    };

    helpers.getRegion = function(chunk, context) {
        var provinces = SPC.PROVINCES;
        var states = SPC.STATES;
        var regions = provinces ? provinces.concat(states) : [];
        var regionIsoCode = context.current().name;

        var regionsResult = _.filter(regions, {isocode: regionIsoCode});

        var regionName = regionsResult && regionsResult.length ? regionsResult[0].name : regionIsoCode;

        return chunk.write(regionName);
    };

    helpers.getFormattedDate = function(chunk, context, bodies, params) {
        function findProperty(obj, key) {
            if (_.has(obj, key)) {
                return [obj[key]];
            }

            return _.flatten(_.map(obj, function(obj) {
                return typeof obj === 'object' ? findProperty(obj, key) : [];
            }), true);
        }

        var rawValue = findProperty(context.current(), params.fromProperty)[0];
        var toFormat = params.toFormat || 'MMMM DD, YYYY';
        var formattedValue = 'Date formatting error';

        if (rawValue) {
            formattedValue = moment(rawValue).format(toFormat);
        }

        return chunk.write(formattedValue);
    };

    helpers.sort = function(chunk, context, bodies, params) {
        var exclude = params.exclude;
        var objects = null;

        if (bodies.block) {
            if (exclude) {
                objects = _.filter(context.stack.head, function(object) {
                    if (object.type.indexOf(exclude) === -1) {
                        return object;
                    }
                });
            } else {
                objects = context.stack.head;
            }

            var sorted = _.sortBy(objects, params.by);

            for (var i = 0; i < sorted.length; i++) {
                chunk = bodies.block(chunk, context.push(sorted[i], i, sorted.length));
            }

            return chunk;
        } else {
            return this;
        }
    };

    /**
     * {@getLanguageRoot/}
     */
    helpers.getLanguageRoot = function(chunk) {
        return chunk.write(SPC.languageRoot);
    };

    /**
     * {@getLanguageRoot/}
     */
    helpers.getS7DefaultImageUrl = function(chunk) {
        return chunk.write(SPC.s7RootUrl + 'undefined');
    };

    /**
     * {@getImage url="imageURL"}
     *
     * @param chunk
     * @param context
     * @param bodies
     * @param {Object} params
     * @returns {String}
     * @constructor
     */
    helpers.getImage = function(chunk, context, bodies, params) {
        var key = renderParameter('url', chunk, context, bodies, params);

        if (!key) {
            key = SPC.s7RootUrl + 'undefined';
        }

        return chunk.write(key);
    };

    /**
     * {@getRating value="3.4"/}
     *
     * @param chunk
     * @param context
     * @param bodies
     * @param params
     * @returns {*}
     */
    helpers.getRating = function(chunk, context, bodies, params) {
        var value = renderParameter('value', chunk, context, bodies, params);

        return chunk.write(value * 20);
    };

    helpers.getStoreInventoryStatus = function(chunk, context) {
        var inventoryStatus = 'inventory.status.' + context.current().inventoryStatus;

        return chunk.write(CQ.I18n.get(inventoryStatus));
    };

    /**
     * {@getSubstring string="{string}" start="0" end="10"/}
     *
     * @param chunk
     * @param context
     * @param bodies
     * @param params
     * @returns {substring}
     */
    helpers.getSubstring = function(chunk, context, bodies, params) {
        var string = renderParameter('string', chunk, context, bodies, params);
        var start = renderParameter('start', chunk, context, bodies, params);
        var end = renderParameter('end', chunk, context, bodies, params);

        return chunk.write(string.slice(start, end));
    };
    /**
     * {@getPreparedFacetsPrice/}
     *
     * @param chunk
     * @param context
     * @returns formatted price for faccets
     */
    helpers.getPreparedFacetsPrice = function(chunk, context) {
        var lowerBound = context.current().lowerBound;
        var upperBound = context.current().upperBound;
        var MAX_RANGE_BOUND = context.current().MAX_RANGE_BOUND;
        var MIN_RANGE_BOUND = context.current().MIN_RANGE_BOUND;
        var result = '';

        if (!lowerBound && !upperBound) {

            return chunk.write(result);
        }

        result = '($';
        result += lowerBound || MIN_RANGE_BOUND;
        result += '-$';
        result += upperBound || (MAX_RANGE_BOUND + '+');
        result += ')';

        return chunk.write(result);
    };

}).call(window.dust.helpers = window.dust.helpers || {}, window.CQ, window.SPC || {}, window._, window.moment);

;(function(window, document, $, undefined) {

    var app = this;

    /**
     * Take an element and convert it and its contents into a module.
     *
     * This script expects the element to have a "data-module-type" attribute
     * specifying which module constructor to use.
     *
     * @param {HTMLElement} $element The containing element of the module.
     *
     * @return {object} The object representing the module.
     */

    app.createModule = function __createModule__($element) {
        var moduleTypes = $element.data('module-type').split(' ');
        var module = null;
        var modules = app.modules || {};
        var end;

        moduleTypes.forEach(function(moduleType) {

            if (app[moduleType] && typeof app[moduleType] === 'function') {
                try {
                    module = new app[moduleType]($element);

                    // Store a reference of the module object on the element
                    $.data($element[0], moduleType, module);

                    end = $.now();

                    // Log: console.log('', moduleType, 'module loaded in', end - start, 'ms.');
                } catch (e) {
                    console.error('Attempted to initialize a', moduleType, 'module using', $element[0], 'but there was an error:', e);
                }

            } else {
                console.error('Module', moduleType, 'not found');
            }

            if (module) {
                if (modules[moduleType] === undefined) {
                    modules[moduleType] = [];
                }

                modules[moduleType].push(module);
            }
        });

        app.modules = modules;
    };

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, _, undefined) {
    var app = this;

    app.createSubModule = function __createSubModule__($element, context) {
        $element.find('[data-module-type]').each(function() {
            var $subModules = $(this);

            var moduleTypes = $subModules.data('module-type').split(' ');
            var module = null;
            var end;

            moduleTypes.forEach(function(moduleType) {
                if (app[moduleType] && typeof app[moduleType] === 'function') {
                    try {
                        module = new app[moduleType]($subModules, context);

                        // Store a reference of the module object on the element
                        $.data($subModules[0], moduleType, module);

                        end = $.now();

                        // Log: console.log('  ', moduleType, 'submodule loaded in', end - start, 'ms.');
                    } catch (e) {
                        console.error('Attempted to initialize a', moduleType, 'submodule using', $subModules[0], 'but there was an error:', e);
                    }
                } else {
                    console.error('Submodule', moduleType, 'not found');
                }

                if (module) {
                    if (!context.subModules) {
                        context.subModules = {};
                    }

                    if (context.subModules[moduleType] === undefined) {
                        context.subModules[moduleType] = [];
                    }

                    context.subModules[moduleType].push(module);
                }
            });
        });

    };

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._);

;(function(window, document, $, _) {

    var app = this;

    app.observers = {};

    app.noop = function() {
        return '';
    };

    app.triggeredEvents = [];

    /**
     * Trigger an event and alert all observers of the event
     *
     * @param {string} eventType The type of the event to trigger.
     * @param {object} eventOptions An object with relevant named parameters
     *
     * @return The pubsub object.
     */
    app.trigger = function __trigger__(eventType, eventOptions, context, callback) {
        // Use a timeout to allow for events to be asynchronous
        setTimeout(function() {
            var observers = app.observers[eventType];
            var i;

            if (observers) {
                i = observers.length;

                while (i--) {
                    if (typeof observers[i] === 'function') {
                        try {
                            observers[i].call(context, eventOptions);
                        } catch (e) {
                            console.error('pubsub >> trigger >>', eventType, '>>', e);
                        }
                    }
                }
            }

            if (callback) {
                callback();
            }
        }, 0);

        app.triggeredEvents = _.union(app.triggeredEvents, [eventType]);

        return app;
    };

    /**
     * Subscribe to an event. Callback will be called and passed any
     * eventOptions when the event is triggered.
     *
     * @param {string} eventType The type of event to subscribe to.
     * @param {function} callback The function called when even triggered
     *
     * @return {Object} The pubsub object.
     */
    app.subscribe = function __subscribe__(eventType, callback) {
        var observers = app.observers;

        if (!(eventType in observers)) {
            observers[eventType] = [];
        }

        observers[eventType].push(callback);

        return app;
    };

    /**
     * Unsubscribe from an event.
     *
     * @param {string} eventType name of event subscribed to
     * @param {function} handler Function that is currently subscribed (optional)
     *
     * @return {Object} The pubsub object.
     */
    app.unsubscribe = function __unsubscribe__(eventType, handler) {
        var observers = app.observers[eventType];
        var i;

        if (observers && observers.length) {
            i = observers.length;

            while (i--) {
                if (!handler || observers[i] === handler) {
                    observers.splice(i, 1);
                }
            }
        }

        return app;
    };

    /**
     * Subscribe to an event then unsubscribe after the event is triggered once.
     *
     * @param {string} eventType The type of event to subscribe to.
     * @param {function} callback To be called when the event is triggered.
     *
     * @return {Object} The pubsub object.
     */
    app.once = function __once__(eventType, callback) {
        var wrappedCallback = function(eventOptions) {
            callback(eventOptions);
            app.unsubscribe(eventType, wrappedCallback);
        };

        this.subscribe(eventType, wrappedCallback);

        return app;
    };

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._);

;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            NAVIGATION_TITLE: 'meta[name="page-navigation-title"]'
        }
    };

    var Page = function Page() {
        var _this = this instanceof Page ? this : Object.create(Page.prototype);

        _this.elems = {
            $navigationTitle: $(DEFAULTS.SELECTORS.NAVIGATION_TITLE)
        };

        _this.initialize();

        return _this;
    };

    $.extend(Page.prototype, {
        initialize: function initialize() {
            this._saveData();
            this._bindEvents();
        },

        _bindEvents: function _bindEvents() {
            $(window).on('hashchange', $.proxy(this._saveData, this));
        },

        getPageData: function getPageData() {
            return {
                title: this.elems.$navigationTitle.attr('content'),
                href: window.location.href
            };
        },

        /**
         * Check current page in a cookie or not. Also can be extend for ignoring some pages (like 404)
         * @param {Object} pageData
         * @param {Object} savedData
         * @returns {Boolean}
         * @private
         */
        _isValidPage: function _isValidPage(pageData, savedData) {
            function getHref(href, splitter) {
                return href.split(splitter)[0];
            }

            var pageHref = getHref(pageData.href, '.html');
            var previousPageHref = getHref(savedData.href, '.html');

            return pageHref !== previousPageHref;
        },

        _handlePreviousData: function _handlePreviousData() {
            var savedCookieData = $.cookie(app.COOKIES.PAGE_DATA);
            var savedData = savedCookieData ? JSON.parse(savedCookieData) : null;

            if (savedCookieData && savedData) {
                var pageData = this.getPageData();

                if (this._isValidPage(pageData, savedData)) {
                    $.cookie(app.COOKIES.PREVIOUS_PAGE_DATA, savedCookieData, {
                        path: '/'
                    });
                }
            }
        },

        _saveData: function _saveData() {
            this._handlePreviousData();

            var pageData = this.getPageData();
            var pageCookieData = JSON.stringify(pageData);

            $.cookie(app.COOKIES.PAGE_DATA, pageCookieData, {
                path: '/'
            });
        },

        getPreviousData: function getPreviousData() {
            var previousData = $.cookie(app.COOKIES.PREVIOUS_PAGE_DATA);

            return previousData ? JSON.parse(previousData) : null;
        }
    });

    app.Page = Page;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $, _, pca, CQ) {
    var app = this;
    var DEFAULT = {
        SELECTORS: {
            ADDRESS_COMPLETER: '#address-completer',
            PCA_VALUE_OPTION_ATTRIBUTE: 'option[data-pca-value]'
        },
        DATA_ATTRIBUTES: {
            KEY: 'key',
            PCA_VALUE: 'pcaValue'
        },
        FIELDS: {
            ISO2: 'CountryIso2',
            ISO3: 'CountryIso3',
            COUNTRY_NAME: 'CountryName'
        },
        RESULTS_OPTIONS: {
            search: {
                maxSuggestions: 7,
                maxResults: 100
            },
            minItems: 1,
            maxItems: 9
        }
    };

    var AddressCompleter = function AddressCompleter(options) {
        var _this = this instanceof AddressCompleter ? this : Object.create(AddressCompleter.prototype);

        _this.options = $.extend({}, DEFAULT.RESULTS_OPTIONS, options);

        _this.elems = {
            $component: $(_this.options.element || DEFAULT.SELECTORS.ADDRESS_COMPLETER)
        };

        _this.initialize();

        return _this;
    };

    $.extend(AddressCompleter.prototype, {

        initialize: function initialize() {
            this.options.key = this.options.key || this.elems.$component.data(DEFAULT.DATA_ATTRIBUTES.KEY);

            if (!pca) {
                return;
            }

            this.canadaPostController = new pca.Address(this.options.fields, this.options);
            this.canadaPostController.autocomplete.list.setFooterItem({message: CQ.I18n.get('GLB0176')}, '{message}', this.canadaPostController.manualEntry);

            this.bindEvents();

            this.reorderCountryList(['Canada', 'United States']);
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.canadaPostController.listen('populate', $.proxy(_this.onPopulateCanadianPostController, _this));

            var fieldIso2 = _.find(this.options.fields, {field: DEFAULT.FIELDS.ISO2});
            var fieldIso3 = _.find(this.options.fields, {field: DEFAULT.FIELDS.ISO3});
            var fieldCountry = _.find(this.options.fields, {field: DEFAULT.FIELDS.COUNTRY_NAME});

            if (fieldIso2) {
                _this.canadaPostController.countrylist.listen('change', function(countryData) {
                    $('#' + fieldIso2.element).val(countryData.iso2).trigger('change');
                });
            }

            if (fieldIso3) {
                _this.canadaPostController.countrylist.listen('change', function(countryData) {
                    $('#' + fieldIso3.element).val(countryData.iso3).trigger('change', countryData.iso3);
                });
            }

            if (fieldCountry) {
                _this.canadaPostController.countrylist.listen('change', function(countryData) {
                    $('#' + fieldCountry.element).val(countryData.name).trigger('change', countryData.name);
                });
            }

        },

        onPopulateCanadianPostController: function onPopulateCanadianPostController(address) {
            this.options.fields.forEach(function(field) {
                // Need to use getElementById because of #country.name selector
                var element = document.getElementById(field.element);
                var $element = $(element);

                if ($element.is('select')) {
                    var value = address[field.field];
                    var $specialOptions = $element.find(DEFAULT.SELECTORS.PCA_VALUE_OPTION_ATTRIBUTE);

                    $specialOptions.each(function() {
                        var $option = $(this);

                        if ($option.data(DEFAULT.DATA_ATTRIBUTES.PCA_VALUE) === value) {
                            value = $option.val();

                            return false;
                        }
                    });

                    $element.val(value);
                }

                $element.trigger('change');
                $element.valid();
            });
        },

        /**
         * This method change a country order for country select
         * @parameter topCountryNames - the array of country names witch would  be up into top of list
         */
        reorderCountryList: function reorderCountryList(topCountryNames) {
            var countryItems =  this.canadaPostController.countrylist.autocomplete.list.collection.items;
            var topCountryItems = [];

            for (var i = 0; i < countryItems.length; i++) {
                if (_.contains(topCountryNames, countryItems[i].data.name)) {
                    topCountryItems.push(countryItems[i]);
                    countryItems.splice(i, 1);

                    if (topCountryItems.length === topCountryNames.length) {
                        break;
                    }
                }
            }

            // Insert into top
            this.canadaPostController.countrylist.autocomplete.list.collection.items = topCountryItems.concat(countryItems);

            this.canadaPostController.countrylist.autocomplete.list.draw();
        }
    });

    app.AddressCompleter = AddressCompleter;

    return app.AddressCompleter;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.pca, window.CQ);

;(function(window, document, $, dust) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            CLOSE_BUTTON: '.modal-information-window__close'
        }
    };

    /*
    * Examples:
    *
    * app.modules.Alert.openModal({title: 'title'});
    *
    * app.modules.Alert.openModal({title: 'title', description: 'description', buttonText: 'ok'}, callback);
    *
    * app.modules.Alert.openModal(templateData, callback, [,templateName])
    */

    var Alert = function Alert() {
        var _this = this instanceof Alert ? this : Object.create(Alert.prototype);

        _this.elems = {
            $component: $('body')
        };

        _this.bindEvents();

        return _this;
    };

    $.extend(Alert.prototype, {
        bindEvents: function bindEvents() {
            this.elems.$component.on('click', DEFAULTS.SELECTORS.CLOSE_BUTTON, function(e) {
                e.preventDefault();
                $.SpcMagnificPopup.close();
            });
        },

        /**
         * @param data {Object} template data
         * @param callback {Function}
         * @param templateName {String} templateName
         */
        openModal: function openModal(data, callback, templateName) {
            this.closeCallback = callback;
            this.render(data, templateName);
        },

        closeModal: function() {
            $.SpcMagnificPopup.close();
        },

        render: function render(data, templateName) {
            var _this = this;

            dust.render(templateName || 'alert', data, function(error, out) {
                $.SpcMagnificPopup.open({
                    items: {
                        src: out
                    },
                    callbacks: {
                        close: _this.closeCallback
                    }
                });
            });
        }
    });

    app.Alert = Alert;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust);
;(function(window, document, $, dust) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            CONFIRMATION_BUTTON: '.modal-confirm-window__button_ok',
            CANCELLATION_BUTTON: '.modal-confirm-window__button_cancel'
        }
    };

    /*
    * Examples:
    *
    * app.modules.Confirm.openModal({title: 'title'}, confirmationCallback);
    *
    * app.modules.Confirm.openModal({title: 'title', description: 'description', confirmText: 'ok', cancelText: 'cancel'}, confirmationCallback, cancellationCallback);
    *
    * app.modules.Confirm.openModal(templateData, confirmationCallback, cancellationCallback [,templateName]);
    */

    var Confirm = function Confirm() {
        var _this = this instanceof Confirm ? this : Object.create(Confirm.prototype);

        _this.elems = {
            $component: $('body')
        };

        _this.bindEvents();

        return _this;
    };

    $.extend(Confirm.prototype, {
        bindEvents: function() {
            this.elems.$component.on('click', DEFAULTS.SELECTORS.CONFIRMATION_BUTTON, $.proxy(this.resolve, this, 'confirmation'));
            this.elems.$component.on('click', DEFAULTS.SELECTORS.CANCELLATION_BUTTON, $.proxy(this.cancelButton, this, 'cancellation'));
        },

        /**
         * @param data {Object} template data
         * @param confirmationCallback {Function} confirm callback
         * @param cancellationCallback {Function} cancel callback
         * @param templateName {String} template name
         */
        openModal: function openModal(data, confirmationCallback, cancellationCallback, templateName) {
            this.confirmationCallback = confirmationCallback || $.noop;
            this.cancellationCallback = cancellationCallback || $.noop;
            this.settings = data;

            this.render(data, templateName);
        },

        render: function render(data, templateName) {
            dust.render(templateName || 'confirm', data, function(error, out) {
                $.SpcMagnificPopup.open({
                    items: {
                        src: out
                    }
                });

                // FIXME: remove
                $('.mfp-wrap').addClass('confirm-modal');
            });
        },

        /**
         * @param callbackType {String} 'confirmation' || 'cancellation'
         */
        resolve: function resolve(callbackType) {
            $.SpcMagnificPopup.close();
            this[callbackType + 'Callback']();
        },

        cancelButton: function cancelButton(callbackType, event) {
            if (!this.settings.cancelTextLink) {
                event.preventDefault();
            }

            this.resolve(callbackType);
        }
    });

    app.Confirm = Confirm;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust);
;(function(window, document, $, dust, Modernizr) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            CANCELLATION_BUTTON: '.modal-prompt-window__button_cancel',
            INPUT: '.modal-prompt-window__input',
            FORM: '.modal-prompt-window__form'
        },
        CLASSES: {
            MAIN: 'prompt-modal default-modal'
        }
    };

    /*
     * Examples:
     *
     * app.modules.Prompt.openModal({title: 'title'}, submissionCallback);
     *
     * app.modules.Prompt.openModal({title: 'title', description: 'description', confirmText: 'ok', cancelText: 'cancel'}, submissionCallback, cancellationCallback);
     *
     * app.modules.Prompt.openModal(templateData, submissionCallback, cancellationCallback [,templateName]);
     */

    var Prompt = function Prompt() {
        var _this = this instanceof Prompt ? this : Object.create(Prompt.prototype);

        _this.elems = {
            $component: $('body')
        };

        _this.popupInstance = $.SpcMagnificPopup.getInstance();

        _this.bindEvents();

        return _this;
    };

    $.extend(Prompt.prototype, {
        bindEvents: function() {
            this.elems.$component.on('submit', DEFAULTS.SELECTORS.FORM, $.proxy(this.resolve, this, 'submit'));
            this.elems.$component.on('click', DEFAULTS.SELECTORS.CANCELLATION_BUTTON, $.proxy(this.resolve, this, 'cancel'));
        },

        /**
         * @param data {Object} template data
         * @param submissionCallback {Function} submit callback
         * @param cancellationCallback {Function} cancel callback
         * @param templateName {String} template name
         */
        openModal: function openModal(data, submissionCallback, cancellationCallback, templateName) {
            this.submissionCallback = submissionCallback || $.noop;
            this.cancellationCallback = cancellationCallback || $.noop;
            this.data = data;
            this.templateName = templateName;

            this.render();
            this.initForm();
        },

        initForm: function initForm() {
            this.elems.$input = this.popupInstance.content.find(DEFAULTS.SELECTORS.INPUT);
            this.formBlocking = new app.FormBlocking(this.popupInstance.content.find(DEFAULTS.SELECTORS.FORM));

            var $input = this.elems.$input;

            if (!Modernizr.touch) {
                setTimeout(function() {
                    $input.focus();
                }, 50);
            }
        },

        render: function render() {
            dust.render(this.templateName || 'prompt', this.data, function(error, out) {
                $.SpcMagnificPopup.open({
                    mainClass: DEFAULTS.CLASSES.MAIN,
                    items: {
                        src: out
                    }
                });
            });
        },

        /**
         * @param type {String} type of resolution
         * @param event
         */
        resolve: function resolve(type, event) {
            var _this = this;
            var value = _this.elems.$input.val();

            event.preventDefault();

            if (type === 'submit') {
                $.when(_this.submissionCallback(value))
                    .done(function() {
                        $.SpcMagnificPopup.close();
                    });
            } else {
                $.SpcMagnificPopup.close();
                this.cancellationCallback();
            }
        }
    });

    app.Prompt = Prompt;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust, window.Modernizr);
;(function(window, document, Modernizr, $, Response) {

    var DEFAULTS = {
        SELECTORS: {
            FORM_FIELDS: 'input, textarea',
            BODY: 'body'
        },
        CLASSES: {
            MAIN: 'default-modal',
            IS_IOS: 'mfp-wrap_ios',
            IS_OPEN_MODAL: 'is-open-modal',
            BG_ABSOLUTE: 'mfp-bg_absolute'
        },
        KEY: 'sportchek-modal'
    };

    var elems = {
        $body: $(DEFAULTS.SELECTORS.BODY)
    };

    $.extend($.magnificPopup.defaults, {
        key: DEFAULTS.KEY,
        mainClass: DEFAULTS.CLASSES.MAIN,
        closeOnContentClick: false,
        closeOnBgClick: false,
        enableEscapeKey: true,
        fixedContentPos: true,
        callbacks: {
            beforeClose: function() {
                elems.$body.removeClass(DEFAULTS.CLASSES.IS_OPEN_MODAL);
            }
        }
    });

    $.SpcMagnificPopup = {
        open: function open() {
            $.magnificPopup.open(arguments[0]);

            if ($.magnificPopup.instance.isIOS) { // Fix for background on ipad when keyboard opened
                $.magnificPopup.instance.bgOverlay.addClass(DEFAULTS.CLASSES.BG_ABSOLUTE);
                $.magnificPopup.instance.wrap.addClass(DEFAULTS.CLASSES.IS_IOS);
                elems.$body.addClass(DEFAULTS.CLASSES.IS_OPEN_MODAL);
            }
        },

        close: function close() {
            $.magnificPopup.close(arguments[0]);
        },

        getInstance: function getInstance() {
            return $.magnificPopup.instance;
        }
    };

}).call(window.SPC = window.SPC || {}, window, document, window.Modernizr, window.jQuery, window.Response);
/* jshint ignore:start */
// jscs:disable
var triggermail=triggermail||[];triggermail.load=function(a)
{var b=document.createElement("script");b.type="text/javascript";b.async=!0;b.src=("https:"===document.location.protocol?"https://":"http://")+"www.bluecore.com/triggermail.js/"+a+".js";a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a)}
;triggermail.load("fgl_sports");window.triggermail=triggermail;
// jscs:enable
/* jshint ignore:end */

;(function(window, $, _) {
    var app = this;

    var DEFAULTS = {
        REGEXP: {
            PRODUCT_TITLE: /[^a-zA-Z0-9-\.\s]*/gi,
            CURRENCY: /[^0-9\.]*/gi
        },
        FILTER_PRICE: {
            LOWER: {
                KEY: 'priceLowerBound',
                TITLE: 'lower price'
            },
            UPPER: {
                KEY: 'priceUpperBound',
                TITLE: 'upper price'
            }
        }
    };

    var SPCAnalyticHelpers = function SPCAnalyticHelpers() {
        var _this = this instanceof SPCAnalyticHelpers ? this : Object.create(SPCAnalyticHelpers.prototype);

        return _this;
    };

    $.extend(SPCAnalyticHelpers.prototype, {
        cleanProductTitle: function cleanProductTitle(title) {
            return title.replace(DEFAULTS.REGEXP.PRODUCT_TITLE, '');
        },

        cleanCurrency: function cleanCurrency(currency) {
            return currency.replace(DEFAULTS.REGEXP.CURRENCY, '');
        },

        /**
         * Used in addToCart
         * @param sku
         * @param entries
         * @returns {*}
         * @private
         */
        getProductTitle: function getProductTitle(sku, entries) {
            var res = '';

            try {
                var elem = _.find(entries, function(item) {
                    return item.product.code === sku;
                });

                if (!elem) {
                    return '';
                }

                if (elem.product.productTitle) {
                    res = elem.product.productTitle;
                } else {
                    if (elem.product.baseProduct.productTitle) {
                        res = elem.product.baseProduct.productTitle;
                    } else {
                        res = elem.product.baseProduct.name;
                    }
                }
            } catch (err) {
                console.error('app.AnalyticsHelpers.getProductTitle >> ' + err);
            }

            return this.cleanProductTitle(res);
        },

        /**
         * This method returns the string basing on the information about the product
         * @param  {Object} data
         * @param  {String} extended - define format string, if it equal 'productsString' then
         * result string contain information about quantity and price of product.
         * Otherwise it contain only product code and product title informatiom (it used by default).
         * @returns {String}
         */
        getFormattedProducts: function getFormattedProducts(data, extended) {
            var products = [];
            var cleanTitle = '';
            var extendString = '';
            var _this = this;

            try {
                data.entries.forEach(function(item) {
                    extendString = extended ? ';' + item.quantity + ';' + item.totalPrice.value : '';
                    cleanTitle = _this.cleanProductTitle(item.product.baseProduct.name);
                    products.push(';' + item.product.baseProduct.code + ': ' + cleanTitle + extendString);
                });
            } catch (err) {
                console.err('app.AnalyticsHelpers.getFormattedProducts >> ' + err);
            }

            return products.join(',');
        },

        /**
         * @returns {String} formated string with current date in format mm/dd/yyy
         */
        getFormattedDate: function getFormattedDate() {
            var formattedDate = '';
            var dateObject = new Date();

            formattedDate += ('0' + (dateObject.getMonth() + 1)).slice(-2) + '/';
            formattedDate += ('0' + dateObject.getDate()).slice(-2) + '/';
            formattedDate += dateObject.getFullYear();

            return formattedDate;
        },

        /**
         * Returns string with facets
         * @returns {string}
         * @private
         */
        getSearchFilter: function getSearchFilter() {
            var searchParams = $.bbq.getState();
            var filters = [];

            try {
                for (var key in searchParams) {
                    if (searchParams.hasOwnProperty(key)) {
                        if (key.charAt(0) === 'q' && key.length > 1) {
                            filters.push(searchParams[key.replace('q', 'x')] + ': ' + searchParams[key]);
                        } else if (key === DEFAULTS.FILTER_PRICE.LOWER.KEY) {
                            filters.push(DEFAULTS.FILTER_PRICE.LOWER.TITLE + ': ' + searchParams[key]);
                        } else if (key === DEFAULTS.FILTER_PRICE.UPPER.KEY) {
                            filters.push(DEFAULTS.FILTER_PRICE.UPPER.TITLE + ': ' + searchParams[key]);
                        }
                    }
                }
            } catch (err) {
                console.error('app.AnalyticsHelpers.getSearchFilter >> ' + err);
            }

            return filters.join(', ');
        }
    });

    app.SPCAnalyticHelpers = SPCAnalyticHelpers;

}).call(window.SPC = window.SPC || {}, window, window.jQuery, window._);
;(function(window, $, _, CQ, _satellite) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            BODY: 'body',
            WISHLIST_ELEMENT: '[data-module-type="AddToWishList"]',
            WISHLIST_BUTTON: 'button.wishlist',
            FIND_IN_STORE_BUTTON: 'button[data-module-type="FindInStore"]',
            PRODUCT_DETAIL_CLASS: '.product-detail',
            PRODUCT_TITLE: '.global-page-header__title',
            SYNONYM_LINK: '.search-content .no-results__text a',
            PRODUCT_GRID_LIST_ITEM: '.product-grid__list-item',
            PRODUCT_GRID_LIST_LINK: '.product-grid__link'
        },
        CSS_MODIFIERS: {
            SUBCATEGORY_PAGE: 'subcategory'
        },
        SERVICES: {
            PRODUCT_INFO: '/services/sportchek/findInStore/skus'
        },
        COOKIES: {
            FIRST_VISIT: 'DTM.firstVisit',
            IS_CUSTOMER: 'DTM.isCustomer'
        },
        VISITOR_STATUS: {
            FIRST_DAY_NOT_CUSTOMER: 'First Day Visit: Not Customer',
            FIRST_DAY_CUSTOMER: 'First Day Visit: Customer',
            POST_FIRST_DAY_NOT_CUSTOMER: 'Post First Day Visit: Not Customer',
            POST_FIRST_DAY_CUSTOMER: 'Post First Day Visit: Customer'
        },
        STRINGS: {
            SEARCH_EMPTY_RESULT: 'Zero',
            ANONYMOUS: 'anonymous'
        }
    };

    var DTM_DATA = {
        GLOBAL: {},
        HOME_PAGE: {},
        PRODUCT_DESCRIPTION_PAGE: {},
        PRODUCT_LIST_PAGE: {},
        CATEGORY_PAGE: {},
        SEARCH_RESULTS_PAGE: {},
        SHOPPING_CART_PAGE: {},
        CONFIRMATION_PAGE: {}
    };

    var SPCAnalytics = function SPCAnalytics() {
        var _this = this instanceof SPCAnalytics ? this : Object.create(SPCAnalytics.prototype);

        _this.initialize();

        return _this;
    };

    $.extend(SPCAnalytics.prototype, {
        initialize: function initialize() {
            this.elems = {
                $body: $(DEFAULTS.SELECTORS.BODY)
            };

            this.analyticsHelper = app.modules.SPCAnalyticHelpers;
            this.checkoutClicked = false;

            this.bindEvents();
            this.allPages();
        },

        bindEvents: function bindEvents() {
            // PDP
            app.subscribe(app.EVENTS.ANALYTICS.ADD_TO_WISHLIST, $.proxy(this.addToWishlist, this));
            app.subscribe(app.EVENTS.ANALYTICS.ADD_TO_CART, $.proxy(this.addToCart, this));
            app.subscribe(app.EVENTS.ANALYTICS.FIND_IN_STORE, $.proxy(this.findInStore, this));
            app.subscribe(app.EVENTS.ANALYTICS.SHOW_WRITE_REVIEW_MODAL, $.proxy(this.productReviewStarted, this));
            app.subscribe(app.EVENTS.ANALYTICS.COMPLETE_WRITE_REVIEW_MODAL, $.proxy(this.productReviewCompleted, this));

            // Shopping-cart
            app.subscribe(app.EVENTS.UPDATE_CART, $.proxy(this._setCartData, this));
            app.subscribe(app.EVENTS.ANALYTICS.SHOPPING_CART_LOADED, $.proxy(this.shoppingCartPageView, this));
            app.subscribe(app.EVENTS.ANALYTICS.REMOVE_FROM_CART, $.proxy(this.removeFromCart, this));

            app.subscribe(app.EVENTS.ANALYTICS.PROCESS_CHECKOUT, $.proxy(this.clickOnCheckout, this));
            app.subscribe(app.EVENTS.ANALYTICS.PROCESS_PAYPAL_CHECKOUT, $.proxy(this.payPalCheckout, this));

            app.subscribe(app.EVENTS.ANALYTICS.SUMMARY_ORDER, $.proxy(this.paymentConfirmation, this));

            // Search page (all types of search and search-result clicks listen this event)
            app.subscribe(app.EVENTS.ANALYTICS.PRODUCT_GRID_LOADED, $.proxy(this.siteSearchPerformed, this));
            $(document).on('click', DEFAULTS.SELECTORS.PRODUCT_GRID_LIST_LINK, $.proxy(this.searchResultClicked, this));
            $(document).on('click', DEFAULTS.SELECTORS.PRODUCT_GRID_LIST_LINK, $.proxy(this._debounceLocation, this));

            // Global
            app.subscribe(app.EVENTS.ANALYTICS.SHOW_REGISTER_MODAL, $.proxy(this.registerUserStart, this));
            app.subscribe(app.EVENTS.ANALYTICS.COMPLETE_REGISTER_MODAL, $.proxy(this.registerUserComplete, this));
            app.subscribe(app.EVENTS.ANALYTICS.SHOW_SIGNUP_MODAL, $.proxy(this.emailSignUpStart, this));
            app.subscribe(app.EVENTS.ANALYTICS.SUBSCRIPTION_COMPLETE, $.proxy(this.eEmailSignUpComplete, this));
            app.subscribe(app.EVENTS.ANALYTICS.QUICK_VIEW_CLICKED, $.proxy(this.quickViewClicked, this));
        },

        allPages: function allPages() {
            app.analyticsObject = app.analyticsObject || {pageHierarchy: [], pageType: ''};
            var exceptedPages = app.modules.ConfirmationOrderSummary || app.modules.LocationsAnalytics;

            if (!exceptedPages) {
                try {
                    var breadcrumb = _.values(app.analyticsObject.pageHierarchy);

                    var firstVisitString = $.cookie(DEFAULTS.COOKIES.FIRST_VISIT);

                    if (!firstVisitString) {
                        $.cookie(DEFAULTS.COOKIES.FIRST_VISIT, new Date(), {
                            expires: 10000,
                            path: '/'
                        });
                        $.cookie(DEFAULTS.COOKIES.IS_CUSTOMER, false, {
                            expires: 10000,
                            path: '/'
                        });
                        DTM_DATA.GLOBAL.visitorStatus = DEFAULTS.VISITOR_STATUS.FIRST_DAY_NOT_CUSTOMER;
                    } else {
                        var oneDay = 24 * 60 * 60 * 1000;
                        var today = new Date();
                        var firstVisit = new Date($.cookie(DEFAULTS.COOKIES.FIRST_VISIT));
                        var diffDays = Math.round(Math.abs((firstVisit.getTime() - today.getTime()) / (oneDay)));
                        var localIsCustomer = $.cookie(DEFAULTS.COOKIES.IS_CUSTOMER);

                        if (diffDays > 1 && localIsCustomer === 'false') {
                            DTM_DATA.GLOBAL.visitorStatus = DEFAULTS.VISITOR_STATUS.POST_FIRST_DAY_NOT_CUSTOMER;
                        } else if (diffDays <= 1 && localIsCustomer === 'false') {
                            DTM_DATA.GLOBAL.visitorStatus = DEFAULTS.VISITOR_STATUS.FIRST_DAY_NOT_CUSTOMER;
                        } else if (diffDays > 1 && localIsCustomer === 'true') {
                            DTM_DATA.GLOBAL.visitorStatus = DEFAULTS.VISITOR_STATUS.POST_FIRST_DAY_CUSTOMER;
                        } else if (diffDays <= 1 && localIsCustomer === 'true') {
                            DTM_DATA.GLOBAL.visitorStatus = DEFAULTS.VISITOR_STATUS.FIRST_DAY_CUSTOMER;
                        }
                    }

                    var previousPage = '';

                    // TODO: use session storage instead of complicated condition
                    if (app.modules.Page.getPreviousData() && document.referrer.split('/')[2] === window.location.hostname) {
                        previousPage = app.modules.Page.getPreviousData().title;
                    }

                    DTM_DATA.GLOBAL.previousPageName = previousPage;
                    DTM_DATA.GLOBAL.channel = breadcrumb.join(' / ');
                    DTM_DATA.GLOBAL.cattegoryPath = breadcrumb.length ? breadcrumb[breadcrumb.length - 1] : '';
                    DTM_DATA.GLOBAL.pageType = app.analyticsObject.pageType;

                    _satellite.track('_all_pages');
                } catch (e) {
                    console.error('SPCAnalytics.allPages >> ', e);
                }
            }
        },

        addToWishlist: function addToWishlist(data) {
            try {
                var $addToWishlistButton = $(DEFAULTS.SELECTORS.WISHLIST_ELEMENT).find(DEFAULTS.SELECTORS.WISHLIST_BUTTON);
                var _this = this;

                // FIXME: product name should arrive in data, but currently service doesn't return it
                // we have to get it from selector or separate service
                if ($addToWishlistButton.length) {
                    var $wrapper = $addToWishlistButton.closest(DEFAULTS.SELECTORS.PRODUCT_DETAIL_CLASS);

                    if ($wrapper.length > 0) {
                        var textTitle = $wrapper.find(DEFAULTS.SELECTORS.PRODUCT_TITLE).text();
                        var cleanTitle = this.analyticsHelper.cleanProductTitle(textTitle);

                        DTM_DATA.GLOBAL.wishlistProductId = data.code + ': ' + cleanTitle;

                        _satellite.track('_add_to_wishlist');
                    }

                } else {
                    var requestData = [{
                        sku: data.sku,
                        product: data.code,
                        locale: CQ.I18n.getLocale()
                    }];

                    $.ajax({
                        url: DEFAULTS.SERVICES.PRODUCT_INFO,
                        data: JSON.stringify(requestData),
                        type: 'POST',
                        contentType: 'application/json',
                        dataType: 'JSON',

                        success: function(skuData) {
                            var cleanTitle = _this.analyticsHelper.cleanProductTitle(skuData[0].productTitle);

                            DTM_DATA.GLOBAL.wishlistProductId = data.code + ': ' + cleanTitle;

                            _satellite.track('_add_to_wishlist');
                        },
                        error: function(jqXhr, textStatus, errorThrown) {
                            console.error('SPCAnalytics.addToWishlist >> ' + jqXhr.status + ' (' + errorThrown + ')');
                        }
                    });
                }
            } catch (e) {
                console.error('SPCAnalytics.addToWishlist >> ', e);
            }
        },

        _getProductCodeBySku: function _getProductCodeBySku(sku, entries) {
            var elem = _.find(entries, function(item) {
                return item.product.code === sku;
            });

            if (!elem) {
                return '';
            }

            return elem.product.baseProduct.code;
        },

        addToCart: function addToCart(data) {
            try {
                var productIds = [];
                var entries = data.entries;
                var _this = this;

                app.analyticsObject = app.analyticsObject || {pageHierarchy: [], pageType: ''};

                data.skus.forEach(function(sku) {
                    productIds.push(_this._getProductCodeBySku(sku, entries) + ': ' + _this.analyticsHelper.getProductTitle(sku, entries));
                });

                DTM_DATA.GLOBAL.addToCartId = productIds.join(',;');
                DTM_DATA.PRODUCT_DESCRIPTION_PAGE.currentDate = _this.analyticsHelper.getFormattedDate();
                DTM_DATA.GLOBAL.addedToCartFrom = app.analyticsObject.pageType;

                _satellite.track('_add_to_cart');

            } catch (e) {
                console.error('SPCAnalytics.addToCart >> ', e);
            }
        },

        findInStore: function findInStore(data) {
            try {
                var $findInStore = $(DEFAULTS.SELECTORS.FIND_IN_STORE_BUTTON);
                var _this = this;

                // FIXME: product name should arrive in data, but currently service doesn't return it
                // we have to get it from selector or separate service
                if ($findInStore.length) {
                    var $wrapper = $findInStore.closest(DEFAULTS.SELECTORS.PRODUCT_DETAIL_CLASS);

                    if ($wrapper.length > 0) {
                        var textTitle = $wrapper.find(DEFAULTS.SELECTORS.PRODUCT_TITLE).text();
                        var cleanTitle = this.analyticsHelper.cleanProductTitle(textTitle);

                        DTM_DATA.GLOBAL.findInStoreId = data.code + ': ' + cleanTitle;

                        _satellite.track('_find_in_store_click');
                    }

                } else {
                    var requestData = [{
                        sku: data.sku,
                        product: data.code,
                        locale: CQ.I18n.getLocale()
                    }];

                    $.ajax({
                        url: DEFAULTS.SERVICES.PRODUCT_INFO,
                        data: JSON.stringify(requestData),
                        type: 'POST',
                        contentType: 'application/json',
                        dataType: 'JSON',

                        success: function(skuData) {
                            var cleanTitle = _this.analyticsHelper.cleanProductTitle(skuData[0].productTitle);

                            DTM_DATA.GLOBAL.findInStoreId = data.code + ': ' + cleanTitle;

                            _satellite.track('_find_in_store_click');
                        },
                        error: function(jqXhr, textStatus, errorThrown) {
                            console.error('SPCAnalytics.findInStore >> ' + jqXhr.status + ' (' + errorThrown + ')');
                        }
                    });
                }
            } catch (e) {
                console.error('SPCAnalytics.findInStore >> ', e);
            }
        },

        productReviewStarted: function productReviewStarted() {
            _satellite.track('_product_review_started');
        },

        productReviewCompleted: function productReviewCompleted(data) {
            try {
                DTM_DATA.PRODUCT_DESCRIPTION_PAGE.rating = parseInt(data.rating, 10);

                // jscs:disable
                /* jshint ignore:start */
                var cleanTitle = this.analyticsHelper.cleanProductTitle(app.modules.Page.getPageData().title);

                DTM_DATA.PRODUCT_DESCRIPTION_PAGE.productId = ';' + data.page_id + ': ' + cleanTitle;
                /* jshint ignore:end */
                // jscs:enable

                _satellite.track('_product_review_submit');
            } catch (e) {
                console.error('SPCAnalytics.productReviewCompleted >> ' + e.message);
            }
        },

        _setCartData: function _setCartData(data) {
            this.cartData = data;
        },

        shoppingCartPageView: function shoppingCartPageView(data) {
            DTM_DATA.SHOPPING_CART_PAGE.ProductIds = this.analyticsHelper.getFormattedProducts(data);
            _satellite.track('_shopping_cart_pageview');
        },

        removeFromCart: function removeFromCart(entryNumber) {
            var index = _.findIndex(this.cartData.entries, function(entry) {
                return entry.entryNumber === entryNumber;
            });

            this.cartData.entries = [this.cartData.entries[index]];

            DTM_DATA.removeProductFromCartProductIds = this.analyticsHelper.getFormattedProducts(this.cartData);

            _satellite.track('_remove_products_from_cart');
        },

        clickOnCheckout: function clickOnCheckout() {
            if (!this.checkoutClicked) {
                this.checkoutClicked = true;

                try {
                    DTM_DATA.SHOPPING_CART_PAGE.shoppingCartCheckoutProducts = this.analyticsHelper.getFormattedProducts(this.cartData);
                    _satellite.track('_shopping_cart_checkout_clicked');

                } catch (e) {
                    console.error('SPCAnalytics.clickOnCheckout >> ', e);
                }
            }
        },

        payPalCheckout: function payPalCheckout() {

            try {
                DTM_DATA.SHOPPING_CART_PAGE.productsIds = this.analyticsHelper.getFormattedProducts(this.cartData);

                _satellite.track('_paypal_checkout_clicked');
            } catch (e) {
                console.error('SPCAnalytics.payPalCheckout >> ' + e.message);
            }
        },

        paymentConfirmation: function paymentConfirmation(data) {
            var checkPaymentMethod = function(paymentInfo) {
                return paymentInfo && paymentInfo.cardType ? paymentInfo.cardType : '';
            };

            try {
                $.cookie(DEFAULTS.COOKIES.IS_CUSTOMER, true, {
                    expires: 10000,
                    path: '/'
                });

                var products = _.pluck(data.entries, 'product');
                var skus = _.pluck(products, 'code');
                var userInfo = app.modules.User.get();
                var orderLevelDiscountInfo = '';
                var orderLevelDiscountValue = data.totalDiscounts.value;

                if (orderLevelDiscountValue > 0) {
                    orderLevelDiscountInfo = ',event16=' + orderLevelDiscountValue + ',event17';
                }

                DTM_DATA.CONFIRMATION_PAGE.EventsString = 'purchase,event8=' + data.deliveryCost.value + orderLevelDiscountInfo;
                DTM_DATA.CONFIRMATION_PAGE.Products = this.analyticsHelper.getFormattedProducts(data, true);
                DTM_DATA.CONFIRMATION_PAGE.PurchaseId = data.code;
                DTM_DATA.CONFIRMATION_PAGE.List1 = skus.join(', ');
                DTM_DATA.CONFIRMATION_PAGE.PaymentMethod = checkPaymentMethod(data.paymentInfo);
                DTM_DATA.CONFIRMATION_PAGE.ShippingMethod = data.consignments[0].deliveryMode.name;
                DTM_DATA.CONFIRMATION_PAGE.IsGuest = userInfo.uid ? 'Registered' : 'Guest';
                DTM_DATA.CONFIRMATION_PAGE.CustomerId = userInfo.uid || DEFAULTS.STRINGS.ANONYMOUS;
                DTM_DATA.CONFIRMATION_PAGE.Date = this.analyticsHelper.getFormattedDate();
                DTM_DATA.CONFIRMATION_PAGE.eVar38 = '+1';
                DTM_DATA.CONFIRMATION_PAGE.OrderTotal = '+' + data.totalPrice.value;

                _satellite.track('_payment_confirmation_page');

            } catch (e) {
                console.error('SPCAnalytics.paymentConfirmation >> ', e);
            }

        },

        siteSearchPerformed: function siteSearchPerformed(data) {
            try {
                if (!data.q) {
                    return;
                }

                var synonymSearchParams = $.cookie(app.COOKIES.SYNONYM_SEARCH);
                var filters = this.analyticsHelper.getSearchFilter();

                DTM_DATA.SEARCH_RESULTS_PAGE.totalResults = data.resultCount.total ? data.resultCount.total.toString() : DEFAULTS.STRINGS.SEARCH_EMPTY_RESULT;

                if (DTM_DATA.SEARCH_RESULTS_PAGE.searchTerm !== data.q || !DTM_DATA.SEARCH_RESULTS_PAGE.searchTerm || filters) {
                    DTM_DATA.SEARCH_RESULTS_PAGE.searchTerm = data.q;

                    if (synonymSearchParams) {
                        var params = JSON.parse(synonymSearchParams);
                        DTM_DATA.SEARCH_RESULTS_PAGE.originalSearchTerm = params.originalSearchTerm;
                    } else {
                        DTM_DATA.SEARCH_RESULTS_PAGE.originalSearchTerm = '';
                    }

                    if (filters) {
                        DTM_DATA.SEARCH_RESULTS_PAGE.filterClicked = filters;
                    }

                    if (synonymSearchParams && filters) {
                        _satellite.track('_search_filter_clicked_synonym');
                    } else if (synonymSearchParams && !filters && !data.resultCount.total) {
                        _satellite.track('_unique_search_from_suggestion_no_results');
                    } else if (synonymSearchParams && !filters && data.resultCount.total) {
                        _satellite.track('_unique_search_from_suggestion');
                    } else if (!synonymSearchParams && filters) {
                        _satellite.track('_search_filter_clicked');
                    } else if (!synonymSearchParams && !filters && !data.resultCount.total) {
                        _satellite.track('_unique_search_no_results');
                    } else if (!synonymSearchParams && !filters && data.resultCount.total) {
                        _satellite.track('_unique_search_vanilla');
                    }

                    if (synonymSearchParams) {
                        $.removeCookie(app.COOKIES.SYNONYM_SEARCH, {
                            path: '/'
                        });
                    }
                }

                this._checkSynonymSearch(data);
            } catch (e) {
                console.error('SPCAnalytics.siteSearchPerformed >> ' + e.message);
            }
        },

        /**
         * Function checks if synonym search was suggested
         * and sets appropriate cookie when user cliks on synonym link
         * @param data
         * @private
         */
        _checkSynonymSearch: function _checkSynonymSearch(data) {
            if (!data.resultCount.total && data.suggestion) {
                this.synonymSearchOptions = {
                    searchTerm: data.suggestion,
                    originalSearchTerm: data.q
                };

                var _this = this;

                $(DEFAULTS.SELECTORS.SYNONYM_LINK).on('click', function(e) {
                    e.preventDefault();

                    var url = $(DEFAULTS.SELECTORS.SYNONYM_LINK).attr('href');

                    $.cookie(app.COOKIES.SYNONYM_SEARCH, JSON.stringify(_this.synonymSearchOptions), {
                        path: '/'
                    });

                    // NOTE: We use this because _satellite track makes async call to analytics server
                    var redirect = _.debounce(function() {
                        window.location.replace(url);
                    }, 300);

                    redirect();
                });
            }
        },

        searchResultClicked: function searchResultClicked(event) {
            var uniqueClickCheckJSON;
            var $gridItem = $(event.target).parents(DEFAULTS.SELECTORS.PRODUCT_GRID_LIST_ITEM);
            var clickedPosition = $gridItem.data('id') + 1;
            var uniqueClick;

            try {
                uniqueClickCheckJSON = JSON.parse($.cookie(app.COOKIES.PREVIOUS_PAGE_DATA));
            } catch (e) {
                console.error('SPCAnalytics.searchResultClicked >> invalid json');
            }

            if (uniqueClickCheckJSON) {
                var prevVisitedPageHref = uniqueClickCheckJSON.href;
                var clickedLinkHref = $gridItem.find('a').attr('href').toLowerCase();

                prevVisitedPageHref = prevVisitedPageHref.split(window.location.host)[1].toLowerCase();

                uniqueClick = (prevVisitedPageHref === clickedLinkHref) ? false : true;
            }

            if (this.elems.$body.hasClass(DEFAULTS.CSS_MODIFIERS.SUBCATEGORY_PAGE)) {
                DTM_DATA.CATEGORY_PAGE.clickedCategoryListingPosition = clickedPosition;
                DTM_DATA.CATEGORY_PAGE.uniqueClick = uniqueClick;
                _satellite.track('_product_category_box_clicked');
            } else {
                DTM_DATA.SEARCH_RESULTS_PAGE.clickedSearchResultPosition = clickedPosition;
                DTM_DATA.SEARCH_RESULTS_PAGE.uniqueClick = uniqueClick;

                if (DTM_DATA.SEARCH_RESULTS_PAGE.synonymSearched) {
                    _satellite.track('_search_result_synonym_clicked');
                } else {
                    _satellite.track('_search_result_clicked');
                }
            }
        },

        _debounceLocation: function _debounceLocation(e) {
            var url = $(e.currentTarget).prop('href');

            if (url) {
                e.preventDefault();

                var redirect = _.debounce(function() {
                    window.location.assign(url);
                }, 300);

                redirect();
            }
        },

        quickViewClicked: function quickViewClicked(data) {
            try {
                DTM_DATA.GLOBAL.ProductId = data.code + ': ' + this.analyticsHelper.cleanProductTitle(data.title);
                DTM_DATA.GLOBAL.prop3 = this.analyticsHelper.cleanProductTitle(data.title);
                DTM_DATA.GLOBAL.var10 = '+1';
                DTM_DATA.GLOBAL.currentDate = this.analyticsHelper.getFormattedDate();

                _satellite.track('_quick_view');

            } catch (e) {
                console.error('SPCAnalytics.quickViewClicked >> ', e);
            }
        },

        registerUserStart: function registerUserStart() {
            _satellite.track('_user_registration_initiated');
        },

        registerUserComplete: function registerUserComplete(data) {
            DTM_DATA.GLOBAL.integrationId = data.integrationId;
            _satellite.track('_user_registration_submitted');
        },

        emailSignUpStart: function emailSignUpStart() {
            _satellite.track('_email_signup_initiated');
        },

        eEmailSignUpComplete: function eEmailSignUpComplete() {
            _satellite.track('_email_signup_submit');
        }
    });

    window.DTM_DATA = DTM_DATA;

    app.SPCAnalytics = SPCAnalytics;

}).call(window.SPC = window.SPC || {}, window, window.jQuery, window._, window.CQ, window._satellite);
(function(){dust.register("goodsAndServicesTax",body_0);function body_0(chk,ctx){return chk.section(ctx._get(false, ["provincesTaxAmounts"]),ctx,{"block":body_1},null);}function body_1(chk,ctx){return chk.write("<div class=\"co-sidebar__line-item co-sidebar__line-title\"><span class=\"co-sidebar__line-item__title\">").helper("getRegion",ctx,{},null).write("</span></div>").section(ctx._get(false, ["taxAmounts"]),ctx,{"block":body_2},null);}function body_2(chk,ctx){return chk.write("<div class=\"co-sidebar__line-item\"><span class=\"co-sidebar__line-item__title\">").helper("i18n",ctx,{},{"key":body_3}).write("</span><span class=\"co-sidebar__line-item__amount\">").reference(ctx._get(false,["value","formattedValue"]),ctx,"h").write("</span></div>");}function body_3(chk,ctx){return chk.write("SC0028.").reference(ctx._get(false, ["code"]),ctx,"h");}return body_0;})();
(function(){dust.register("addToCart",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["isSellable"]),ctx,{"block":body_1},null);}function body_1(chk,ctx){return chk.exists(ctx._get(false, ["isPriceAvailable"]),ctx,{"block":body_2},null);}function body_2(chk,ctx){return chk.partial("errorLowStock",ctx,null).helper("select",ctx,{"block":body_3},{"key":ctx._get(false, ["availabilityStatus"])});}function body_3(chk,ctx){return chk.helper("eq",ctx,{"block":body_4},{"value":"AVAILABLE"}).helper("eq",ctx,{"block":body_7},{"value":"OUT_OF_STOCK"}).helper("eq",ctx,{"block":body_8},{"value":"OUT_OF_STOCK_OFFLINE"}).helper("eq",ctx,{"block":body_9},{"value":"NOT_AVAILABLE"});}function body_4(chk,ctx){return chk.helper("if",ctx,{"block":body_5},{"cond":body_6});}function body_5(chk,ctx){return chk.write("<button class=\"add-cart product-detail__button product-detail__button-icon\" type=\"button\"data-module-type=\"SafetyAndWarranty\"data-page-url=\"").helper("getLanguageRoot",ctx,{},null).write("/safety-and-warranty-warning.body-content-modal-with-buttons.html\"><span>").helper("i18n",ctx,{},{"key":"PRD0009"}).write("</span></button>");}function body_6(chk,ctx){return chk.write("'").reference(ctx._get(false, ["preferredShippingMethod"]),ctx,"h").write("' !== 'DO_NOT_USE' || !'").reference(ctx._get(false, ["sku"]),ctx,"h").write("'.length");}function body_7(chk,ctx){return chk.write("<div class=\"product-detail__item-status out-of-stock\">").helper("i18n",ctx,{},{"key":"PRD0018"}).write("</div>");}function body_8(chk,ctx){return chk.write("<div class=\"product-detail__item-status out-of-stock\">").helper("i18n",ctx,{},{"key":"PRD0100"}).write("</div>");}function body_9(chk,ctx){return chk.write("<div class=\"product-detail__item-status out-of-stock\">").helper("i18n",ctx,{},{"key":"PRD0024"}).write("</div>");}return body_0;})();
(function(){dust.register("autofillOff",body_0);function body_0(chk,ctx){return chk.write("<!-- fake fields are a workaround for chrome autofill getting the wrong fields --><input style=\"display:none\" type=\"text\" name=\"fakeusernameremembered\"/><input style=\"display:none\" type=\"password\" name=\"fakepasswordremembered\"/><!-- end: fake fields are a workaround for chrome autofill getting the wrong fields -->");}return body_0;})();
(function(){dust.register("backButton",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["href"]),ctx,{"else":body_1,"block":body_2},null);}function body_1(chk,ctx){return chk.write("<a href=\"/\" class=\"back-to-results__link\">").helper("i18n",ctx,{},{"key":"GLB0138"}).write(" ").helper("i18n",ctx,{},{"key":"GLB0144"}).write(" ").helper("i18n",ctx,{},{"key":"GLB0145"}).write("</a>");}function body_2(chk,ctx){return chk.write("<a href=\"").reference(ctx._get(false, ["href"]),ctx,"h").write("\" class=\"back-to-results__link\">").helper("i18n",ctx,{},{"key":"GLB0138"}).exists(ctx._get(false, ["title"]),ctx,{"block":body_3},null).write("</a>");}function body_3(chk,ctx){return chk.write(" ").helper("i18n",ctx,{},{"key":"GLB0144"}).write(" ").reference(ctx._get(false, ["title"]),ctx,"h",["s"]);}return body_0;})();
(function(){dust.register("cartConfirmationMessage",body_0);function body_0(chk,ctx){return chk.helper("if",ctx,{"else":body_1,"block":body_5},{"cond":body_6});}function body_1(chk,ctx){return chk.helper("if",ctx,{"block":body_2},{"cond":body_4});}function body_2(chk,ctx){return chk.write("<div class=\"header-cart__confirmation-message header-cart__confirmation-message_multiple\"><span class=\"header-cart__confirmation-text\">").helper("i18n",ctx,{},{"key":"GLB0082"}).write("</span><div class=\"header-cart__confirmation-container\">").section(ctx._get(false, ["images"]),ctx,{"block":body_3},null).write("</div></div><!--/.header-cart__confirmation-message_multiple-->");}function body_3(chk,ctx){return chk.write("<img class=\"cart-item__image\" src=\"").reference(ctx._get(true,[]),ctx,"h").write("?wid=75&hei=75&resMode=sharp2&op_sharpen=1\">");}function body_4(chk,ctx){return chk.reference(ctx._get(false,["images","length"]),ctx,"h").write(" > 1");}function body_5(chk,ctx){return chk.write("<div class=\"header-cart__confirmation-message\"><img class=\"cart-item__image header-cart__confirmation-message_image\" src=\"").reference(ctx._get(false,["images","0"]),ctx,"h").write("?wid=74&hei=74&resMode=sharp2&op_sharpen=1\"><div class=\"header-cart__confirmation-message_text\">").helper("i18n",ctx,{},{"key":"GLB0062"}).write("</div></div><!--/.header-cart__confirmation-message-->");}function body_6(chk,ctx){return chk.reference(ctx._get(false,["images","length"]),ctx,"h").write(" === 1");}return body_0;})();
(function(){dust.register("errorLowStock",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["lowStockError"]),ctx,{"block":body_1},null);}function body_1(chk,ctx){return chk.write("<span class=\"validation-error validation-error__qty\">").helper("if",ctx,{"else":body_2,"block":body_3},{"cond":body_4}).write("<br />").helper("i18n",ctx,{},{"key":"SC0035.ADJUST"}).write("</span>");}function body_2(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"SC0035","snippets":ctx._get(false, ["itemsAvailable"])});}function body_3(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"SC0035.SINGLE","snippets":ctx._get(false, ["itemsAvailable"])});}function body_4(chk,ctx){return chk.reference(ctx._get(false, ["itemsAvailable"]),ctx,"h").write(" <= 1");}return body_0;})();
(function(){dust.register("facebookSignIn",body_0);function body_0(chk,ctx){return chk.write("<button class=\"sign-in__facebook\" data-facebook-auth-url=\"/services/sportchek/facebook/auth?success_url=\" data-module-type=\"FacebookSignIn\"><span class=\"sign-in__facebook__text-wrap\"><span class=\"sign-in__facebook__text\">").helper("i18n",ctx,{},{"key":"GLB0015"}).write("</span></span></button><!--/.sign-in__facebook-->");}return body_0;})();
(function(){dust.register("headerAccountButton",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["facebookId"]),ctx,{"else":body_1,"block":body_2},null);}function body_1(chk,ctx){return chk.write("<div class=\"header-account__trigger\"><span class=\"header-account__trigger__text\">").helper("i18n",ctx,{},{"key":"GLB0050"}).write("</span><span class=\"header-account__label\">").helper("i18n",ctx,{},{"key":"GLB0051"}).write("</span></div>");}function body_2(chk,ctx){return chk.write("<div class=\"header-social__trigger\"><div class=\"header-social__avatar\"><img src=\"https://graph.facebook.com/").reference(ctx._get(false, ["facebookId"]),ctx,"h").write("/picture\" alt=\"Social Avatar\"></div></div>");}return body_0;})();
(function(){dust.register("mainNavigationAccountMenu",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["userIsLoggedIn"]),ctx,{"else":body_1,"block":body_2},null);}function body_1(chk,ctx){return chk.write("<a class=\"utility-nav__link utility-nav__signin\" href=\"#\" data-action=\"logIn\">").helper("i18n",ctx,{},{"key":"GLB0010"}).write("</a>");}function body_2(chk,ctx){return chk.write("<a class=\"utility-nav__link utility-nav__my-account\" href=\"").helper("getLanguageRoot",ctx,{},null).write("/my-account.html#\">").helper("i18n",ctx,{},{"key":"GLB0025"}).write("</a><a class=\"utility-nav__link utility-nav__my-account\" href=\"").helper("getLanguageRoot",ctx,{},null).write("/my-account/wishlist.html\">").helper("i18n",ctx,{},{"key":"GLB0009"}).write("</a><a class=\"utility-nav__link utility-nav__signout\" href=\"#\" data-action=\"logOut\">").helper("i18n",ctx,{},{"key":"GLB0008"}).write("</a>");}return body_0;})();
(function(){dust.register("marketingIframe",body_0);function body_0(chk,ctx){return chk.write("<div class=\"section-container container\">").exists(ctx._get(false, ["title"]),ctx,{"block":body_1},null).write("<iframe class=\"glb-marketing-iframe__iframe\" type=\"text/html\"").notexists(ctx._get(false, ["fixedSize"]),ctx,{"else":body_2,"block":body_3},null).write("height=\"").reference(ctx._get(false, ["height"]),ctx,"h").write("\" src=\"").reference(ctx._get(false, ["url"]),ctx,"h").exists(ctx._get(false, ["autoPlay"]),ctx,{"block":body_4},null).write("\" frameborder=\"0\"></iframe></div>");}function body_1(chk,ctx){return chk.write("<div class=\"section-header\"><h2 class=\"section-header__text\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</h2></div>");}function body_2(chk,ctx){return chk.write("width=\"").reference(ctx._get(false, ["width"]),ctx,"h").write("\"");}function body_3(chk,ctx){return chk.write("width=\"100%\"");}function body_4(chk,ctx){return chk.exists(ctx._get(false, ["isYoutube"]),ctx,{"block":body_5},null);}function body_5(chk,ctx){return chk.write("?autoplay=1");}return body_0;})();
(function(){dust.register("alert",body_0);function body_0(chk,ctx){return chk.write("<div class=\"modal__main-content\">").exists(ctx._get(false, ["description"]),ctx,{"else":body_1,"block":body_2},null).exists(ctx._get(false, ["buttonText"]),ctx,{"block":body_3},null).write("</div>").exists(ctx._get(false, ["footerText"]),ctx,{"block":body_4},null);}function body_1(chk,ctx){return chk.write("<h1 class=\"modal__title modal__title_empty-description\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</h1>");}function body_2(chk,ctx){return chk.write("<h1 class=\"modal__title\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</h1><p class=\"gray-text\">").reference(ctx._get(false, ["description"]),ctx,"h").write("</p>");}function body_3(chk,ctx){return chk.write("<div class=\"submit-wrap\"><input class=\"signin-form__submit button modal-information-window__button modal-information-window__close\" type=\"submit\" value=\"").reference(ctx._get(false, ["buttonText"]),ctx,"h").write("\"/></div>");}function body_4(chk,ctx){return chk.write("<div class=\"modal__footer\"><a class=\"modal-information-window__close\" href=\"#\">").reference(ctx._get(false, ["footerText"]),ctx,"h").write("</a></div>");}return body_0;})();
(function(){dust.register("confirm",body_0);function body_0(chk,ctx){return chk.write("<div class=\"modal__main-content\"><h1 class=\"modal__title\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</h1>").exists(ctx._get(false, ["description"]),ctx,{"block":body_1},null).exists(ctx._get(false, ["altDescription"]),ctx,{"block":body_2},null).write("<div class=\"submit-wrap\"><input class=\"signin-form__submit button modal-confirm-window__button modal-confirm-window__button_ok\" type=\"submit\" value=\"").exists(ctx._get(false, ["confirmText"]),ctx,{"else":body_3,"block":body_4},null).write("\"/><a class=\"modal-text-link modal-confirm-window__button_cancel\" href=\"").exists(ctx._get(false, ["cancelTextLink"]),ctx,{"else":body_5,"block":body_6},null).write("\">").exists(ctx._get(false, ["cancelText"]),ctx,{"else":body_7,"block":body_8},null).write("</a></div></div>");}function body_1(chk,ctx){return chk.write("<p class=\"gray-text\">").reference(ctx._get(false, ["description"]),ctx,"h").write("</p>");}function body_2(chk,ctx){return chk.write("<p class=\"gray-text\">").reference(ctx._get(false, ["altDescription"]),ctx,"h").write("</p>");}function body_3(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"GLB0126"});}function body_4(chk,ctx){return chk.reference(ctx._get(false, ["confirmText"]),ctx,"h");}function body_5(chk,ctx){return chk.write("#");}function body_6(chk,ctx){return chk.reference(ctx._get(false, ["cancelTextLink"]),ctx,"h");}function body_7(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"GLB0111"});}function body_8(chk,ctx){return chk.reference(ctx._get(false, ["cancelText"]),ctx,"h");}return body_0;})();
(function(){dust.register("fraud",body_0);function body_0(chk,ctx){return chk.write("<div class=\"modal__main-content\"><h1 class=\"modal__title\">").helper("i18n",ctx,{},{"key":"GLB0136"}).write("</h1><p class=\"gray-text\">").helper("i18n",ctx,{},{"key":"GLB0121"}).write("&nbsp;<a href=\"tel:1-877-977-2435\">1-877-977-2435</a>&nbsp;").helper("i18n",ctx,{},{"key":"GLB0123"}).write("</p></div>");}return body_0;})();
(function(){dust.register("prompt",body_0);function body_0(chk,ctx){return chk.write("<div class=\"modal__main-content\"><h1 class=\"modal__title\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</h1>").exists(ctx._get(false, ["description"]),ctx,{"block":body_1},null).write("<form method=\"post\" class=\"modal-prompt-window__form form_layout_stack\" data-module-type=\"FormBlocking\"><input type=\"text\" data-form-blocking=\"input\" class=\"modal-prompt-window__input ").exists(ctx._get(false, ["error"]),ctx,{"else":body_2,"block":body_3},null).write(" ").exists(ctx._get(false, ["placeholder"]),ctx,{"block":body_4},null).write("/>").exists(ctx._get(false, ["error"]),ctx,{"block":body_5},null).write("<div class=\"submit-wrap\"><input class=\"button signin-form__submit\" type=\"submit\" value=\"").exists(ctx._get(false, ["submitText"]),ctx,{"else":body_6,"block":body_7},null).write("\" data-form-blocking=\"button\"/><a class=\"modal-text-link modal-prompt-window__button_cancel\" href=\"#\">").exists(ctx._get(false, ["cancelText"]),ctx,{"else":body_8,"block":body_9},null).write("</a></div></form></div>");}function body_1(chk,ctx){return chk.write("<p class=\"gray-text\">").reference(ctx._get(false, ["description"]),ctx,"h").write("</p>");}function body_2(chk,ctx){return chk.write("\"");}function body_3(chk,ctx){return chk.write("validation-error\" value=\"").reference(ctx._get(false, ["value"]),ctx,"h").write("\"");}function body_4(chk,ctx){return chk.write("placeholder=\"").reference(ctx._get(false, ["placeholder"]),ctx,"h").write("\"");}function body_5(chk,ctx){return chk.write("<span class=\"validation-error validation-error_show\">").reference(ctx._get(false, ["error"]),ctx,"h").write("</span>");}function body_6(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"GLB0126"});}function body_7(chk,ctx){return chk.reference(ctx._get(false, ["submitText"]),ctx,"h");}function body_8(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"GLB0111"});}function body_9(chk,ctx){return chk.reference(ctx._get(false, ["cancelText"]),ctx,"h");}return body_0;})();
(function(){dust.register("quebecRedirectionModal",body_0);function body_0(chk,ctx){return chk.write("<div class=\"modal__main-content\"><a href=\"#\" class=\"modal__logo\"><img alt=\"SportChek\" src=\"/etc/clientlibs/sportchek/global/img/logo.png\"></a><p class=\"modal__text_gray\">Le site internet SportChek.ca est non disponible pour les rsidents du Qubec.</p><p class=\"modal__text_gray\">Visitez notre site <a href=\"http://www.sportsexperts.ca/\">www.sportsexperts.ca</a> pour voir notre vaste slection de produits ainsi que la liste complte de nos magasins.</p><p class=\"modal__text_gray\">Les magasins Sports Experts offrent un environnement dynamique soucieux de combler les besoins des familles actives jusquaux aspirations des passionns de sport les plus ardents. Offrant une vaste gamme de vtements, de chaussures et dquipement de sport de marques renommes et exclusives  des prix concurrentiels, Sports Experts reprsente une valeur exceptionnelle pour le consommateur.</p><p class=\"modal__text_gray\">Si vous etes arrives sur cette page par erreur, <br><a href=\"").helper("getLanguageRoot",ctx,{},null).write("/homepage.html\">cliquez ici pour tre redirig vers www.sportchek.ca</a><br>Pour tout autre renseignement additionnel, sil vous plat appelez 1-877-977-2435</p><div class=\"modal__devider\"></div><p class=\"modal__text_gray\">SportChek.ca is not available to Quebec residents.</p><p class=\"modal__text_gray\">Please visit <a href=\"http://www.sportsexperts.ca/\">www.sportsexperts.ca</a> to view the Sports Experts in-store assortment and to locate a store near you.</p><p class=\"modal__text_gray\">The Sports Experts stores offer a dynamic environment concerned about filling the needs of active families and the aspiration of the most passionate sport enthusiasts. Offering a vast range of clothing, shoes and sports equipment of renowned and exclusive brands at competitive prices, Sports Expert represents an exceptional value for the consumer.</p><p class=\"modal__text_gray\">If you think you have landed on this page in error, <br><a href=\"").helper("getLanguageRoot",ctx,{},null).write("/homepage.html\">click here to be redirected to www.sportchek.ca</a><br>For any other inquiries, please call 1-877-977-2435</p></div><div title=\"Close (Esc)\" type=\"button\" class=\"mfp-close\"></div>");}return body_0;})();
(function(){dust.register("sessionExpirationModal",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["userIsLoggedIn"]),ctx,{"else":body_1,"block":body_2},null);}function body_1(chk,ctx){return chk.write("<section class=\"expiration-modal\"><div class=\"expiration-modal__expiration-warning modal-content-wrapper first mfp-hide\"><div class=\"modal__main-content\"><h1 class=\"modal__title\">").helper("i18n",ctx,{},{"key":"GLB0147"}).write("</h1><p class=\"gray-text\">").helper("i18n",ctx,{},{"key":"GLB0148"}).write(" <a class=\"expiration-modal__link-login\" data-action=\"login\" href=\"#\">").helper("i18n",ctx,{},{"key":"GLB0149"}).write("</a> ").helper("i18n",ctx,{},{"key":"GLB0150"}).write(" <a class=\"expiration-modal__link-register\" data-action=\"register\" href=\"#\">").helper("i18n",ctx,{},{"key":"GLB0151"}).write("</a> ").helper("i18n",ctx,{},{"key":"GLB0152"}).write("</p><form class=\"expiration-modal__form\"><div class=\"signin-form__remember__wrap\"><input class=\"signin-form__remember mfp-hide\" type=\"checkbox\" name=\"rememberMe\"></div><div class=\"submit-wrap\"><input class=\"expiration-modal__continue-button button push-half--right\" type=\"button\" data-action=\"continue\" value=\"").helper("i18n",ctx,{},{"key":"CHT0053"}).write("\"/></div></form></div></div><div class=\"expiration-modal__expiration-message modal-content-wrapper mfp-hide\"><div class=\"modal__main-content\"><h1 class=\"modal__title\">").helper("i18n",ctx,{},{"key":"GLB0153"}).write("</h1><p class=\"gray-text\">").helper("i18n",ctx,{},{"key":"GLB0154"}).write("</p><form class=\"expiration-modal__form\"><div class=\"submit-wrap\"><input class=\"expiration-modal__button-continue button\" type=\"button\" data-action=\"continue\" value=\"").helper("i18n",ctx,{},{"key":"CHT0053"}).write("\"/></div></form></div></div></section><!--/#timeout-modal-->");}function body_2(chk,ctx){return chk.write("<section class=\"expiration-modal\"><div class=\"expiration-modal__expiration-warning modal-content-wrapper first mfp-hide\"><div class=\"modal__main-content\"><h1 class=\"modal__title\">").helper("i18n",ctx,{},{"key":"GLB0079"}).write("</h1><form method=\"post\" class=\"expiration-modal__form-warning\"><label class=\"signin-form__remember__wrap\"><input class=\"hidden-input\" type=\"checkbox\" name=\"rememberMe\"><span class=\"checkbox\"></span>").helper("i18n",ctx,{},{"key":"GLB0037"}).write("</label><div class=\"submit-wrap\"><input class=\"expiration-modal__continue-button button\" type=\"button\" data-action=\"continue\" value=\"").helper("i18n",ctx,{},{"key":"CHT0053"}).write("\"/></div></form></div></div><div class=\"expiration-modal__expiration-message modal-content-wrapper mfp-hide\"><div class=\"modal__main-content\"><h1 class=\"modal__title\">").helper("i18n",ctx,{},{"key":"GLB0080"}).write("</h1>").partial("facebookSignIn",ctx,null).write("<span class=\"modal__or\">").helper("i18n",ctx,{},{"key":"GLB0074"}).write("</span><div data-module-type=\"SignIn\" data-render-form=\"true\"><!-- glb-sign-in.dust --></div></div></div></section><!--/#timeout-modal-->");}return body_0;})();
(function(){dust.register("videoModal",body_0);function body_0(chk,ctx){return chk.write("<section><div class=\"modal__main-content\"><div class=\"video-modal__player-wrap\">").helper("select",ctx,{"block":body_1},{"key":ctx._get(false, ["videoUrlType"])}).write("</div><div class=\"video-modal__information\"><h1 class=\"modal__title\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</h1><div class=\"video-modal__descr\">").helper("if",ctx,{"else":body_11,"block":body_12},{"cond":body_15}).write("</div><div class=\"video-modal__related-link__wrap\">").section(ctx._get(false, ["tags"]),ctx,{"block":body_16},null).write("</div></div></div><div title=\"").helper("i18n",ctx,{},{"key":"GLB0115"}).write("\" type=\"button\" class=\"mfp-close\">?</div></section>");}function body_1(chk,ctx){return chk.helper("eq",ctx,{"block":body_2},{"value":"html5Player"}).helper("eq",ctx,{"block":body_3},{"value":"youtubePlayer"}).helper("eq",ctx,{"block":body_4},{"value":"flashPlayer"}).helper("eq",ctx,{"block":body_5},{"value":"quicktimePlayer"}).helper("default",ctx,{"block":body_6},null).write("<div class=\"video-modal__overlay\" style=\"display: none;\">").exists(ctx._get(false, ["afterPlayTitle"]),ctx,{"block":body_7},null).write("<a href=\"#\" class=\"video-modal__button video-modal__button_replay\"><span class=\"video-modal__button-cover\"><span class=\"video-modal__button-icon-wrap\"><img src=\"/etc/clientlibs/sportchek/global/img/video-modal-replay.png\"class=\"video-modal__button-icon\" alt=\"\"></span></span><span>").helper("i18n",ctx,{},{"key":"GLB0124"}).write("</span></a></div>");}function body_2(chk,ctx){return chk.write("<video id=\"videoPlayer\" class=\"video-modal__player\" width=\"788\" height=\"450\" controls autoplay><source type=\"video/").reference(ctx._get(false, ["videoExtension"]),ctx,"h").write("\" src=\"").reference(ctx._get(false, ["videoLink"]),ctx,"h").write("\">").helper("i18n",ctx,{},{"key":"GLB0125"}).write("</video>");}function body_3(chk,ctx){return chk.write("<iframe id=\"videoPlayer\" class=\"video-modal__player\" width=\"788\" height=\"450\"src=\"").reference(ctx._get(false, ["youtubeLink"]),ctx,"h").write("?autoplay=1&hl=en_US&rel=0&enablejsapi=1&wmode=opaque\"frameborder=\"0\" allowfullscreen></iframe>");}function body_4(chk,ctx){return chk.write("<object id=\"videoPlayer\" class=\"video-modal__player\"classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,65,0\"width=\"788\" height=\"450\" align=\"\"><param name=\"movie\" value=\"").reference(ctx._get(false, ["s7Domain"]),ctx,"h").write("skins/Scene7SharedAssets/desktopViewers-AS3/GenericVideo.swf?&config=Scene7SharedAssets/Video\" /><param name=\"flashvars\" value=\"asset=").reference(ctx._get(false, ["s7FilePath"]),ctx,"h").write("&streaming=true\" /><param name=\"fullScreenOnSelection\" value=\"true\" /><param name=\"menu\" value=\"false\" /><param name=\"quality\" value=\"high\" /><param name=\"wmode\" value=\"opaque\" /><param name=\"scale\" value=\"noscale\" /><param name=\"align\" value=\"LT\" /><param name=\"allowFullScreen\" value=\"true\" /><param name=\"bgcolor\" value=\"#000000\" /><param name=\"allowScriptAccess\" value=\"always\" /><embed src=\"").reference(ctx._get(false, ["s7Domain"]),ctx,"h").write("skins/Scene7SharedAssets/desktopViewers-AS3/GenericVideo.swf?&amp;config=Scene7SharedAssets/Video\"fullscreenonselection=\"true\" allowscriptaccess=\"always\" wmode=\"opaque\" quality=\"high\"bgcolor=\"#000000\" width=\"788\" height=\"450\" swliveconnect=\"true\"flashvars=\"asset=").reference(ctx._get(false, ["s7FilePath"]),ctx,"h").write("&amp;streaming=true\" name=\"videoPlayer\"type=\"application/x-shockwave-flash\" menu=\"false\" allowfullscreen=\"true\"pluginpage=\"http://www.macromedia.com/go/getflashplayer\"></embed></object>");}function body_5(chk,ctx){return chk.write("<object id=\"videoPlayer\" class=\"video-modal__player-embed\" classid=\"clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B\"codebase=\"http://www.apple.com/qtactivex/qtplugin.cab\" width=\"788\" height=\"450\"><param name=\"src\" value=\"").reference(ctx._get(false, ["videoLink"]),ctx,"h").write("\" /><param name=\"controller\" value=\"false\" /><param name=\"wmode\" value=\"transparent\" /><param name=\"autoplay\" value=\"true\" /><param name=\"enablejavascript\" value=\"true\" /><param name=\"postdomevents\" value=\"true\" /><param name=\"scale\" value=\"tofit\" /><param name=\"bgcolor\" value=\"#000000\" /><param name=\"allowScriptAccess\" value=\"always\" /><embed id=\"videoPlayer-em\" name=\"videoPlayer\" src=\"").reference(ctx._get(false, ["videoLink"]),ctx,"h").write("\" type=\"video/quicktime\" scale=\"tofit\" postdomevents=\"true\" wmode=\"transparent\"  bgcolor=\"#000000\" width=\"788\" height=\"450\"  autoplay=\"true\" enablejavascript=\"true\" controller=\"false\" allowscriptaccess=\"always\" pluginpage=\"http://www.apple.com/quicktime/download/\"></embed></object>");}function body_6(chk,ctx){return chk.write("<video class=\"video-modal__player\" width=\"788\" height=\"450\" controls=\"false\"></video>");}function body_7(chk,ctx){return chk.write("<a href=\"").reference(ctx._get(false, ["afterPlayLink"]),ctx,"h").write("\" ").exists(ctx._get(false, ["afterPlayTargetBlank"]),ctx,{"block":body_8},null).write(" class=\"video-modal__button video-modal__button_activity\"><span class=\"video-modal__button-cover\"><span class=\"video-modal__button-icon-wrap\"><img src=\"").exists(ctx._get(false, ["afterPlayActivityImage"]),ctx,{"else":body_9,"block":body_10},null).write("\" class=\"video-modal__button-icon\"alt=\"").reference(ctx._get(false, ["afterPlayTitle"]),ctx,"h").write("\"></span></span><span class=\"video-modal__button-title\">").reference(ctx._get(false, ["afterPlayTitle"]),ctx,"h").write("</span></a>");}function body_8(chk,ctx){return chk.write("target=\"_blank\"");}function body_9(chk,ctx){return chk.write("/etc/clientlibs/sportchek/global/img/video-modal-afterplay-activity.png");}function body_10(chk,ctx){return chk.reference(ctx._get(false, ["afterPlayActivityImage"]),ctx,"h");}function body_11(chk,ctx){return chk.reference(ctx._get(false, ["description"]),ctx,"h");}function body_12(chk,ctx){return chk.write("<span class=\"video-modal__short-descr\">").helper("getSubstring",ctx,{},{"string":body_13,"start":"0","end":body_14}).write("...</span><span class=\"video-modal__full-descr\">").reference(ctx._get(false, ["description"]),ctx,"h").write("</span> <button class=\"video-modal__more-link\">").helper("i18n",ctx,{},{"key":"PRD0014"}).write("</button>");}function body_13(chk,ctx){return chk.reference(ctx._get(false, ["description"]),ctx,"h");}function body_14(chk,ctx){return chk.reference(ctx._get(false, ["maxDescrSize"]),ctx,"h");}function body_15(chk,ctx){return chk.write("'").reference(ctx._get(false, ["description"]),ctx,"h").write("'.length > ").reference(ctx._get(false, ["maxDescrSize"]),ctx,"h");}function body_16(chk,ctx){return chk.exists(ctx._get(false, ["registerUserOnly"]),ctx,{"else":body_17,"block":body_20},null);}function body_17(chk,ctx){return chk.write("<a href=\"").reference(ctx._get(false, ["url"]),ctx,"h").write("\" ").exists(ctx._get(false, ["openInNewTab"]),ctx,{"block":body_18},null).write(" class=\"video-modal__related-link\">").reference(ctx._get(false, ["text"]),ctx,"h").write("</a>").helper("sep",ctx,{"block":body_19},null);}function body_18(chk,ctx){return chk.write("target=\"_blank\"");}function body_19(chk,ctx){return chk.write(" / ");}function body_20(chk,ctx){return chk.exists(ctx._get(false, ["userIsLoggedIn"]),ctx,{"block":body_21},null);}function body_21(chk,ctx){return chk.write("<a href=\"").reference(ctx._get(false, ["url"]),ctx,"h").write("\" ").exists(ctx._get(false, ["openInNewTab"]),ctx,{"block":body_22},null).write(" class=\"video-modal__related-link\">").reference(ctx._get(false, ["text"]),ctx,"h").write("</a>").helper("sep",ctx,{"block":body_23},null);}function body_22(chk,ctx){return chk.write("target=\"_blank\"");}function body_23(chk,ctx){return chk.write(" / ");}return body_0;})();
(function(){dust.register("wishlistAlert",body_0);function body_0(chk,ctx){return chk.write("<div class=\"modal__main-content\"><h1 class=\"modal__title\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</h1>").exists(ctx._get(false, ["description"]),ctx,{"block":body_1},null).write("<div class=\"signin-form__submit-wrap submit-wrap\"><a href=\"").helper("getLanguageRoot",ctx,{},null).write("/my-account/wishlist.html\" class=\"signin-form__submit button\">").reference(ctx._get(false, ["linkText"]),ctx,"h").write("</a><a class=\"signin-form__forgot-password modal-text-link modal-information-window__close\" href=\"#\">").reference(ctx._get(false, ["cancelText"]),ctx,"h").write("</a></div></div>");}function body_1(chk,ctx){return chk.write("<p class=\"gray-text\">").reference(ctx._get(false, ["description"]),ctx,"h").write("</p>");}return body_0;})();
(function(){dust.register("miniCartProductsContent",body_0);function body_0(chk,ctx){return chk.helper("if",ctx,{"else":body_1,"block":body_2},{"cond":body_9});}function body_1(chk,ctx){return chk.write("<div class=\"header-cart__empty-message\">").helper("i18n",ctx,{},{"key":"GLB0029"}).write("</div>");}function body_2(chk,ctx){return chk.write("<div class=\"header-cart__content\">").section(ctx._get(false, ["entries"]),ctx,{"block":body_3},null).section(ctx._get(false, ["giftcards"]),ctx,{"block":body_8},null).write("</div><div class=\"header-cart__action\"><a class=\"header-cart__link\" href=\"#\" data-action=\"continueShopping\">").helper("i18n",ctx,{},{"key":"GLB0034"}).write("</a><a class=\"header-cart__checkout button button_color_red\" href=\"").helper("getLanguageRoot",ctx,{},null).write("/shopping-cart.html\" data-action=\"viewCart\">").helper("i18n",ctx,{},{"key":"GLB0036"}).write("</a></div>");}function body_3(chk,ctx){return chk.write("<section class=\"cart-item\"><a data-action=\"goToProductDetailsPage\" href=\"").reference(ctx._get(false, ["productPageUrl"]),ctx,"h").write("\"><img class=\"cart-item__image\" src=\"").helper("getImage",ctx,{},{"url":ctx._get(false, ["productPictureUrl"])}).write("?wid=80&hei=80&resMode=sharp2&op_sharpen=1\" width=\"80\" height=\"80\"/></a><div class=\"cart-item__info\"><h2 class=\"cart-item__title\"><a data-action=\"goToProductDetailsPage\" href=\"").reference(ctx._get(false, ["productPageUrl"]),ctx,"h").write("\">").exists(ctx._get(false,["product","productTitle"]),ctx,{"else":body_4,"block":body_7},null).write("</a></h2><div class=\"cart-item__price\"></div><p class=\"cart-item__description\"></p><dl class=\"cart-item__detail\"><dt class=\"cart-item__detail__term\">").helper("i18n",ctx,{},{"key":"GLB0032"}).write(":</dt><dd class=\"cart-item__detail__description\">").reference(ctx._get(false, ["quantity"]),ctx,"h").write("</dd></dl></div><!--/.cart-item__info--></section>");}function body_4(chk,ctx){return chk.exists(ctx._get(false,["product","baseProduct","productTitle"]),ctx,{"else":body_5,"block":body_6},null);}function body_5(chk,ctx){return chk.reference(ctx._get(false,["product","baseProduct","name"]),ctx,"h",["s"]);}function body_6(chk,ctx){return chk.reference(ctx._get(false,["product","baseProduct","productTitle"]),ctx,"h",["s"]);}function body_7(chk,ctx){return chk.reference(ctx._get(false,["product","productTitle"]),ctx,"h",["s"]);}function body_8(chk,ctx){return chk.write("<section class=\"cart-item\"><a data-action=\"goToProductDetailsPage\" href=\"{}/gift-card.html\"><img class=\"cart-item__image\" src=\"").reference(ctx._get(false, ["imageUrl"]),ctx,"h").write("?wid=80&hei=80\"/></a><div class=\"cart-item__info\"><h2 class=\"cart-item__title\"><a href=\"").reference(ctx._get(false, ["giftCardPageUrl"]),ctx,"h").write("\" data-action=\"goToProductDetailsPage\">").helper("i18n",ctx,{},{"key":"SC0063"}).write("</a></h2><div class=\"cart-item__price\"></div><p class=\"cart-item__description\"></p><dl class=\"cart-item__detail\"><dt class=\"cart-item__detail__term\">").helper("i18n",ctx,{},{"key":"GLB0032"}).write(":</dt><dd class=\"cart-item__detail__description\">").reference(ctx._get(false, ["quantity"]),ctx,"h").write("</dd></dl></div></section>");}function body_9(chk,ctx){return chk.reference(ctx._get(false, ["totalUnitCount"]),ctx,"h").write(" > 0");}return body_0;})();
(function(){dust.register("productGridBanner",body_0);function body_0(chk,ctx){return chk.write("<li class=\"product-grid__list-item product-grid__list-item_state_banner\" data-id=\"").reference(ctx._get(false, ["id"]),ctx,"h").write("\"><div class=\"product-grid__list-item-height\"><a class=\"product-grid__list-item_state_banner\" href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write("\" data-raw-href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write("\" ").exists(ctx._get(false, ["openInNewWindow"]),ctx,{"block":body_1},null).write("><img class=\"product-grid-image\" src=\"").helper("getImage",ctx,{},{"url":ctx._get(false,["imageAndColor","0","imageUrl"])}).write("?wid=288&op_sharpen=1&resMode=sharp2\" alt=\"").reference(ctx._get(false, ["title"]),ctx,"h").write("\"></a></div><div class=\"product-spacer\"></div></li>");}function body_1(chk,ctx){return chk.write(" target=\"_blank\" ");}return body_0;})();
(function(){dust.register("productGridBundle",body_0);function body_0(chk,ctx){return chk.write("<li class=\"product-grid__list-item product-grid__list-item_state_bundle\" data-id=\"").reference(ctx._get(false, ["id"]),ctx,"h").write("\" data-product-page-url=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write("\" data-module-type=\"ProductGridItem\"><div class=\"product-grid__list-item-height\"><div class=\"product-grid__list-item-content\"><div class=\"product-image-wrap\"><a class=\"product-grid__link product-grid__link_image\" href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\" data-raw-href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\"><img class=\"product-grid-image\" src=\"").helper("getImage",ctx,{},{"url":ctx._get(false,["imageAndColor","0","imageUrl"])}).write("?wid=288&hei=288&op_sharpen=1&resMode=sharp2\" alt=\"").reference(ctx._get(false, ["title"]),ctx,"h").write("\"></a><button class=\"product-quickview-btn\">").helper("i18n",ctx,{},{"key":"PRD0019"}).write("</button></div><div class=\"product-details\"><div class=\"product-title\"><a class=\"product-title-text\" href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\" data-raw-href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\">").reference(ctx._get(false, ["title"]),ctx,"h",["s"]).write("</a></div></div><!--/.product-details--></div><div class=\"product-quickview-arr\"></div></div><div class=\"quickview\"><div class=\"quickview__content-wrap\"></div></div><div class=\"product-spacer\"></div></li>");}return body_0;})();
(function(){dust.register("productGridGiftCard",body_0);function body_0(chk,ctx){return chk.write("<li class=\"product-grid__list-item\" data-product-code=\"").reference(ctx._get(false, ["code"]),ctx,"h").write("\" data-id=\"").reference(ctx._get(false, ["id"]),ctx,"h").write("\" data-product-page-url=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write("\"><div class=\"product-grid__list-item-height\"><div class=\"product-grid__list-item-content\"><div class=\"product-image-wrap\"><a class=\"product-grid__link product-grid__link_image\" href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\" data-raw-href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\"><img class=\"product-grid-image\" src=\"").helper("getImage",ctx,{},{"url":ctx._get(false,["imageAndColor","0","imageUrl"])}).write("?wid=288&hei=288&op_sharpen=1&resMode=sharp2\" alt=\"").reference(ctx._get(false, ["title"]),ctx,"h").write("\"></a></div><div class=\"product-details\"><div class=\"product-price\">").partial("productGridProductPrice",ctx,null).write("</div><div class=\"product-title\"><a class=\"product-grid__link\" href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\" data-raw-href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\"><span class=\"product-title-text\">").reference(ctx._get(false, ["title"]),ctx,"h",["s"]).write("</span></a></div></div><!--/.product-details--></div></div><div class=\"product-spacer\"></div></li>");}return body_0;})();
(function(){dust.register("productGridItemPromotionIcon",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["timeTestedPrice"]),ctx,{"else":body_1,"block":body_4},null);}function body_1(chk,ctx){return chk.helper("if",ctx,{"block":body_2},{"cond":body_3});}function body_2(chk,ctx){return chk.write("<div class=\"product-grid__list-item-sale\">").helper("i18n",ctx,{},{"key":"PRD0021"}).write("</div>");}function body_3(chk,ctx){return chk.write("'").reference(ctx._get(false,["basePrice","type"]),ctx,"h").write("' === '10' || '").reference(ctx._get(false, ["clearancePrice"]),ctx,"h").write("'");}function body_4(chk,ctx){return chk.write("<div class=\"product-grid__list-item-sale\">").helper("i18n",ctx,{},{"key":"WSL0011"}).write("</div>");}return body_0;})();
(function(){dust.register("productGridItem",body_0);function body_0(chk,ctx){return chk.section(ctx._get(false, ["products"]),ctx,{"else":body_1,"block":body_6},null);}function body_1(chk,ctx){return chk.write("<div class=\"search-content container\"><h2 class=\"no-results__headline product-grid-wrapper_no-results\">").helper("if",ctx,{"else":body_2,"block":body_3},{"cond":body_4}).write("</h2>").exists(ctx._get(false, ["suggestion"]),ctx,{"block":body_5},null).write("</div>");}function body_2(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"SCH0005"}).write("<br>").helper("i18n",ctx,{},{"key":"SCH0006"});}function body_3(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"SCH0022"});}function body_4(chk,ctx){return chk.write("'").reference(ctx._get(false, ["gridType"]),ctx,"h").write("' === 'SUBCATEGORY'");}function body_5(chk,ctx){return chk.write("<p class=\"no-results__text\">").helper("i18n",ctx,{},{"key":"SCH0007"}).write("<strong> \"").reference(ctx._get(false, ["q"]),ctx,"h").write("\"</strong>").helper("i18n",ctx,{},{"key":"SCH0008"}).write(" \"<strong><a href=\"#q=").reference(ctx._get(false, ["suggestion"]),ctx,"h").write("\">").reference(ctx._get(false, ["suggestion"]),ctx,"h").write("</a></strong>\"?</p>");}function body_6(chk,ctx){return chk.helper("select",ctx,{"block":body_7},{"key":ctx._get(false, ["type"])});}function body_7(chk,ctx){return chk.helper("eq",ctx,{"block":body_8},{"value":"product"}).helper("eq",ctx,{"block":body_9},{"value":"bundle"}).helper("eq",ctx,{"block":body_10},{"value":"marketingSlot"}).helper("eq",ctx,{"block":body_11},{"value":"banner"}).helper("eq",ctx,{"block":body_12},{"value":"giftCard"});}function body_8(chk,ctx){return chk.partial("productGridProduct",ctx,null);}function body_9(chk,ctx){return chk.partial("productGridBundle",ctx,null);}function body_10(chk,ctx){return chk.partial("productGridMarketingSlot",ctx,null);}function body_11(chk,ctx){return chk.partial("productGridBanner",ctx,null);}function body_12(chk,ctx){return chk.partial("productGridGiftCard",ctx,null);}return body_0;})();
(function(){dust.register("productGridMarketingSlot",body_0);function body_0(chk,ctx){return chk.write("<li class=\"product-grid__list-item marketing-slot\"><div class=\"product-grid__list-item-height\"><div class=\"product-grid__list-item-content\"><img class=\"product-grid__list-item__picture\" src=\"/etc/clientlibs/sportchek/global/img/placeholder/mobile-marketing.jpg\" alt=\"SportChek\"></div></div></li>");}return body_0;})();
(function(){dust.register("productGridProductPrice",body_0);function body_0(chk,ctx){return chk.helper("gt",ctx,{"else":body_1,"block":body_8},{"key":"0","value":ctx._get(false, ["price"])}).exists(ctx._get(false, ["packagePrice"]),ctx,{"block":body_9},null);}function body_1(chk,ctx){return chk.write("<span class=\"product-price__wrap\">").exists(ctx._get(false, ["timeTestedPrice"]),ctx,{"else":body_2,"block":body_7},null).write("</span>");}function body_2(chk,ctx){return chk.exists(ctx._get(false, ["clearancePrice"]),ctx,{"else":body_3,"block":body_6},null);}function body_3(chk,ctx){return chk.exists(ctx._get(false, ["priceData"]),ctx,{"else":body_4,"block":body_5},null);}function body_4(chk,ctx){return chk.write("<span class=\"product-price-text\">").helper("i18n",ctx,{},{"key":"GLB0128"}).write("</span>");}function body_5(chk,ctx){return chk.write("<span class=\"product-price-text\">").reference(ctx._get(false, ["priceData"]),ctx,"h").write("</span>");}function body_6(chk,ctx){return chk.write("<span class=\"product-sale-price\">").reference(ctx._get(false, ["priceData"]),ctx,"h").write("</span>");}function body_7(chk,ctx){return chk.write("<span class=\"product-price-text strike-through\">").reference(ctx._get(false, ["timeTestedPrice"]),ctx,"h").write(" </span><span class=\"product-sale-price\">").reference(ctx._get(false, ["priceData"]),ctx,"h").write("</span>");}function body_8(chk,ctx){return chk.write("<span class=\"product-price__wrap\">").reference(ctx._get(false, ["priceShortMessage"]),ctx,"h").write("</span>");}function body_9(chk,ctx){return chk.write("<span class=\"product-package-price\">").helper("i18n",ctx,{},{"key":"PRD0106"}).write("</span>");}return body_0;})();
(function(){dust.register("productGridProductPromotions",body_0);function body_0(chk,ctx){return chk.helper("select",ctx,{"block":body_1},{"key":ctx._get(false, ["price"])});}function body_1(chk,ctx){return chk.helper("lt",ctx,{"block":body_2},{"value":0}).helper("default",ctx,{"block":body_3},null);}function body_2(chk,ctx){return chk.write("<div class=\"product-promo ellipsis\"><span>").reference(ctx._get(false, ["priceLongMessage"]),ctx,"h").write("</span></div>");}function body_3(chk,ctx){return chk.exists(ctx._get(false, ["priceShortMessage"]),ctx,{"block":body_4},null).helper("if",ctx,{"block":body_5},{"cond":body_9});}function body_4(chk,ctx){return chk.write("<div class=\"product-promo\"><span class=\"product-promo-text product-promo-text_decorated ellipsis\" data-module-type=\"PromotionDetails\" data-promotional-modal='{\"productMessages\": [{\"longMessage\": ").reference(ctx._get(false, ["priceLongMessage"]),ctx,"h",["js"]).write(", \"shortMessage\": \"").reference(ctx._get(false, ["priceShortMessage"]),ctx,"h").write("\"}]}'>").reference(ctx._get(false, ["priceShortMessage"]),ctx,"h").write("</span></div>");}function body_5(chk,ctx){return chk.write("<div class=\"product-promo product-promo_second\"><span class=\"product-promo-text product-promo-text_decorated product-promo-text_promoted ellipsis\" data-module-type=\"PromotionDetails\" data-promotional-modal='{\"productMessages\": [{\"longMessage\": ").reference(ctx._get(false,["promoMessages","0","longMessage"]),ctx,"h",["js"]).write(", \"shortMessage\": \"").reference(ctx._get(false,["promoMessages","0","shortMessage"]),ctx,"h").write("\"}]}'>").reference(ctx._get(false,["promoMessages","0","shortMessage"]),ctx,"h").write("</span>").helper("if",ctx,{"block":body_6},{"cond":body_8}).write("</div>");}function body_6(chk,ctx){return chk.write("<a href=\"").reference(ctx._get(false,["productPageUrls","0"]),ctx,"h").write(".html\" class=\"product-promo-text__more compare-list__item-pdp-link ellipsis\">").helper("i18n",ctx,{},{"key":"PRD0027"}).write(" (").helper("math",ctx,{},{"key":body_7,"method":"subtract","operand":"1"}).write(")</a>");}function body_7(chk,ctx){return chk.reference(ctx._get(false,["promoMessages","length"]),ctx,"h");}function body_8(chk,ctx){return chk.reference(ctx._get(false,["promoMessages","length"]),ctx,"h").write(" > 1");}function body_9(chk,ctx){return chk.reference(ctx._get(false,["promoMessages","length"]),ctx,"h");}return body_0;})();
(function(){dust.register("productGridProduct",body_0);function body_0(chk,ctx){return chk.write("<li class=\"product-grid__list-item product-grid__list-item_state_comparable ").exists(ctx._get(false, ["inCompareList"]),ctx,{"block":body_1},null).write("\" data-product-code=\"").reference(ctx._get(false, ["code"]),ctx,"h").write("\" data-id=\"").reference(ctx._get(false, ["id"]),ctx,"h").write("\" data-product-page-url=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write("\" data-module-type=\"ProductGridItem\"><div class=\"product-grid__list-item-height\"><div class=\"product-grid__list-item-content\">").partial("productGridItemPromotionIcon",ctx,null).write("<div class=\"product-image-wrap\"><a class=\"product-grid__link product-grid__link_image\" href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\" data-raw-href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\"><img class=\"product-grid-image\" src=\"").helper("getImage",ctx,{},{"url":ctx._get(false,["imageAndColor","0","imageUrl"])}).write("?wid=288&hei=288&op_sharpen=1&resMode=sharp2\" alt=\"").reference(ctx._get(false, ["title"]),ctx,"h").write("\"></a><div class=\"product-quickview\">").partial("productGridProductPrice",ctx,null).helper("if",ctx,{"block":body_2},{"cond":body_18}).write("</div><button class=\"product-quickview-btn\">").helper("i18n",ctx,{},{"key":"PRD0019"}).write("</button></div><div class=\"product-details\"><div class=\"product-price\">").partial("productGridProductPrice",ctx,null).helper("if",ctx,{"block":body_19},{"cond":body_20}).write("</div><div class=\"product-title ellipsis\"><a class=\"product-grid__link\" href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\" data-raw-href=\"").reference(ctx._get(false, ["pagePath"]),ctx,"h").write(".html\"><span class=\"product-title-text\">").reference(ctx._get(false, ["title"]),ctx,"h",["s"]).write("</span></a></div>").helper("if",ctx,{"else":body_21,"block":body_25},{"cond":body_26}).write("<div class=\"product-util\"><div class=\"product-compare-checkbox\"><span class=\"product-compare-checkbox__text\">").helper("i18n",ctx,{},{"key":"PRD0020"}).write("</span></div>").helper("if",ctx,{"block":body_27},{"cond":body_29}).write("</div></div><!--/.product-details--></div><div class=\"product-quickview-arr\"></div></div><div class=\"quickview\"><div class=\"quickview__content-wrap\"></div></div><div class=\"product-spacer\"></div></li>");}function body_1(chk,ctx){return chk.write("product-grid__list-item_state_compare");}function body_2(chk,ctx){return chk.write("<ul class=\"product-colors\">").section(ctx._get(false, ["imageAndColor"]),ctx,{"block":body_3},null).write("</ul>");}function body_3(chk,ctx){return chk.helper("if",ctx,{"block":body_4},{"cond":body_5}).exists(ctx._get(false, ["imageUrl"]),ctx,{"else":body_6,"block":body_11},null);}function body_4(chk,ctx){return chk.write("<li class=\"product-colors-item product-colors-item_plus\">+</li>");}function body_5(chk,ctx){return chk.write("(").reference(ctx._get(false, ["$idx"]),ctx,"h").write(" === 2 && ").reference(ctx._get(false,["imageAndColor","length"]),ctx,"h").write(" > 3)");}function body_6(chk,ctx){return chk.write("<li class=\"product-colors-item ").helper("if",ctx,{"block":body_7},{"cond":body_8}).write(" ").helper("if",ctx,{"block":body_9},{"cond":body_10}).write("\" data-image-url='").helper("getS7DefaultImageUrl",ctx,{},null).write("?wid=288&hei=288&op_sharpen=1&resMode=sharp2' data-color-value='").reference(ctx._get(false, ["colorValue"]),ctx,"h").write("'><img class=\"product-colors-image\" src=\"").helper("getImage",ctx,{},{"url":ctx._get(false, ["color"])}).write("?wid=23&hei=23&fit=stretch,1\"></li>");}function body_7(chk,ctx){return chk.write("selected");}function body_8(chk,ctx){return chk.write("(").reference(ctx._get(false, ["$idx"]),ctx,"h").write(" === 0)");}function body_9(chk,ctx){return chk.write("product-colors-item_extend");}function body_10(chk,ctx){return chk.write("(").reference(ctx._get(false, ["$idx"]),ctx,"h").write(" > 1 && ").reference(ctx._get(false,["imageAndColor","length"]),ctx,"h").write(" > 3)");}function body_11(chk,ctx){return chk.write("<li class=\"product-colors-item ").helper("if",ctx,{"block":body_12},{"cond":body_13}).write(" ").helper("if",ctx,{"block":body_14},{"cond":body_15}).write("\" data-image-url='").reference(ctx._get(false, ["imageUrl"]),ctx,"h").write("?wid=288&hei=288&op_sharpen=1&resMode=sharp2' data-color-value='").reference(ctx._get(false, ["colorValue"]),ctx,"h").write("'>").exists(ctx._get(false, ["color"]),ctx,{"else":body_16,"block":body_17},null).write("</li>");}function body_12(chk,ctx){return chk.write("selected");}function body_13(chk,ctx){return chk.write("(").reference(ctx._get(false, ["$idx"]),ctx,"h").write(" === 0)");}function body_14(chk,ctx){return chk.write("product-colors-item_extend");}function body_15(chk,ctx){return chk.write("(").reference(ctx._get(false, ["$idx"]),ctx,"h").write(" > 1 && ").reference(ctx._get(false,["imageAndColor","length"]),ctx,"h").write(" > 3)");}function body_16(chk,ctx){return chk.write("<img class=\"product-colors-image\" src=\"").helper("getS7DefaultImageUrl",ctx,{},null).write("?wid=23&hei=23&fit=stretch,1\">");}function body_17(chk,ctx){return chk.write("<img class=\"product-colors-image\" src=\"").reference(ctx._get(false, ["color"]),ctx,"h").write("?wid=23&hei=23&fit=stretch,1\">");}function body_18(chk,ctx){return chk.reference(ctx._get(false,["imageAndColor","length"]),ctx,"h").write(" > 0 && '").reference(ctx._get(false,["imageAndColor","0","colorValue"]),ctx,"h").write("' < '91'");}function body_19(chk,ctx){return chk.write("<div class=\"product-colors-wheel\"><img class=\"color-wheel-img\" src=\"/etc/clientlibs/sportchek/global/img/color-wheel.png\" />").reference(ctx._get(false,["imageAndColor","length"]),ctx,"h").write(" ").helper("i18n",ctx,{},{"key":"PRD0012"}).write("</div>");}function body_20(chk,ctx){return chk.reference(ctx._get(false,["imageAndColor","length"]),ctx,"h").write(" > 1 && '").reference(ctx._get(false,["imageAndColor","0","colorValue"]),ctx,"h").write("' < '91'");}function body_21(chk,ctx){return chk.write("<div class=\"product-stock-status\">").notexists(ctx._get(false, ["availability"]),ctx,{"block":body_22},null).helper("if",ctx,{"block":body_23},{"cond":body_24}).write("</div>");}function body_22(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"PRD0105"});}function body_23(chk,ctx){return chk.helper("i18n",ctx,{},{"key":"PRD0104"});}function body_24(chk,ctx){return chk.write("('").reference(ctx._get(false, ["availability"]),ctx,"h").write("'==='INSTORE')");}function body_25(chk,ctx){return chk.partial("productGridProductPromotions",ctx,null);}function body_26(chk,ctx){return chk.write("('").reference(ctx._get(false, ["availability"]),ctx,"h").write("'==='ONLINE' || '").reference(ctx._get(false, ["availability"]),ctx,"h").write("'==='INSTORE,ONLINE' )");}function body_27(chk,ctx){return chk.write("<div class=\"rating rating_small rating_bottom\"><div class=\"rating__blank\"><div class=\"rating__value\" style=\"width: ").helper("getRating",ctx,{},{"value":body_28}).write("%;\"></div></div></div>");}function body_28(chk,ctx){return chk.reference(ctx._get(false, ["rating"]),ctx,"h");}function body_29(chk,ctx){return chk.reference(ctx._get(false, ["rating"]),ctx,"h").write(" > 0");}return body_0;})();
(function(){dust.register("productGridQuickviewBundle",body_0);function body_0(chk,ctx){return chk.write("<div class=\"bundles product-detail product-detail_quickview\"><div class=\"product-detail__background-wrapper\"><div class=\"product-detail__background\"><span class=\"product-detail__bg\" data-picture data-alt=\"Product Detail Background Image\"><span data-src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1366&fit=constrain,1\"></span><span data-src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1920&fit=constrain,1\" data-media=\"(min-device-pixel-ratio: 2.0)\"></span><span data-src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1920&fit=constrain,1\" data-media=\"(min-width: 1367px)\"><img alt=\"Product Detail Background Image\" src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1920&fit=constrain,1\"></span></span></div><div class=\"bundles__header-container\"><div class=\"global-page-header global-page-header_suppressed container\"><h1 class=\"global-page-header__title global-page-header__title_no-transform\">").reference(ctx._get(false, ["title"]),ctx,"h",["s"]).write("</h1><button class=\"quickview__close\"></button></div></div><section class=\"product-detail__preview container\"><div class=\"product-detail__preview-gallery\"><div class=\"product-detail__preview-gallery-content-wrapper\"><span class=\"bundles__header-image\" data-picture=\"\" data-alt=\"").reference(ctx._get(false, ["title"]),ctx,"h").write("\"><span data-src=\"").reference(ctx._get(false, ["image"]),ctx,"h").write("\"><img alt=\"").reference(ctx._get(false, ["title"]),ctx,"h").write("\" src=\"").reference(ctx._get(false, ["image"]),ctx,"h").write("\"></span><span data-src=\"").reference(ctx._get(false, ["image"]),ctx,"h").write("\" data-media=\"(max-width: 767px)\"></span></span></div></div><div class=\"bundles__sidebar\"><div class=\"bundles-sidebar\"><div class=\"bundles-sidebar__inner\"><h2 class=\"bundles-sidebar__title\">").reference(ctx._get(false, ["summary"]),ctx,"h",["s"]).write("</h2><ul class=\"bundles-sidebar__list\">").section(ctx._get(false, ["products"]),ctx,{"block":body_1},null).write("</ul><div class=\"bundles-sidebar__footer\"><a href=\"").reference(ctx._get(false, ["path"]),ctx,"h").write("\" class=\"add-cart product-detail__button\">").helper("i18n",ctx,{},{"key":"GLB0155"}).write("</a></div></div></div></div></section></div></div>");}function body_1(chk,ctx){return chk.write("<li class=\"bundles-sidebar__item\"><span class=\"bundles-dot bundles-sidebar__num\">").helper("idx",ctx,{"block":body_2},null).write("</span><span class=\"bundles-sidebar__item-title-wrapper\"><span class=\"bundles-sidebar__item-title\">").reference(ctx._get(true,[]),ctx,"h").write("</span></span></li>");}function body_2(chk,ctx){return chk.helper("math",ctx,{},{"key":body_3,"method":"add","operand":"1"});}function body_3(chk,ctx){return chk.reference(ctx._get(false, ["$idx"]),ctx,"h");}return body_0;})();
(function(){dust.register("productGridQuickviewPrice",body_0);function body_0(chk,ctx){return chk.helper("select",ctx,{"block":body_1},{"key":ctx._get(false, ["price"])}).exists(ctx._get(false, ["packagePrice"]),ctx,{"block":body_10},null);}function body_1(chk,ctx){return chk.helper("lt",ctx,{"block":body_2},{"value":0}).helper("default",ctx,{"block":body_3},null);}function body_2(chk,ctx){return chk.write("<span class=\"product-detail__price-text\">").reference(ctx._get(false, ["priceShortMessage"]),ctx,"h").write("</span>");}function body_3(chk,ctx){return chk.exists(ctx._get(false, ["timeTestedPrice"]),ctx,{"else":body_4,"block":body_9},null);}function body_4(chk,ctx){return chk.exists(ctx._get(false, ["clearancePrice"]),ctx,{"else":body_5,"block":body_8},null);}function body_5(chk,ctx){return chk.exists(ctx._get(false, ["priceData"]),ctx,{"else":body_6,"block":body_7},null);}function body_6(chk,ctx){return chk.write("<span class=\"product-price-text\">").helper("i18n",ctx,{},{"key":"GLB0128"}).write("</span>");}function body_7(chk,ctx){return chk.write("<span class=\"product-price-text\">").reference(ctx._get(false, ["priceData"]),ctx,"h").write("</span>");}function body_8(chk,ctx){return chk.write("<span class=\"product-detail__price-text\">").reference(ctx._get(false, ["priceData"]),ctx,"h").write("</span><span class=\"product-detail__price-original\">").helper("i18n",ctx,{},{"key":"PRD0021"}).write("</span>");}function body_9(chk,ctx){return chk.write("<span>").reference(ctx._get(false, ["priceData"]),ctx,"h").write(" </span><span class=\"product-detail__price-original\">").helper("i18n",ctx,{},{"key":"GLB0076"}).write(" ").reference(ctx._get(false, ["timeTestedPrice"]),ctx,"h").write("</span>");}function body_10(chk,ctx){return chk.write("<span class=\"product-detail__price-package\">").helper("i18n",ctx,{},{"key":"PRD0106"}).write("</span>");}return body_0;})();
(function(){dust.register("productGridQuickviewProduct",body_0);function body_0(chk,ctx){return chk.write("<div class=\"product-detail product-detail_quickview\"><div class=\"product-detail__background-wrapper\"><div class=\"product-detail__background\">").exists(ctx._get(false, ["backgroundImage"]),ctx,{"block":body_1},null).write("</div><!--/.product-detail__background--><div class=\"global-page-header container\"><a href=\"").reference(ctx._get(false, ["productPageUrl"]),ctx,"h").write("\" class=\"global-page-header__title\">").reference(ctx._get(false, ["title"]),ctx,"h",["s"]).write("</a><button class=\"quickview__close\"></button></div><section id=\"product-detail__preview\" class=\"product-detail__preview container\"><div class=\"product-detail__preview-gallery\" data-module-type=\"MediaViewer\" data-product-code='").reference(ctx._get(false, ["code"]),ctx,"h").write("' data-product='").reference(ctx._get(false, ["images"]),ctx,"h",["js"]).write("' data-default-image='").reference(ctx._get(false, ["s7RootUrl"]),ctx,"h").write("'><div class=\"product-detail__preview-gallery-content-wrapper\"><div class=\"product-detail__preview-gallery-content\"><img class=\"product-detail__product-img\" src=\"\"/><div class=\"zoom-marker\"></div><div class=\"zoom-window\"><div class=\"zoom-window__product-img-container\"><img class=\"zoom-window__product-img\" src=\"\"/></div></div></div></div><div class=\"product-detail__mobile-gallery-content\"><div class=\"product-detail__mobile-gallery\"></div></div></div><!--/.product-detail__preview-gallery--><div class=\"product-swatches\"><div class=\"product-swatches__wrapper\"><a href=\"#\" class=\"product-swatches__btn product-swatches__btn-hidden product-swatches__btn-top\">&#9650;</a><div class=\"product-swatches__list-wrapper\"><!-- prd-media-viewer-swatches.dust --></div><a href=\"#\" class=\"product-swatches__btn product-swatches__btn-hidden product-swatches__btn-bottom\">&#9660;</a></div></div><!--/.product-swatches--><div class=\"product-detail__options\"><div class=\"product-detail__price product-detail__price_quickview\"data-module-type=\"ProductPrice\"data-price=\"").reference(ctx._get(false, ["priceData"]),ctx,"h").write("\"data-online-only=\"").reference(ctx._get(false, ["onlineOnly"]),ctx,"h").write("\"data-on-floor=\"").reference(ctx._get(false, ["onFloor"]),ctx,"h").write("\"><div class=\"product-detail__price-wrap ").exists(ctx._get(false, ["clearancePrice"]),ctx,{"block":body_2},null).write("\">").partial("productGridQuickviewPrice",ctx,null).write("</div></div><!--/.product-detail__price_quickview-->").helper("gt",ctx,{"block":body_3},{"key":ctx._get(false, ["rating"]),"value":"-1"}).write("<div class=\"product-detail__promo_desktop\">").helper("select",ctx,{"block":body_5},{"key":ctx._get(false, ["price"])}).write("</div><!--/.product-detail__promo_desktop--><div class=\"product-detail__form-wrapper\"><form method=\"post\" class=\"product-detail__form\" action=\"\"><input name=\"code\" type=\"hidden\"><input name=\"productPictureUrl\" type=\"hidden\"><input name=\"productPageUrl\" data-raw-value='").reference(ctx._get(false, ["productPageUrl"]),ctx,"h").write("' value=\"\" type=\"hidden\"><fieldset class=\"product-detail__fieldset\"><div data-module-type='SkuSelector'data-push-state-disabled='true'data-product-code='").reference(ctx._get(false, ["code"]),ctx,"h").write("'data-product-variants='").reference(ctx._get(false, ["productVariants"]),ctx,"h",["js"]).write("'data-product-sku-query='").reference(ctx._get(false, ["skuQuery"]),ctx,"h",["js"]).write("'data-product-image-and-colors='").reference(ctx._get(false, ["imageAndColor"]),ctx,"h",["js"]).write("'data-product-size-chart='").reference(ctx._get(false, ["sizeChart"]),ctx,"h",["js"]).write("'data-is-sellable='").reference(ctx._get(false, ["sellable"]),ctx,"h").write("'></div>").partial("qtySelector",ctx,null).write("<div class=\"product-detail__form-action\"><div class=\"product-detail__action-button-wrapper\"><div class=\"add-cart-wrapper\" data-module-type=\"AddToCart\" data-is-assembly-required='").reference(ctx._get(false, ["assemblyRequired"]),ctx,"h").write("'></div>").notexists(ctx._get(false, ["onlineOnly"]),ctx,{"block":body_10},null).partial("addToWishlistButton",ctx,null).write("</div></div></fieldset></form><p class=\"product-detail__description-read-more\">").reference(ctx._get(false, ["longDescription"]),ctx,"h",["s"]).write(" <a class=\"product-detail__description-read-more-link\" href=\"").reference(ctx._get(false, ["productPageUrl"]),ctx,"h").write("#showdescription\">").helper("i18n",ctx,{},{"key":"PRD0096"}).write("</a></p></div><!--/.product-detail__form-wrapper--></div></section></div></div><!--/.product-detail_quickview-->");}function body_1(chk,ctx){return chk.write("<span class=\"product-detail__bg\" data-picture data-alt=\"Product Detail Background Image\"><span data-src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1366&fit=constrain,1\"></span><span data-src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1920&fit=constrain,1\" data-media=\"(min-device-pixel-ratio: 2.0)\"></span><span data-src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1920&fit=constrain,1\" data-media=\"(min-width: 1367px)\"><img alt=\"Product Detail Background Image\" src=\"").reference(ctx._get(false, ["backgroundImage"]),ctx,"h").write("?wid=1920&fit=constrain,1\"></span></span>");}function body_2(chk,ctx){return chk.write("product-detail__price-wrap_clearance");}function body_3(chk,ctx){return chk.write("<div class=\"product-detail__user-reviews\"><div class=\"rating rating_small\"><div class=\"rating__blank\"><div class=\"rating__value\" style=\"width: ").helper("getRating",ctx,{},{"value":body_4}).write("%;\"></div></div></div></div>");}function body_4(chk,ctx){return chk.reference(ctx._get(false, ["rating"]),ctx,"h");}function body_5(chk,ctx){return chk.helper("lt",ctx,{"block":body_6},{"value":0}).helper("default",ctx,{"block":body_7},null);}function body_6(chk,ctx){return chk.write("<div class=\"product-detail__promotion\"><span class=\"product-detail__promotion-wrap ellipsis\">").reference(ctx._get(false, ["priceLongMessage"]),ctx,"h").write("</span></div>");}function body_7(chk,ctx){return chk.exists(ctx._get(false, ["priceShortMessage"]),ctx,{"block":body_8},null).section(ctx._get(false, ["promoMessages"]),ctx,{"block":body_9},null);}function body_8(chk,ctx){return chk.write("<div class=\"product-detail__promotion\"><span class=\"product-detail__promotion-wrap ellipsis\">").reference(ctx._get(false, ["priceShortMessage"]),ctx,"h").write("</span></div>");}function body_9(chk,ctx){return chk.write("<div class=\"product-detail__promotion\"><span class=\"product-detail__promotion-link\" data-module-type=\"PromotionDetails\" data-promotional-modal='{\"productMessages\": [{\"longMessage\": ").reference(ctx._get(false, ["longMessage"]),ctx,"h",["js"]).write(", \"shortMessage\": \"").reference(ctx._get(false, ["shortMessage"]),ctx,"h").write("\"}]}'><span class=\"product-detail__promotion-wrap ellipsis\">").reference(ctx._get(false, ["shortMessage"]),ctx,"h").write("</span></span></div>");}function body_10(chk,ctx){return chk.exists(ctx._get(false, ["onFloor"]),ctx,{"block":body_11},null);}function body_11(chk,ctx){return chk.write("<div class=\"product-stores-wrapper\">").partial("findInStoreButton",ctx,null).partial("findInStoreList",ctx,null).write("</div>");}return body_0;})();
(function(){dust.register("productGridQuickview",body_0);function body_0(chk,ctx){return chk.write("<div class=\"quickview__content\">").helper("select",ctx,{"block":body_1},{"key":ctx._get(false, ["type"])}).write("</div>").exists(ctx._get(false, ["hasPrev"]),ctx,{"block":body_4},null).exists(ctx._get(false, ["hasNext"]),ctx,{"block":body_5},null);}function body_1(chk,ctx){return chk.helper("eq",ctx,{"block":body_2},{"value":"product"}).helper("eq",ctx,{"block":body_3},{"value":"bundle"});}function body_2(chk,ctx){return chk.partial("productGridQuickviewProduct",ctx,null);}function body_3(chk,ctx){return chk.partial("productGridQuickviewBundle",ctx,null);}function body_4(chk,ctx){return chk.write("<button class=\"quickview__btn quickview__btn_prev\"></button>");}function body_5(chk,ctx){return chk.write("<button class=\"quickview__btn quickview__btn_next\"></button>");}return body_0;})();
(function(){dust.register("promotionDetails",body_0);function body_0(chk,ctx){return chk.exists(ctx._get(false, ["isShipping"]),ctx,{"else":body_1,"block":body_9},null);}function body_1(chk,ctx){return chk.section(ctx._get(false, ["appliedProductPromoMessages"]),ctx,{"block":body_2},null).section(ctx._get(false, ["appliedOrderPromoMessages"]),ctx,{"block":body_4},null).section(ctx._get(false, ["productMessages"]),ctx,{"block":body_6},null).exists(ctx._get(false, ["emptyPromoMessage"]),ctx,{"block":body_8},null);}function body_2(chk,ctx){return chk.write("<h1 class=\"modal__subtitle\">").reference(ctx._get(false, ["shortMessage"]),ctx,"h").write("</h1>").section(ctx._get(false, ["longMessage"]),ctx,{"block":body_3},null);}function body_3(chk,ctx){return chk.write("<p class=\"modal__text_gray\">").reference(ctx._get(true,[]),ctx,"h",["s"]).write("</p>");}function body_4(chk,ctx){return chk.write("<h1 class=\"modal__subtitle\">").reference(ctx._get(false, ["shortMessage"]),ctx,"h").write("</h1>").section(ctx._get(false, ["longMessage"]),ctx,{"block":body_5},null);}function body_5(chk,ctx){return chk.write("<p class=\"modal__text_gray\">").reference(ctx._get(true,[]),ctx,"h",["s"]).write("</p>");}function body_6(chk,ctx){return chk.write("<h1 class=\"modal__title promotion-details__sub-title\">").reference(ctx._get(false, ["shortMessage"]),ctx,"h").write("</h1>").section(ctx._get(false, ["longMessage"]),ctx,{"block":body_7},null);}function body_7(chk,ctx){return chk.write("<p class=\"promotion-details__message\">").reference(ctx._get(true,[]),ctx,"h",["s"]).write("</p>");}function body_8(chk,ctx){return chk.write("<p><span class=\"validation-error validation-error_show\">").helper("i18n",ctx,{},{"key":"PRD0026"}).write("</span></p>");}function body_9(chk,ctx){return chk.section(ctx._get(false, ["appliedShippingPromoMessages"]),ctx,{"else":body_10,"block":body_11},null);}function body_10(chk,ctx){return chk.write("<p><span class=\"validation-error validation-error_show\">").helper("i18n",ctx,{},{"key":"PRD0026"}).write("</span></p>");}function body_11(chk,ctx){return chk.write("<h1 class=\"modal__subtitle\">").reference(ctx._get(false, ["shortMessage"]),ctx,"h").write("</h1>").section(ctx._get(false, ["longMessage"]),ctx,{"block":body_12},null);}function body_12(chk,ctx){return chk.write("<p class=\"modal__text_gray\">").reference(ctx._get(true,[]),ctx,"h",["s"]).write("</p>");}return body_0;})();
(function(){dust.register("shareByEmailProductDetail",body_0);function body_0(chk,ctx){return chk.write("<form class=\"email-wishlist-form form_layout_stack\" method=\"POST\" data-module-type=\"FormBlocking\"><h1 class=\"modal__title\">").helper("i18n",ctx,{},{"key":"PRD0089"}).write("</h1>").partial("shareByEmailForm",ctx,null).write("</form>");}return body_0;})();
(function(){dust.register("shareByEmailForm",body_0);function body_0(chk,ctx){return chk.write("<div class=\"email-wishlist-modal__col\"><label class=\"label-set label-set_full\"><span class=\"label-set__imp\">*</span>").helper("i18n",ctx,{},{"key":"WSL0018"}).write("<input type=\"text\" name=\"toRecipient\" data-module-type=\"TextFieldPlaceholder\" placeholder=\"").helper("i18n",ctx,{},{"key":"STD0010"}).write("\" data-form-blocking=\"input\"></label><div class=\"label-set label-set_full\"><span class=\"label-set__imp\">*</span>").helper("i18n",ctx,{},{"key":"WSL0020"}).write("<input type=\"text\" name=\"senderEmail\" data-module-type=\"TextFieldPlaceholder\" placeholder=\"").helper("i18n",ctx,{},{"key":"STD0011"}).write("\" value=\"").reference(ctx._get(false, ["senderEmail"]),ctx,"h").write("\" data-form-blocking=\"input\" maxlength=\"254\"><input type=\"text\" name=\"firstName\" data-module-type=\"TextFieldPlaceholder\" placeholder=\"").helper("i18n",ctx,{},{"key":"STD0012"}).write("\" value=\"").reference(ctx._get(false, ["firstName"]),ctx,"h").write("\" data-form-blocking=\"input\"><input type=\"text\" name=\"lastName\" data-module-type=\"TextFieldPlaceholder\" placeholder=\"").helper("i18n",ctx,{},{"key":"STD0013"}).write("\" value=\"").reference(ctx._get(false, ["lastName"]),ctx,"h").write("\" data-form-blocking=\"input\"></div></div><div class=\"email-wishlist-modal__col\"><label class=\"label-set label-set_full\">").helper("i18n",ctx,{},{"key":"WSL0024"}).write("<textarea class=\"label-set__textarea email-wishlist-form__textarea\" rows=\"6\" maxlength=\"120\" placeholder=\"").helper("i18n",ctx,{},{"key":"STD0014"}).write("\" name=\"personalMessage\"></textarea></label><p class=\"gray-text\">").helper("i18n",ctx,{},{"key":"WSL0025"}).write("</p><button class=\"email-wishlist-form__submit button\" type=\"submit\" data-form-blocking=\"button\">").helper("i18n",ctx,{},{"key":"WSL0026"}).write("</button></div>");}return body_0;})();
(function(){dust.register("signIn",body_0);function body_0(chk,ctx){return chk.helper("if",ctx,{"else":body_1,"block":body_2},{"cond":body_3});}function body_1(chk,ctx){return chk.write("<div class=\"account-menu\"><a class=\"account-menu__link\" href=\"").helper("getLanguageRoot",ctx,{},null).write("/my-account.html#\">").helper("i18n",ctx,{},{"key":"GLB0025"}).write("</a><a class=\"account-menu__link\" href=\"").helper("getLanguageRoot",ctx,{},null).write("/my-account/wishlist.html\">").helper("i18n",ctx,{},{"key":"GLB0009"}).write("</a><a class=\"account-menu__link\" data-action='logOut' href=\"#\">").helper("i18n",ctx,{},{"key":"GLB0008"}).write("</a></div>");}function body_2(chk,ctx){return chk.write("<section class=\"header-account__sign-in\"><h2 class=\"header-account__sign-in__title\">").helper("i18n",ctx,{},{"key":"GLB0010"}).write("</h2><form method=\"post\" class=\"signin-form form_layout_stack\" data-module-type=\"FormBlocking\"><input class=\"signin-form__email\" type=\"text\" name=\"login\" data-module-type=\"TextFieldPlaceholder\" placeholder=\"").helper("i18n",ctx,{},{"key":"GLB0011"}).write("\" data-form-blocking=\"input\" maxlength=\"254\"/><input class=\"signin-form__password\" type=\"password\" name=\"password\" data-module-type=\"TextFieldPlaceholder\" placeholder=\"").helper("i18n",ctx,{},{"key":"GLB0012"}).write("\" data-form-blocking=\"input\" /><label class=\"signin-form__remember__wrap\"><input class=\"hidden-input\" type=\"checkbox\" name=\"rememberMe\" /><span class=\"checkbox\"></span>").helper("i18n",ctx,{},{"key":"GLB0037"}).write("</label><div class=\"signin-form__submit-wrap\"><input class=\"signin-form__submit button button_state_disabled\" type=\"submit\" value=\"").helper("i18n",ctx,{},{"key":"GLB0013"}).write("\" data-action='logIn' data-form-blocking=\"button\" disabled /><a class=\"signin-form__forgot-password modal-text-link\" data-action=\"forgot-password\" data-goto-step=\"forgot-password\" href=\"#\">").helper("i18n",ctx,{},{"key":"GLB0014"}).write("</a></div></form>").partial("facebookSignIn",ctx,null).write("<div class=\"header-account__sign-in__register\">").helper("i18n",ctx,{},{"key":"GLB0016"}).write(" <a class=\"header-account__sign-in__register__link\" data-action=\"register\" href=\"#\">").helper("i18n",ctx,{},{"key":"GLB0017"}).write("</a></div></section>");}function body_3(chk,ctx){return chk.write("'").reference(ctx._get(false, ["forceRenderForm"]),ctx,"h").write("' === 'true' || '").reference(ctx._get(false, ["userIsLoggedIn"]),ctx,"h").write("' !== 'true'");}return body_0;})();
(function(){dust.register("addToWishlist",body_0);function body_0(chk,ctx){return chk.helper("if",ctx,{"block":body_1},{"cond":body_4});}function body_1(chk,ctx){return chk.exists(ctx._get(false, ["inWishList"]),ctx,{"else":body_2,"block":body_3},null);}function body_2(chk,ctx){return chk.write("<button class=\"text-button wishlist product-detail__button product-detail__button-icon\" type=\"button\"><span>").helper("i18n",ctx,{},{"key":"PRD0011"}).write("</span></button>");}function body_3(chk,ctx){return chk.write("<button class=\"remove-wishlist text-button product-detail__button product-detail__button-icon\" type=\"button\"><span>").helper("i18n",ctx,{},{"key":"PRD0010"}).write("</span></button>");}function body_4(chk,ctx){return chk.write("'").reference(ctx._get(false, ["availabilityStatus"]),ctx,"h").write("' !== 'NOT_AVAILABLE'");}return body_0;})();
(function(){dust.register("addToWishlistButton",body_0);function body_0(chk,ctx){return chk.write("<div data-module-type=\"AddToWishList\"></div>");}return body_0;})();
(function(){dust.register("findInStoreButton",body_0);function body_0(chk,ctx){return chk.write("<button class=\"product-detail__button product-detail__button-icon locator\" data-module-type=\"FindInStore\" type=\"button\" data-product-code=\"").reference(ctx._get(false, ["code"]),ctx,"h").write("\"><span>").helper("i18n",ctx,{},{"key":"PRD0015"}).write("</span></button>");}return body_0;})();
(function(){dust.register("findInStoreItem",body_0);function body_0(chk,ctx){return chk.section(ctx._get(false, ["results"]),ctx,{"block":body_1},null).exists(ctx._get(false, ["error"]),ctx,{"block":body_6},null);}function body_1(chk,ctx){return chk.write("<div class=\"product-store ").helper("if",ctx,{"else":body_2,"block":body_3},{"cond":body_4}).write(" ").exists(ctx._get(false, ["preferredStore"]),ctx,{"block":body_5},null).write("\"><a class=\"product-store__store-name\" href=\"").reference(ctx._get(false, ["storeLink"]),ctx,"h").write("\">").reference(ctx._get(false, ["title"]),ctx,"h").write("</a><div class=\"product-store__status\">").helper("getStoreInventoryStatus",ctx,{},null).write(" - <span class=\"product-store__distance\">(").reference(ctx._get(false, ["formattedDistance"]),ctx,"h").write(")</span></div></div>");}function body_2(chk,ctx){return chk.write(" product-store__out-of-stock ");}function body_3(chk,ctx){return chk.write(" product-store__in-stock ");}function body_4(chk,ctx){return chk.write("'").reference(ctx._get(false, ["inventoryStatus"]),ctx,"h").write("'==='FORCEINSTOCK' || '").reference(ctx._get(false, ["inventoryStatus"]),ctx,"h").write("'==='LOWSTOCK'");}function body_5(chk,ctx){return chk.write(" product-store__preferred ");}function body_6(chk,ctx){return chk.write("<div class=\"product-stores__error\"><span class=\"validation-error validation-error_show\">").reference(ctx._get(false, ["error"]),ctx,"h").write("</span></div>");}return body_0;})();
(function(){dust.register("findInStoreList",body_0);function body_0(chk,ctx){return chk.write("<div class=\"product-stores\"><div class=\"product-stores__carat-wrapper\"><span class=\"product-stores__carat\"></span></div><div class=\"product-stores__listing\"><div class=\"product-stores__listing__inner\"><div class=\"product-stores__template-placeholder\"><!--product-stores__template--></div><a class=\"product-stores__more\" href=\"#\" data-raw-href=\"").helper("getLanguageRoot",ctx,{},null).write("/find-in-store.html\">").helper("i18n",ctx,{},{"key":"PRD0017"}).write("</a><a class=\"product-stores__change-store\" href=\"#\" data-raw-href=\"").helper("getLanguageRoot",ctx,{},null).write("/find-in-store.html\"><span class=\"product-stores__previous-location\"></span>: ").helper("i18n",ctx,{},{"key":"PRD0103"}).write("</a></div></div></div><!--/.product-stores-->");}return body_0;})();
(function(){dust.register("mediaViewerMobile",body_0);function body_0(chk,ctx){return chk.section(ctx._get(false, ["variants"]),ctx,{"block":body_1},null);}function body_1(chk,ctx){return chk.write("<div class=\"product-detail__mobile-gallery-item\"><img src=\"").helper("getImage",ctx,{},{"url":ctx._get(false, ["imagePath"])}).write("?bgColor=0,0,0,0&fmt=png-alpha&hei=246&resMode=sharp2&qlt=85,1\" height=\"246\" /></div>");}return body_0;})();
(function(){dust.register("mediaViewerSwatches",body_0);function body_0(chk,ctx){return chk.write("<ul class=\"product-swatches__list\">").section(ctx._get(false, ["variants"]),ctx,{"block":body_1},null).write("</ul>");}function body_1(chk,ctx){return chk.write("<li class=\"product-swatches__item\" data-swatch-index=\"").helper("idx",ctx,{"block":body_2},null).write("\"><a class=\"product-swatches__item-selector\" href=\"#\"><img class=\"product-swatches__item-img\" src=\"").helper("getImage",ctx,{},{"url":ctx._get(false, ["imagePath"])}).write("?fmt=png-alpha&wid=80&hei=80&op_sharpen=1&resMode=sharp2&qlt=85,1\" width=\"80\" height=\"80\" /></a></li>");}function body_2(chk,ctx){return chk.reference(ctx._get(true,[]),ctx,"h");}return body_0;})();
(function(){dust.register("qtySelector",body_0);function body_0(chk,ctx){return chk.write("<div class=\"product-detail__qty dropdown-wrapper qty-dropdown\"><h3 class=\"dropdown-title product-detail__options-title\">").helper("i18n",ctx,{},{"key":"PRD0007"}).write(": <span></span></h3><div class=\"dropdown dropdown_ready-visible\"><select name=\"quantity\"><option value=\"1\">1</option><option value=\"2\">2</option><option value=\"3\">3</option><option value=\"4\">4</option><option value=\"5\">5</option></select></div></div><!--/.product-detail__qty-->");}return body_0;})();
(function(){dust.register("skuSelector",body_0);function body_0(chk,ctx){return chk.write("<div class=\"product-detail__select\">").section(ctx._get(false, ["controls"]),ctx,{"block":body_1},null).write("</div>");}function body_1(chk,ctx){return chk.helper("if",ctx,{"else":body_2,"block":body_16},{"cond":body_22});}function body_2(chk,ctx){return chk.helper("if",ctx,{"else":body_3,"block":body_4},{"cond":body_6}).write("<h3 class=\"dropdown-title product-detail__options-title\">").reference(ctx._get(false, ["controlType"]),ctx,"h").write(": ").helper("if",ctx,{"block":body_7},{"cond":body_8}).write("</h3><div class=\"dropdown-wrap\" data-print-options=\"").section(ctx._get(false, ["options"]),ctx,{"block":body_9},null).write("\"><div class=\"dropdown form-dropdown\"><select data-module-type='FormDropdown' data-control-type='").reference(ctx._get(false, ["controlType"]),ctx,"h").write("' autocomplete=\"off\"><option value=\"\">").helper("i18n",ctx,{},{"key":"GLB0024"}).write("</option>").section(ctx._get(false, ["options"]),ctx,{"block":body_12},null).write("</select></div><span class=\"validation-error\">").helper("i18n",ctx,{},{"key":"validation.skuSelector.select"}).write(" ").reference(ctx._get(false, ["controlType"]),ctx,"h").write("</span></div></div>");}function body_3(chk,ctx){return chk.write("<div class=\"product-detail__custom dropdown-wrapper\">");}function body_4(chk,ctx){return chk.write("<div class=\"product-detail__size dropdown-wrapper\" ").exists(ctx._get(false, ["hideSize"]),ctx,{"block":body_5},null).write(">");}function body_5(chk,ctx){return chk.write("style=\"display: none\"");}function body_6(chk,ctx){return chk.write("'").reference(ctx._get(false, ["controlType"]),ctx,"h").write("' === 'size'");}function body_7(chk,ctx){return chk.write("<a data-module-type='SizeChartModal' data-product-size-chart='").reference(ctx._get(false, ["sizeChart"]),ctx,"h",["js"]).write("' class=\"info-popup\" href=\"#\"></a>");}function body_8(chk,ctx){return chk.write("'").reference(ctx._get(false, ["controlType"]),ctx,"h").write("' === 'size' && '").reference(ctx._get(false, ["sizeChart"]),ctx,"h").write("'.length");}function body_9(chk,ctx){return chk.helper("if",ctx,{"block":body_10},{"cond":body_11}).reference(ctx._get(false, ["optionTitle"]),ctx,"h");}function body_10(chk,ctx){return chk.write(" / ");}function body_11(chk,ctx){return chk.reference(ctx._get(false, ["$idx"]),ctx,"h").write(" !== 0");}function body_12(chk,ctx){return chk.write("<option value=\"").reference(ctx._get(false, ["optionValue"]),ctx,"h").write("\" ").exists(ctx._get(false, ["isSelected"]),ctx,{"block":body_13},null).write(" ").notexists(ctx._get(false, ["isAvailable"]),ctx,{"block":body_14},null).write(">").reference(ctx._get(false, ["optionTitle"]),ctx,"h").exists(ctx._get(false, ["outOfStockMobileView"]),ctx,{"block":body_15},null).write("</option>");}function body_13(chk,ctx){return chk.write(" selected=\"selected\"");}function body_14(chk,ctx){return chk.write(" class=\"out-of-stock\"");}function body_15(chk,ctx){return chk.write(" - ").helper("i18n",ctx,{},{"key":"PRD0102"});}function body_16(chk,ctx){return chk.helper("if",ctx,{"block":body_17},{"cond":body_21});}function body_17(chk,ctx){return chk.write("<div class=\"product-detail__color\"><h3 class=\"input-title product-detail__options-title\">").helper("i18n",ctx,{},{"key":"GLB0030"}).write(": <span>").reference(ctx._get(false, ["controlTypeTitle"]),ctx,"h").write("</span></h3>").section(ctx._get(false, ["options"]),ctx,{"block":body_18},null).write("</div><div class=\"product-detail__clearer\"></div>");}function body_18(chk,ctx){return chk.write("<a data-value='").reference(ctx._get(false, ["optionValue"]),ctx,"h").write("' data-control-type='").reference(ctx._get(false, ["controlType"]),ctx,"h").write("' class=\"product-detail__color-option ").notexists(ctx._get(false, ["isAvailable"]),ctx,{"block":body_19},null).write(" ").exists(ctx._get(false, ["isSelected"]),ctx,{"block":body_20},null).write("\" title=\"").reference(ctx._get(false, ["optionTitle"]),ctx,"h").write("\"><img src=\"").helper("getImage",ctx,{},{"url":ctx._get(false, ["colorImage"])}).write("?wid=42&hei=42&fit=stretch,1\" alt=\"").reference(ctx._get(false, ["optionTitle"]),ctx,"h").write("\"/></a>");}function body_19(chk,ctx){return chk.write(" out-of-stock");}function body_20(chk,ctx){return chk.write(" selected");}function body_21(chk,ctx){return chk.reference(ctx._get(false,["options","length"]),ctx,"h").write(" > 0 && '").reference(ctx._get(false,["options","0","optionValue"]),ctx,"h").write("' !== '99'");}function body_22(chk,ctx){return chk.write("'").reference(ctx._get(false, ["controlType"]),ctx,"h").write("' === 'color'");}return body_0;})();
;(function(window, document, $) {
    var app = this;

    var MainContentSpinner = function MainContentSpinner($element) {
        var _this = this instanceof MainContentSpinner ? this : Object.create(MainContentSpinner.prototype);

        _this.elems = {
            $component: $element
        };

        _this.counter = 0;

        return _this;
    };

    $.extend(MainContentSpinner.prototype, {
        spinner: function spinner(action, params) {
            var _this = this;

            switch (undefined) {
                case (params):
                    params = {
                        position: 'fixed',
                        insertInside: false
                    };

                    break;

                case (params.position):
                    params.position = 'fixed';

                    break;

                case (params.insertInside):
                    params.position = false;

                    break;
            }

            if (action === 'show') {
                if (_this.counter === 0) {
                    _this.elems.$component.addClass('page-container_blured');
                    _this.elems.$component.spinner('show', params);
                }

                _this.counter++;

                return;
            }

            if (action === 'hide') {
                if (_this.counter === 1) {
                    _this.elems.$component.removeClass('page-container_blured');
                    _this.elems.$component.spinner('hide', params);
                }

                if (_this.counter) {
                    _this.counter--;
                }
            }
        }
    });

    app.MainContentSpinner = MainContentSpinner;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $, _, CQ, store) {
    var app = this;

    var DEFAULTS = {
        SERVICES_URLS: {
            USER_ACCOUNT: '/services/sportchek/customer/profile/current',
            LOG_IN: '/services/sportchek/customers/login',
            LOG_OUT: '/services/sportchek/customers/logout'
        }
    };

    var User = function User() {
        var _this = this instanceof User ? this : Object.create(User.prototype);

        _this.data = app.userData;

        delete app.userData;

        _this.logOutRequest = null;
        _this.email = null;

        _this.initialize();

        return _this;
    };

    $.extend(User.prototype, {
        initialize: function initialize() {
            var currentUserData = this.get();
            var isLoggedIn = !$.isEmptyObject(currentUserData) && currentUserData.uid !== 'anonymous';

            $.cookie(app.COOKIES.LOGGED_IN, isLoggedIn, {
                path: '/'
            });

            // Restore user data
            if (this.isLoggedIn()) {
                var data = this.get();
                var hasUserData = Boolean(data && data.uid);

                if (!hasUserData) {
                    this.reload();
                }
            }
        },

        /**
         * Update user data object
         * @param {Object|Null} newUserData
         */
        update: function update(newUserData) {
            var currentUserData = this.get();

            this.data = $.extend(currentUserData, newUserData);

            var isLoggedIn = !$.isEmptyObject(this.data) && this.data.uid !== 'anonymous';

            $.cookie(app.COOKIES.LOGGED_IN, isLoggedIn, {
                path: '/'
            });

            if (isLoggedIn) {
                app.trigger(app.EVENTS.LOG_IN);
            } else {
                app.trigger(app.EVENTS.LOG_OUT);
            }
        },

        reload: function reload() {
            var _this = this;

            return $.ajax({
                url: DEFAULTS.SERVICES_URLS.USER_ACCOUNT,
                type: 'GET',
                dataType: 'JSON',
                contentType: 'application/json',
                cache: false,
                success: function(data) {
                    _this.update(data);
                },
                error: function(jqXhr) {

                    switch (jqXhr.status) {
                        case 401:

                        case 403:

                            _this.logOut();

                            break;

                        default:
                            console.error('"User.reload" >> Your account data cannot be loaded');
                    }
                }
            });
        },

        logIn: function logIn($form) {
            var _this = this;
            var data = $form.toObject();

            data.login = $.trim(data.login);
            _this.email = data.login;

            return $.ajax({
                url: DEFAULTS.SERVICES_URLS.LOG_IN,
                type: 'POST',
                data: $.param(data),
                dataType: 'JSON',
                success: function(data) {
                    _this.update(data);

                    app.modules.AuthModal[0].close();
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 403:
                            var parsedResponse = JSON.parse(jqXhr.responseText);

                            switch (parsedResponse.messages[0].message) {
                                case 'error.customers.login.customerId.fraud':

                                case 'validation.customerId.fraud':
                                    app.modules.Alert.openModal({}, $.noop, 'fraud');

                                    break;

                                case 'error.customers.login.customerId.maxFailedLoginAttempts':
                                    app.modules.AuthModal[0].open({
                                        step: 'max-failed-login-attemps'
                                    });

                                    break;

                                case 'error.customers.login.activationLink.unconfirmed':
                                    app.modules.AuthModal[0].open({
                                        step: 'changed-email-activation'
                                    });

                                    break;

                                case 'registration.customerId.inactive':
                                    app.modules.AuthModal[0].open({
                                        step: 'resend-activation-link'
                                    });

                                    break;
                            }

                            break;

                        default:
                            console.error('"User.logIn" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                }
            });
        },

        clearUserData: function clearUserData() {
            this.data = {};

            $.removeCookie(app.COOKIES.LOGGED_IN, {
                path: '/'
            });

            $.removeCookie(app.COOKIES.MINI_CART, {
                path: '/'
            });

            store.remove(app.LOCAL_STORAGE.SHIPPING_CONSIGNMENT_ADDRESSES);
        },

        logOut: function logOut() {
            var _this = this;

            if (_this.logOutRequest) {
                _this.logOutRequest.abort();
            }

            _this.logOutRequest = $.ajax({
                url: DEFAULTS.SERVICES_URLS.LOG_OUT,
                type: 'GET',
                dataType: 'TEXT',
                success: function() {
                    _this.clearUserData();
                    app.trigger(app.EVENTS.LOG_OUT);
                }
            });

            return _this.logOutRequest;
        },

        isLoggedIn: function isLoggedIn() {
            return $.cookie(app.COOKIES.LOGGED_IN) === 'true';
        },

        isRememberMe: function isRememberMe() {
            return Boolean(this.get().isRememberMe);
        },

        get: function get() {
            return this.data || {};
        }
    });

    app.User = User;

    return app.User;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.CQ, window.store);

;(function(window, document, $) {
    var app = this;

    /*
     * Constructor
     */
    var LoginWithSocialNetwork = function LoginWithSocialNetwork() {
        var _this = this instanceof LoginWithSocialNetwork ? this : Object.create(LoginWithSocialNetwork.prototype);

        _this.initialize();

        return _this;
    };

    $.extend(LoginWithSocialNetwork.prototype, {
        initialize: function initialize() {
            if ($.bbq.getState().reloadUserData === 'true') {
                this._updateComponentsState();
            }
        },

        _updateComponentsState: function _updateComponentsState() {
            $.when(app.modules.User.reload()).done(function() {
                $.bbq.removeState('reloadUserData');

                if (app.modules.AuthModal) {
                    app.modules.AuthModal[0].close();
                }
            });
        }
    });

    app.LoginWithSocialNetwork = LoginWithSocialNetwork;

    return app.LoginWithSocialNetwork;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);

;(function(window, document, $, CQ) {
    var app = this;

    var DEFAULTS = {
        SERVICES: '/services/sportchek/'
    };

    var ServerErrorModal = function ServerErrorModal() {
        var _this = this instanceof ServerErrorModal ? this : Object.create(ServerErrorModal.prototype);

        _this.initialize();

        return _this;
    };

    $.extend(ServerErrorModal.prototype, {
        initialize: function initialize() {
            var _this = this;

            _this.bindEvents();

            var showServerErrorModal = $.bbq.getState().showServerErrorModal;

            if (showServerErrorModal) {
                _this._open();

                $.bbq.removeState();
            }
        },

        bindEvents: function bindEvents() {
            var _this = this;

            $.ajaxPrefilter(function(options, originalOptions, jqXhr) {

                jqXhr.fail(function() {

                    if (options.url.match(DEFAULTS.SERVICES) && jqXhr.status === 503) {

                        _this._open();
                    }
                });
            });
        },

        _open: function _open() {
            app.modules.Alert.openModal({
                title: CQ.I18n.get('error.server.did.not.respond'),
                description: CQ.I18n.get('GLB0139')
            });
        }
    });

    app.ServerErrorModal = ServerErrorModal;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);

;(function(window, document, $, _, Modernizr) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SELECTORS: {
            DATA_MENU_TOGGLE: '.header-menu-toggle, .page-nav-close-toggle',
            CONTAINER_CLASS: '.page-nav-container',
            PAGE_NAVE: '.page-nav',
            NAVE_ITEM: '.page-nav__item',
            WRAPPER: 'nav:first',
            RETURN_MAIN: '.page-nav__item_return',
            PLUS_BUTTONS: '.page-nav__plus-btn',
            PARENT_ITEMS: '.page-nav__item_subcategory-opened > .page-nav__link'
        },
        ACTIVE_CLASS: 'page-nav-active',
        CLASSES: {
            OPEN: 'page-nav__item_opened',
            NAVE_OPEN: 'page-nav_opened',
            SUBCATEGORY_OPEN: 'page-nav__item_subcategory-opened'
        },
        HTML_ELEMENT: 'html'
    };

    // TODO: rewrite module with $.bbq
    var MainNavigation = function($element) {
        var _this = this instanceof MainNavigation ? this : Object.create(MainNavigation.prototype);

        _this.elems = {
            $component: $element,
            $document: $(document),
            $body: $(document.body),
            $htmlElement: $(DEFAULTS.HTML_ELEMENT),
            $toggle: $(DEFAULTS.SELECTORS.DATA_MENU_TOGGLE),
            $wrapper: $element.find(DEFAULTS.SELECTORS.WRAPPER),
            $returnToMain: $element.find(DEFAULTS.SELECTORS.RETURN_MAIN)
        };

        _this.elems.$container = _this.elems.$component.closest(DEFAULTS.SELECTORS.CONTAINER_CLASS);

        _this.initialize();

        return _this;
    };

    $.extend(MainNavigation.prototype, {
        initialize: function initialize() {
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', DEFAULTS.SELECTORS.PARENT_ITEMS, $.proxy(this._backToParent, this));
            this.elems.$component.on('click', DEFAULTS.SELECTORS.PLUS_BUTTONS, $.proxy(this._plusListener, this));
            this.elems.$returnToMain.on('click', $.proxy(this._returnToMain, this));
            this.elems.$toggle.on('click', $.proxy(this._toggleMenu, this));

            app.subscribe(app.EVENTS.LOG_IN, $.proxy(this.closeMainNav, this));
            app.subscribe(app.EVENTS.LOG_OUT,  $.proxy(this.closeMainNav, this));
        },

        openMainNav: function openMainNav() {
            var _this = this;

            this.elems.$htmlElement.addClass(DEFAULTS.ACTIVE_CLASS);

            if (Modernizr.touch) {
                // This force repaint when scrolling, fixes issue in galaxy tab 2 android 4.0.4
                // TODO: Should be simplified
                _this.elems.$document.on(
                    'scroll.mainNav', _.throttle(function() {
                    $('<style></style>')
                        .appendTo(_this.elems.$body)
                        .remove();
                }, 100, {
                    trailing: true
                }));
            }
        },

        closeMainNav: function closeMainNav() {
            this.elems.$htmlElement.removeClass(DEFAULTS.ACTIVE_CLASS);

            if (Modernizr.touch) {
                this.elems.$document.off('scroll.mainNav');
            }
        },

        _plusListener: function _plusListener(event) {
            var $current = $(event.currentTarget).parent(DEFAULTS.SELECTORS.NAVE_ITEM);

            $current.addClass(DEFAULTS.CLASSES.OPEN);

            this.elems.$returnToMain.show();

            this._setParents($current);
        },

        _setParents: function _setParents($current) {
            var $itemParents = $current.parents(DEFAULTS.SELECTORS.NAVE_ITEM);

            $current.parents(DEFAULTS.SELECTORS.PAGE_NAVE).addClass(DEFAULTS.CLASSES.NAVE_OPEN).scrollTop(0);

            if (Modernizr.touch) {
                this.elems.$container.scrollTop(0);
            }

            $itemParents.addClass(DEFAULTS.CLASSES.SUBCATEGORY_OPEN);
            $itemParents.addClass(DEFAULTS.CLASSES.OPEN);
        },

        _returnToMain: function _returnToMain(event) {
            event.preventDefault();

            this.elems.$returnToMain.hide();
            this.elems.$component.find(DEFAULTS.SELECTORS.PAGE_NAVE).removeClass(DEFAULTS.CLASSES.NAVE_OPEN);
            this.elems.$component.find(DEFAULTS.SELECTORS.NAVE_ITEM).removeClass(DEFAULTS.CLASSES.OPEN);
            this.elems.$component.find(DEFAULTS.SELECTORS.NAVE_ITEM).removeClass(DEFAULTS.CLASSES.SUBCATEGORY_OPEN);
        },

        _backToParent: function _backToParent(event) {
            event.preventDefault();

            var $item = $(event.currentTarget).parent(DEFAULTS.SELECTORS.NAVE_ITEM);

            $item.removeClass(DEFAULTS.CLASSES.SUBCATEGORY_OPEN);
            $item.find(DEFAULTS.SELECTORS.PAGE_NAVE).removeClass(DEFAULTS.CLASSES.NAVE_OPEN);
            $item.find(DEFAULTS.SELECTORS.NAVE_ITEM).removeClass(DEFAULTS.CLASSES.OPEN);
            $item.find(DEFAULTS.SELECTORS.NAVE_ITEM).removeClass(DEFAULTS.CLASSES.SUBCATEGORY_OPEN);
        },

        _toggleMenu: function _toggleMenu(event) {
            if (this.elems.$htmlElement.hasClass(DEFAULTS.ACTIVE_CLASS)) {
                this.closeMainNav(event);
            } else {
                this.openMainNav(event);
            }
        }
    });

    app.MainNavigation = MainNavigation;

    return app.MainNavigation;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.Modernizr);

;(function(window, document, $, dust) {
    var app = this;

    /*
     * Constructor
     */
    var MainNavigationAccountMenu = function MainNavigationAccountMenu($element) {
        var _this = this instanceof MainNavigationAccountMenu ? this : Object.create(MainNavigationAccountMenu.prototype);

        _this.elems = {
            $component: $element
        };

        _this.initialize();

        return _this;
    };

    $.extend(MainNavigationAccountMenu.prototype, {
        initialize: function initialize() {
            this.render();
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$component
                .on('click', '[data-action]', function(e) {
                    e.preventDefault();

                    var $actionButton = $(e.currentTarget);
                    var action = $actionButton.data('action');

                    switch (action) {
                        case 'logIn':
                            app.modules.AuthModal[0].open({
                                step: 'signin'
                            });

                            break;

                        case 'logOut':
                            app.modules.User.logOut();

                            break;
                    }
                });

            app.subscribe(app.EVENTS.LOG_IN, function() {
                _this.render();
            });

            app.subscribe(app.EVENTS.LOG_OUT, function() {
                _this.render();
            });
        },

        render: function render() {
            var _this = this;
            var settings = {
                userIsLoggedIn: app.modules.User.isLoggedIn()
            };

            dust.render('mainNavigationAccountMenu', settings, function(error, out) {
                _this.elems.$component.html(out);
            });
        }
    });

    app.MainNavigationAccountMenu = MainNavigationAccountMenu;

    return app.MainNavigationAccountMenu;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust);
;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            LOGOTYPE_LINK: '.header-logo__link'
        }
    };

    var _homePageLink = '';

    var HeaderLogo = function HeaderLogo($element) {
        var _this = this instanceof HeaderLogo ? this : Object.create(HeaderLogo.prototype);

        _this.elems = {
            $component: $element,
            $link: $element.find(DEFAULTS.SELECTORS.LOGOTYPE_LINK)
        };

        _homePageLink = _this.elems.$link.attr('href');

        return _this;
    };

    $.extend(HeaderLogo.prototype, {
        goToHome: function goToHome() {
            window.location.assign(_homePageLink);
        }
    });

    app.HeaderLogo = HeaderLogo;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, Modernizr) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            FORM: 'form',
            SEARCH_INPUT: 'input[type="text"]',
            AUTOCOMPLETE: '.ui-autocomplete'
        },
        MODIFIERS: {
            HIDE_AUTOCOMPLETE: 'search-box__hide-autocomplete'
        }
    };

    var SearchBox = function SearchBox($element) {
        var _this = this instanceof SearchBox ? this : Object.create(SearchBox.prototype);

        _this.elems = {
            $component: $element,
            $form: $element.find(DEFAULTS.SELECTORS.FORM),
            $input: $element.find(DEFAULTS.SELECTORS.SEARCH_INPUT),
            $div: $('<div/>')
        };

        DEFAULTS.SEARCH_URL = this.elems.$form.attr('action');

        _this.initialize();

        _this.bindEvents();

        return _this;
    };

    $.extend(SearchBox.prototype, {
        initialize: function initialize() {
            var _this = this;
            var account = _this.elems.$component.data('account-number');
            var searchDomain = _this.elems.$component.data('search-domain');
            var proxiedUnescapeHtmlEntity = $.proxy(_this._unescapeHtmlEntity, _this);
            var maxResults = 5;
            var adobeAutocompleteSettings = {
                account: account,
                searchDomain: searchDomain,
                inputElement: _this.elems.$input,
                inputFormElement: _this.elems.$form,
                appendTo: _this.elems.$component,
                delay: 150,
                minLength: 3,
                maxResults: maxResults,
                browserAutocomplete: false,
                queryCaseSensitive: false,
                startsWith: false,
                zindex: 100,
                header: '',
                footer: '',
                focus: proxiedUnescapeHtmlEntity,
                onSelect: proxiedUnescapeHtmlEntity
            };

            // Solution from http://jqueryui.com/autocomplete/#custom-data
            _this.elems.$input.AdobeAutocomplete(adobeAutocompleteSettings).data('autocomplete')._renderItem = function(ul, item) {
                return $('<li></li>')
                    .data('item.autocomplete', item)
                    .append($('<a></a>').html(item.label))
                    .appendTo(ul);
            };
        },

        _unescapeHtmlEntity: function(event, ui) {
            var value = this.elems.$div.html(ui.item.value).text();
            this.elems.$input.val(value);

            return false;
        },

        bindEvents: function bindEvents() {
            this.elems.$form.on('submit', $.proxy(this._doSearch, this));
            this.elems.$input.on('keydown', $.proxy(this._enableToShowAutocompleate, this));
            app.subscribe(app.EVENTS.PRODUCT_GRID_LOADED, $.proxy(this.onGridLoaded, this));

            if (Modernizr.touch) {
                this.elems.$input.on('autocompleteclose', $.proxy(this._keepAutocomplete, this));
                this.elems.$input.on('autocompleteopen', $.proxy(this._onRenderAutocomplete, this));
            }
        },

        _doSearch: function _doSearch(e) {
            e.preventDefault();

            this.elems.$component.addClass(DEFAULTS.MODIFIERS.HIDE_AUTOCOMPLETE);

            if (app.modules.Facets) {
                app.modules.Facets[0].closeFacets();
            }

            if (Modernizr.touch) {
                this.elems.$input.trigger('blur');
            }

            window.location.href = DEFAULTS.SEARCH_URL + encodeURIComponent(this.elems.$input.val());
        },

        _enableToShowAutocompleate: function _enableToShowAutocompleate() {
            this.elems.$component.removeClass(DEFAULTS.MODIFIERS.HIDE_AUTOCOMPLETE);
        },

        _onRenderAutocomplete: function _onRenderAutocomplete() {
            this.elems.$autocomplete = this.elems.$component.find(DEFAULTS.SELECTORS.AUTOCOMPLETE);
            this.isRendered = true;
        },

        _keepAutocomplete: function _keepAutocomplete() {
            var _this = this;

            if (_this.isRendered) {
                _this.elems.$autocomplete.show();

                $(document).one('click', function(event) {
                    if (!$(event.target).closest(_this.elems.$autocomplete).size()) {
                        _this.elems.$autocomplete.hide();
                    }
                });

                _this.isRendered = false;
            }
        },

        onGridLoaded: function onGridLoaded() {
            this.elems.$input.val('');
        }
    });

    app.SearchBox = SearchBox;

    return app.SearchBox;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.Modernizr);

;(function(window, document, $, dust) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            PLACEHOLDER: '.header-account__placeholder'
        }
    };

    /*
     * Constructor
     */
    var HeaderAccountButton = function HeaderAccountButton($element) {
        var _this = this instanceof HeaderAccountButton ? this : Object.create(HeaderAccountButton.prototype);

        _this.elems = {
            $component: $element,
            $placeholder: $element.find(DEFAULTS.SELECTORS.PLACEHOLDER)
        };
        _this.subModules = {};

        _this.initialize();
        _this.bindEvents();

        return _this;
    };

    $.extend(HeaderAccountButton.prototype, {
        initialize: function initialize() {
            this.subModules.drawer = new app.SignInDrawer(this.elems.$component);

            this.setButtonState(this.isUserLoggedIn());
        },

        bindEvents: function bindEvents() {
            var _this = this;

            app.subscribe(app.EVENTS.LOG_IN, function() {
                 _this.setButtonState(true);
             });

            app.subscribe(app.EVENTS.LOG_OUT, function() {
                _this.setButtonState(false);
            });
        },

        isUserLoggedIn: function isUserLoggedIn() {
            return app.modules.User.isLoggedIn();
        },

        setButtonState: function setButtonState(isLoggedIn) {
            this.elems.$component.toggleClass('logged-in', isLoggedIn);

            var data = app.modules.User.get();

            this.render(data);
        },

        render: function render(templateData) {
            var _this = this;

            dust.render('headerAccountButton', templateData, function(error, out) {
                _this.elems.$placeholder.html(out);
            });
        }
    });

    app.HeaderAccountButton = HeaderAccountButton;

    return app.HeaderAccountButton;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust);

;(function(window, document, $, dust, CQ) {

    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            SIGN_IN_FORM: 'form',
            REGISTRATION_LINK: '.header-account__sign-in__register__link'
        },
        SERVICES_URLS: {
            LOGOUT: '/services/sportchek/customers/logout'
        },
        VALIDATION_ERROR: 'validation-error',
        VALIDATION_ERROR_SHOW: 'validation-error_show'
    };

    /*
     * Constructor
     */
    var SignIn = function SignIn($element) {
        var _this = this instanceof SignIn ? this : Object.create(SignIn.prototype);

        _this.elems = {
            $component: $element
        };

        _this.$deferred = null;

        _this.subModules = {};

        _this.$validator = null;

        _this.initialize();

        return _this;
    };

    $.extend(SignIn.prototype, {
        initialize: function initialize() {
            this.render();

            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', '[data-action]', $.proxy(this.doAction, this));
            this.elems.$component.on('click', DEFAULTS.SELECTORS.REGISTRATION_LINK, $.proxy(this.clickRegister, this));

            app.subscribe(app.EVENTS.LOG_IN, $.proxy(this.render, this, true));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this.render, this, false));
        },

        doAction: function doAction(event) {
            event.preventDefault();

            var _this = this;
            var $actionButton = $(event.currentTarget);
            var action = $actionButton.data('action');

            switch (action) {
                case 'logIn':

                    if (_this.elems.$form.valid()) {
                        _this.elems.$component.spinner('show', {insertInside: true});

                        _this.$deferred = $.when(app.modules.User.logIn(_this.elems.$form));
                        _this.$deferred
                            .fail(function(jqXhr) {
                                if (jqXhr.status === 403) {
                                    var parsedResponse = JSON.parse(jqXhr.responseText);

                                    if (parsedResponse.messages[0].message === 'error.customers.login.credentials.invalid' && _this.$validator) {
                                        _this.$validator.showErrors({
                                            login: '',
                                            password: CQ.I18n.get(parsedResponse.messages[0].message)
                                        });
                                    }
                                }
                            })
                            .always(function() {
                                _this.elems.$component.spinner('hide');
                            });
                    }

                    break;

                case 'logOut':

                    // @TODO FIXME: CTCOFECM-26831
                    $.when(app.modules.User.logOut()).done(function() {
                        if (app.modules.AccountSideBar) {
                            app.modules.HeaderLogo[0].goToHome();
                        }

                        app.modules.HeaderAccountButton[0].subModules.drawer.closeDrawer(false);
                    });

                    break;

                case 'register':
                    app.modules.AuthModal[0].open({
                        step: 'register',
                        title: 'GLB0047'
                    });

                    break;

                case 'forgot-password':
                    app.modules.AuthModal[0].open({
                        step: 'forgot-password',
                        onOpen: function() {
                            app.modules.ForgotPassword[0].clearForm();
                        }
                    });

                    break;
            }
        },

        _bindValidate: function _bindValidate() {
            return this.elems.$form.validate({
                errorClass: DEFAULTS.VALIDATION_ERROR,
                errorElement: 'span',
                rules: {
                    login: {
                        required: true,
                        spcEmail: true
                    },
                    password: {
                        required: true,
                        spcPassword: true
                    }
                },
                messages: {
                    login: {
                        required: CQ.I18n.get('error.customers.validation.registerData.login.NotBlank'),
                        spcEmail: CQ.I18n.get('error.customers.validation.registerData.login.Pattern')
                    },
                    password: {
                        required: CQ.I18n.get('error.customers.validation.registerData.password.NotBlank'),
                        spcPassword: CQ.I18n.get('error.customers.validation.registerData.password.Pattern')
                    }
                },
                errorPlacement: function(error, input) {
                    $(input).after($(error).addClass(DEFAULTS.VALIDATION_ERROR_SHOW));
                }
            });
        },

        render: function render() {
            var _this = this;

            var settings = {
                userIsLoggedIn: app.modules.User.isLoggedIn(),
                forceRenderForm: _this.elems.$component.data('render-form')
            };

            dust.render('signIn', settings, function(error, out) {
                _this.elems.$component.html(out);

                app.createSubModule(_this.elems.$component, _this);

                _this.elems.$form = _this.elems.$component.find(DEFAULTS.SELECTORS.SIGN_IN_FORM);

                _this.$validator = _this._bindValidate();
            });
        },

        clickRegister: function clickRegister() {
            app.trigger(app.EVENTS.ANALYTICS.SHOW_REGISTER_MODAL, {formLocation: 'Header Sign-In'});
        }
    });

    app.SignIn = SignIn;

    return app.SignIn;

}).call(window.SPC = window.SPC || {}, window, document, jQuery, window.dust, window.CQ);

;(function(window, document, $) {

    var app = this;

    var DEFAULTS = {
        SERVICES: {
            FACEBOOK_SUCCESS_URL: '/services/sportchek/facebook/oauth/success'
        }
    };

    /*
     * Constructor
     */
    var FacebookSignIn = function FacebookSignIn($element) {
        var _this = this instanceof FacebookSignIn ? this : Object.create(FacebookSignIn.prototype);

        _this.elems = {
            $component: $element
        };

        _this.initialize();

        return _this;
    };

    $.extend(FacebookSignIn.prototype, {
        initialize: function initialize() {
            app.modules.LoginWithSocialNetwork = app.modules.LoginWithSocialNetwork || new app.LoginWithSocialNetwork();

            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', $.proxy(this.login, this));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this.logout, this));
        },

        login: function login() {
            // Save current URL that will used by service for redirection
            $.cookie(app.COOKIES.REFERRER_URL, window.location.href, {
                path: '/'
            });

            var facebookUrl = this.elems.$component.data('facebook-auth-url');
            var facebookAuthUrl = facebookUrl + window.location.origin + DEFAULTS.SERVICES.FACEBOOK_SUCCESS_URL;

            window.location.assign(facebookAuthUrl);
        },

        logout: function logout() {
            $.removeCookie(app.COOKIES.REFERRER_URL, {
                path: '/'
            });
        }
    });

    app.FacebookSignIn = FacebookSignIn;

    return app.FacebookSignIn;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, _, dust, Modernizr, Response, undefined) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            CART_COUNT_ID: '#header-cart__count',
            HEADER_CART_TRIGGER: '.header-cart__trigger',
            HEADER_CART_CONTAINER: '.header-cart__container',
            HEADER_CART_CHECKOUT: '.header-cart__checkout',
            HEADER_CART_CONTENT: '.header-cart__content'
        },
        GET_CART_URL: '/services/sportchek/cart/mini',
        ACTIVE_CLASS: 'active'
    };

    var MiniCart = function MiniCart($element) {
        var _this = this instanceof MiniCart ? this : Object.create(MiniCart.prototype);

        _this.elems = {
            $component: $element,
            $miniCartContainer: $element.find(DEFAULTS.SELECTORS.HEADER_CART_CONTAINER),
            $headerCartTrigger: $element.find(DEFAULTS.SELECTORS.HEADER_CART_TRIGGER),
            $miniCartContent: $()
        };

        _this.elems.$headerCartCount = _this.elems.$component.find(DEFAULTS.SELECTORS.CART_COUNT_ID);

        _this.unitCount = 0;
        _this.subTotal = 0;
        _this.modal = null;
        _this.getFromServiceInProgress = false;
        _this.data = {};

        _this.initialize();

        return _this;
    };

    $.extend(MiniCart.prototype, {
        initialize: function initialize() {

            if (typeof (this._getFromCookie()) === 'undefined') {
                this.getFromService();
            }

            this.bindEvents();
        },

        doAction: function doAction(e, location) {
            location = location || window.location;
            e.preventDefault();

            var $button = window.$(e.currentTarget);
            var action = $button.data('action');

            switch (action) {
                case 'continueShopping':

                    this._hideContent();

                    break;

                case 'viewCart':

                    if (Modernizr.touch && Response.band(768) && $button.hasClass(DEFAULTS.SELECTORS.HEADER_CART_TRIGGER.slice(1))) {
                        this._getMiniCart();

                        return;
                    }

                    location.assign($button.attr('href'));

                    break;

                case 'goToProductDetailsPage':
                    location.assign($button.attr('href'));

                    this._hideContent();

                    break;
            }
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', '[data-action]', $.proxy(this.doAction, this));
            this.elems.$component.one('mouseover', DEFAULTS.SELECTORS.HEADER_CART_TRIGGER, $.proxy(this._getMiniCart, this));

            app.subscribe(app.EVENTS.UPDATE_CART, $.proxy(this.updateCart, this));
            app.subscribe(app.EVENTS.LOG_IN, $.proxy(this.getFromService, this));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this.getFromService, this, false));
            app.subscribe(app.EVENTS.CLOSE_DRAWER, $.proxy(this._resetContentScroll, this));
        },

        _getMiniCart: function _getMiniCart() {
            if (_.isEmpty(this.data)) {
                this.getFromService();
            }
        },

        updateCart: function updateCart(data) {
            data = data || {};

            if (data.totalUnitCount === undefined) {
                this.getFromService();
            } else {
                this.refreshData(data);
            }
        },

        refreshData: function refreshData(data) {
            this._setCartDataToCookie(data);
            this.updateQuantity(data.totalUnitCount);
            this.subTotal = data.subTotal;
            this.render(data);
        },

        /**
         * Do synchronous request if method called from 'LOG_OUT' global event
         * @param {Boolean} [async]
         */
        getFromService: function getFromService(async) {
            var _this = this;

            if (_this.getFromServiceInProgress) {
                return;
            }

            $.ajax({
                url: DEFAULTS.GET_CART_URL,
                type: 'GET',
                dataType: 'JSON',
                cache: false,
                async: async !== false,
                beforeSend: function() {
                    _this.getFromServiceInProgress = true;
                },
                success: function(data) {
                    _this.refreshData(data);
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    console.error('"MiniCart.getFromService" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                },
                complete: function() {
                    _this.getFromServiceInProgress = false;
                }
            });
        },

        /**
         * Get and parse mini cart object from cookie
         * @returns {Object|undefined} miniCart
         * @private
         */
        _getFromCookie: function _getFromCookie() {
            var miniCartData = $.cookie(app.COOKIES.MINI_CART);

            if (miniCartData) {
                var miniCartTotalUnitCount = JSON.parse(miniCartData).totalUnitCount;

                this.updateQuantity(miniCartTotalUnitCount);
            }

            return miniCartData;
        },

        /**
         * Stringify and set to cookie data from request
         * @param data {Object}
         * @private
         */
        _setCartDataToCookie: function _setCartDataToCookie(data) {
            $.cookie(app.COOKIES.MINI_CART, JSON.stringify({
                totalUnitCount: data.totalUnitCount,
                code: data.code,
                totalItems: data.totalItems
            }), {
                path: '/'
            });
        },

        /**
         * Update quantity from cookie or service
         * @param {Number} totalUnitCount
         */
        updateQuantity: function updateQuantity(totalUnitCount) {
            var _this = this;

            _this.unitCount = totalUnitCount || 0;

            _this.elems.$headerCartCount.text(_this.unitCount || '');
        },

        /**
         * Return quantity of products in cart
         * @returns {number}
         */
        getQuantity: function getQuantity() {
            return this.unitCount;
        },

        render: function render(data) {
            var _this = this;

            _this.data = data;

            dust.render('miniCartProductsContent', data, function(error, out) {
                _this.elems.$miniCartContainer.html(out);
                _this.elems.$miniCartContent = _this.elems.$miniCartContainer.find(DEFAULTS.SELECTORS.HEADER_CART_CONTENT);
            });
        },

        _hideContent: function _hideContent() {
            this.elems.$component.removeClass(DEFAULTS.ACTIVE_CLASS);
        },

        _resetContentScroll: function _resetContentScroll() {
            if (this.elems.$miniCartContent.length > 0) {
                this.elems.$miniCartContent.scrollTop(0);
            }
        }
    });

    app.MiniCart = MiniCart;

    return app.MiniCart;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.dust, window.Modernizr, window.Response);

;(function(window, document, $, _, dust) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            HEADER_CART_CLASS: '.header-cart',
            HEADER_CART_CONFIRMATION_CLASS: 'header-cart_confirmation',
            HEADER_CART_CONTAINER_ID: '#header-cart__container',
            HTML_BODY: 'html, body'
        },
        SCROLL_TOP_ANISMATION_SPEED: 1000,
        DELAY: 4000
    };

    var CartConfirmationMessage = function CartConfirmationMessage($element) {
        var _this = this instanceof CartConfirmationMessage ? this : Object.create(CartConfirmationMessage.prototype);

        _this.elems = {
            $component: $element,
            $headerCart: $(DEFAULTS.SELECTORS.HEADER_CART_CLASS),
            $body: $(DEFAULTS.SELECTORS.HTML_BODY),
            $headerCartContainer: $(DEFAULTS.SELECTORS.HEADER_CART_CONTAINER_ID)
        };

        return _this;
    };

    $.extend(CartConfirmationMessage.prototype, {

        /**
         * @param data {Object}
         * @param skuList {Array}
         * @returns {Array}
         * @private
         */
        _getImageUrls: function _getImageUrls(data, skuList) {
            var images = [];

            for (var i = 0; i < skuList.length; i++) {

                for (var index = 0; index < data.entries.length; index++) {
                    var entry = data.entries[index];

                    if (entry.product && entry.product.code === skuList[i]) {
                        images.push(entry.productPictureUrl);
                    }
                }
            }

            return images;
        },

        /**
         * @param data {Object}
         * @param skuList {Array}
         * @param imageUrl {String}
         */
        show: function show(data, skuList, imageUrl) {
            var _this = this;
            var confirmationInstance = null;
            var images = imageUrl ? [imageUrl] : _this._getImageUrls(data, skuList);
            var templateData = {
                images: images
            };

            dust.render('cartConfirmationMessage', templateData, function(error, out) {
                // Remove previous DOM-element if user clicks "Add to cart" button many times
                _this.elems.$headerCartContainer.next().remove();
                _this.elems.$headerCart.addClass(DEFAULTS.SELECTORS.HEADER_CART_CONFIRMATION_CLASS);
                _this.elems.$headerCartContainer.after(out);

                clearTimeout(confirmationInstance);

                confirmationInstance = setTimeout(function() {
                    _this.elems.$headerCart.removeClass(DEFAULTS.SELECTORS.HEADER_CART_CONFIRMATION_CLASS);
                    _this.elems.$headerCartContainer.next().remove();
                }, DEFAULTS.DELAY);
            });

            // Don`t scroll if we add product to cart from QuickView
            if (!app.modules.ProductGridItem || app.modules.ProductGridItem.length === 0) {
                _this._scrollTop();
            }
        },

        _scrollTop: function _scrollTop() {
            this.elems.$body.animate({
                scrollTop: 0
            }, DEFAULTS.SCROLL_TOP_ANISMATION_SPEED);
        }
    });

    app.CartConfirmationMessage = CartConfirmationMessage;

    return CartConfirmationMessage;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.dust);
;(function(window, document, $, dust) {
    var app = this;

    var BackButton = function BackButton($element) {
        var _this = this instanceof BackButton ? this : Object.create(BackButton.prototype);

        _this.elems = {
            $component: $element
        };

        _this.ingoreList = _this.elems.$component.data('ignore-list');

        if (app.modules.Page) {
            _this.initialize();
        }

        return _this;
    };

    $.extend(BackButton.prototype, {
        initialize: function initialize() {
            var templateData = null;
            var previousPageData = app.modules.Page.getPreviousData();

            if (previousPageData && $.inArray(previousPageData.title, this.ingoreList) === -1) {
                templateData = previousPageData;
            }

            this.render(templateData);
        },

        render: function render(templateData) {
            var _this = this;

            dust.render('backButton', templateData, function(error, out) {
                _this.elems.$component.html(out);
            });
        }
    });

    app.BackButton = BackButton;

    return app.BackButton;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust);
;(function(window, document, $, Response) {
    var DEFAULTS = {
        SELECTORS: {
            // TODO: two separate elements NEXT: and CLOSE:
            OVERLAY_ELEMENT: '.quickview__btn_next, .quickview__close',
            FOOTER: '.page-footer',
            TOP_BTN_STICK_TO_ATTR: '[data-top-button-stickto]',
            FOOTER_MOBILE_TRIGGER: '.footer-section__head-trigger'
        },
        CLASSES: {
            SHIFT: 'shift',
            STICKY: 'top-button_sticky'
        },
        BREAKPOINTS: [
            {
                width: 1024,
                height: 400
            },
            {
                width: 768,
                height: 240
            },
            {
                width: 320,
                height: 200
            }
        ]
    };

    var app = this;

    var TopButton = function TopButton($element) {
        var _this = this instanceof TopButton ? this : Object.create(TopButton.prototype);

        _this.elems = {
            $component: $element,
            $pageFooter: $(DEFAULTS.SELECTORS.FOOTER),
            $scrollable: $('html, body'),
            $doc: $(document),
            $window: $(window),
            $overlays: $(DEFAULTS.SELECTORS.OVERLAY_ELEMENT),
            $footerMobileTrigger: $(DEFAULTS.SELECTORS.FOOTER_MOBILE_TRIGGER)
        };

        _this.stickTo = _this.elems.$component.attr(DEFAULTS.SELECTORS.TOP_BTN_STICK_TO_ATTR) || 'bottom';
        _this.buttonOffset = parseInt(_this.elems.$component.css(_this.stickTo), 10);
        _this.scrollStart = 200;
        _this.scrollEnd = 0;

        _this.bindEvents();

        return _this;
    };

    $.extend(TopButton.prototype, {
        bindEvents: function bindEvents() {
            this.elems.$component.on('click', $.proxy(this.onClick, this));

            // For proper position of the "Back to Top" button on footer headers toggle
            this.elems.$footerMobileTrigger.on('click', $.proxy(this.onScroll, this));

            this.elems.$window.on('scroll', $.proxy(this.onScroll, this))
                .on('load resize', $.proxy(this.checkResolution, this));

            // Grid loading extends document height
            app.subscribe(app.EVENTS.PRODUCT_GRID_LOADED, $.proxy(this.checkResolution, this));
        },

        onClick: function onClick() {
            var _this = this;
            var top = _this.elems.$window.scrollTop();

            if (top > _this.scrollStart) {
                _this.elems.$scrollable.animate({
                    scrollTop: 0
                }, 1000);
            }

            return false;
        },

        onScroll: function onScroll() {
            var _this = this;
            var top = _this.elems.$window.scrollTop();

            switch (true) {
                case (top < _this.scrollStart):
                    _this.elems.$component.stop(true, true).fadeOut();

                    break;

                case (top > _this.scrollEnd):
                    _this.elems.$component.addClass(DEFAULTS.CLASSES.STICKY);
                    _this.elems.$component.css(_this.stickTo, _this.buttonOffset + _this.elems.$pageFooter.height() + 'px');

                    break;

                default:
                    _this.elems.$component.removeClass(DEFAULTS.CLASSES.STICKY);
                    _this.elems.$component.css(_this.stickTo, _this.buttonOffset + 'px');
                    _this.elems.$component.stop(true, true).fadeIn();
            }

            if (_this.isOverlay()) {
                _this.elems.$component.addClass(DEFAULTS.CLASSES.SHIFT);
            } else {
                _this.elems.$component.removeClass(DEFAULTS.CLASSES.SHIFT);
            }
        },

        isOverlay: function isOverlay() {
            var _this = this;
            var button = {};
            var response = false;

            if (_this.elems.$overlays.length === 0) {
                return false;
            }

            _this.elems.$overlays.each(function() {
                var $overlay = $(this);

                $overlay.cord = [$overlay.offset().top, $overlay.offset().top + $overlay.outerHeight()];

                var offsetAndHeight = _this.elems.$component.offset().top + _this.elems.$component.outerHeight();

                button.cord = [_this.elems.$component.offset().top, offsetAndHeight];

                if (
                    (button.cord[1] > $overlay.cord[0] && button.cord[0] < $overlay.cord[0]) ||
                    (button.cord[0] > $overlay.cord[1] && button.cord[0] < $overlay.cord[0]) ||
                    (button.cord[1] > $overlay.cord[1] && button.cord[0] < $overlay.cord[1]) ||
                    (button.cord[0] > $overlay.cord[0] && button.cord[1] < $overlay.cord[1])
                    ) {

                    response = true;
                }
            });

            return response;
        },

        checkResolution: function checkResolution() {
            var _this = this;

            $.each(DEFAULTS.BREAKPOINTS, function(index, currentBreakpoint) {
                if (Response.band(currentBreakpoint.width)) {
                    _this.scrollStart = currentBreakpoint.height;

                    return false;
                }
            });

            _this.calculateDistance();
            _this.onScroll();
        },

        // To calculate the actual scroll distance excluding page footer
        calculateDistance: function calculateDistance() {
            this.scrollEnd = this.elems.$doc.height() - this.elems.$pageFooter.height() - this.elems.$window.height();
        }
    });

    app.TopButton = TopButton;

    return app.TopButton;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.Response);

;(function(window, document, $, CQ) {
    var app = this;

    /**
     * Default variables
     */
    var DEFAULTS = {
        DO_NOT_DISPLAY: ['*']
    };

    var PageTitle = function PageTitle($element) {
        var _this = this instanceof PageTitle ? this : Object.create(PageTitle.prototype);

        _this.elems = {
            $component: $element
        };

        return _this;
    };

    $.extend(PageTitle.prototype, {
        changeTitle: function changeTitle(searchQuery) {
            var text = CQ.I18n.get('SCH0016');

            if (searchQuery && $.inArray(searchQuery, DEFAULTS.DO_NOT_DISPLAY) === -1) {
                text += ' ' + searchQuery;
            }

            this.elems.$component.text(text);
        }
    });

    app.PageTitle = PageTitle;

    return app.PageTitle;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);
;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            TRIGGER_CLASS: '.footer-section__trigger',
            MOBILE_TRIGGER_CLASS: '.footer-section__head-trigger',
            COLUMN: '.footer-section__show-more',
            LINKS: '.footer-section__menu-link'
        },
        MODIFIERS: {
            OPEN: 'footer-section_state_opened',
            ACTIVE: 'active',
            TOUCH: 'touch',
            LESS_THEN_IE9: 'lt-ie9',
            HIDDEN_LINKS: 'footer-section__menu-link_hidden'
        },
        // TODO: move it to jsp template
        WRAPPER: '<div class="footer-section__menu-content"></div>'
    };

    var ShowMore = function ShowMore($element) {
        var _this = this instanceof ShowMore ? this : Object.create(ShowMore.prototype);

        _this.elems = {
            $component: $element,
            $columns: $element.find(DEFAULTS.SELECTORS.COLUMN),
            $trigger: $element.find(DEFAULTS.SELECTORS.TRIGGER_CLASS),
            $mobileTrigger: $element.find(DEFAULTS.SELECTORS.MOBILE_TRIGGER_CLASS),

            $html: $('html'),
            $bodyAndHtml: $('html, body')
        };

        _this.initialize();

        return _this;
    };

    $.extend(ShowMore.prototype, {
        initialize: function initialize() {
            this._wrapHiddenLinks();

            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$trigger.on('click', $.proxy(_this._toggleContent, _this));
            _this.elems.$mobileTrigger.on('click', $.proxy(_this._toggleMobileContent, _this));

            app.subscribe(app.EVENTS.LOG_IN, $.proxy(this._wrapHiddenLinks, this));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this._wrapHiddenLinks, this));
        },

        _wrapHiddenLinks: function _wrapHiddenLinks() {
            this.elems.$columns.each(function() {
                var $column = $(this);

                $column
                    .find(DEFAULTS.SELECTORS.LINKS + ':not(".' + DEFAULTS.MODIFIERS.HIDDEN_LINKS + '"):gt(3)')
                    .wrapAll(DEFAULTS.WRAPPER);
            });
        },

        _toggleMobileContent: function _toggleMobileContent(e) {
            $(e.target)
                .closest(DEFAULTS.SELECTORS.COLUMN)
                    .toggleClass(DEFAULTS.MODIFIERS.ACTIVE);
        },

        _toggleContent: function _toggleContent() {
            var _this = this;

            _this.elems.$component.toggleClass(DEFAULTS.MODIFIERS.OPEN);

            if (!_this.elems.$html.hasClass(DEFAULTS.MODIFIERS.TOUCH)) {
                if (_this.elems.$html.hasClass(DEFAULTS.MODIFIERS.LESS_THEN_IE9)) {
                    _this.elems.$bodyAndHtml.scrollTop(_this.elems.$trigger.offset().top);
                } else {
                    _this.elems.$bodyAndHtml.animate({
                        scrollTop: _this.elems.$trigger.offset().top
                    });
                }
            }
        }
    });

    app.ShowMore = ShowMore;

    return app.ShowMore;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            HIDDEN_LINK: '.footer-section__menu-link_hidden'
        }
    };

    var HelpfulLinks = function HelpfulLinks($element) {
        var _this = this instanceof HelpfulLinks ? this : Object.create(HelpfulLinks.prototype);

        _this.elems = {
            $component: $element,
            $hiddenLinks: $element.find(DEFAULTS.SELECTORS.HIDDEN_LINK)
        };

        _this.initialize();

        return _this;
    };

    $.extend(HelpfulLinks.prototype, {
        initialize: function initialize() {
            this.bindEvents();
            this._toggleLinks(app.modules.User.isLoggedIn());
        },

        bindEvents: function bindEvents() {
            app.subscribe(app.EVENTS.LOG_IN, $.proxy(this._toggleLinks, this, true));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this._toggleLinks, this, false));
        },

        _toggleLinks: function _toggleLinks(isUserLoggedIn) {
            this.elems.$hiddenLinks.toggle(isUserLoggedIn);
        }
    });

    app.HelpfulLinks = HelpfulLinks;

    return app.HelpfulLinks;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, _) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            INPUT_ATTRIBUTE: '[data-form-blocking="input"]',
            BUTTON_ATTRIBUTE: '[data-form-blocking="button"]'
        },
        DISABLED_CLASS: 'button_state_disabled'
    };

    var FormBlocking = function FormBlocking($element) {
        var _this = this instanceof FormBlocking ? this : Object.create(FormBlocking.prototype);

        _this.elems = {
            $component: $element,
            $inputs: $element.find(DEFAULTS.SELECTORS.INPUT_ATTRIBUTE),
            $buttons: $element.find(DEFAULTS.SELECTORS.BUTTON_ATTRIBUTE)
        };

        _this.initialize();
        _this.bindEvents();

        return _this;
    };

    $.extend(FormBlocking.prototype, {
        initialize: function initialize() {
            this.elems.$buttons.prop('disabled', true);
            this.elems.$buttons.addClass(DEFAULTS.DISABLED_CLASS);
        },

        bindEvents: function bindEvents() {
            this.onChange = this._nextTickProxy(this.onChange);
            this.elems.$inputs.on('keyup input change', this.onChange);
            this.elems.$component.on('reset', this.onChange);
            this.elems.$component.on('inputsUpdated', $.proxy(this.reinitialize, this));
        },

        reinitialize: function reinitialize() {
            this.updateValues();
            this.onChange();
        },

        onChange: function onChange() {
            var disable = this._haveEmptyFields() || !this._haveChanges();

            this.elems.$buttons.prop('disabled', disable);
            this.elems.$buttons.toggleClass(DEFAULTS.DISABLED_CLASS, disable);
        },

        _haveEmptyFields: function _haveEmptyFilds() {
            var _this = this;
            var someEmpty = false;
            var checkedRadios = []; // For prevent rechecking radio group

            _this.elems.$inputs.each(function() {
                var $input = $(this);

                if ($input.data('form-blocking-skip-empty')) {
                    return;
                }

                var value = $input.val();
                var name = $input.attr('name');

                switch (true) {
                    case $input.is(':radio') && !_.contains(checkedRadios, name):
                        someEmpty = _this.elems.$inputs.filter('[name=' + name + ']:checked').size() === 0;
                        checkedRadios.push(name);

                        break;

                    // FIXME: .prop('checked') not work for checkboxes
                    case $input.is(':checkbox'):
                        if ($input.is(':checkbox[data-required]') === true) {
                            someEmpty = !$input.prop('checked');
                        } else {
                            someEmpty = false;
                        }

                        break;

                    case $input.is('textarea'):
                        someEmpty = $input.data('placeholder') ? ((value === $input.data('placeholder')) || _.isEmpty($.trim(value))) : _.isEmpty($.trim(value));

                        break;

                    default:

                        if ('rawMaskFn' in $input.data()) {
                            value = value.replace(/_/g, '').replace(/-/g, '');
                        }

                        someEmpty = _.isEmpty($.trim(value));
                }

                return !someEmpty;
            });

            return someEmpty;
        },

        _haveChanges: function _haveChanges() {
            var noChanges = true;
            var _this = this;

            this.elems.$inputs.each(function() {
                var $input = $(this);
                var value = _this._getInputValue($input);

                noChanges = value === $input.data('init-value');

                return noChanges;
            });

            return !noChanges;
        },

        updateValues: function updateValues() {
            var _this = this;

            this.elems.$inputs.each(function() {
                var $input = $(this);
                var value = _this._getInputValue($input);

                $input.data('init-value', value);
            });
        },

        _getInputValue: function _getInputValue($input) {
            var value = '';

            switch (true) {
                case $input.is(':radio'):

                case $input.is(':checkbox'):
                    value = $input.prop('checked');

                    break;

                default:
                    value = $input.val();
            }

            return value;
        },

        _nextTickProxy: function _nextTickProxy(call) {
            var _this = this;
            // Fix for IE8
            return function() {
                setTimeout($.proxy(call, _this), 0);
            };
        }
    });

    app.FormBlocking = FormBlocking;

    return app.FormBlocking;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._);

;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            DROPDOWN_SELECTOR: '.dropdown',
            DROPDOWN_INIT_CLS: 'dropdown_ready',
            SELECTED_CLASS: 'dropdown_selected',
            VALUE_CONTAINER_CLS: 'dropdown__value'
        }
    };

    var FormDropdown = function FormDropdown(el) {
        var _this = this instanceof FormDropdown ? this : Object.create(FormDropdown.prototype);

        _this.elems = {
            $component: $(el),
            $wrapper: $(el).parent(DEFAULTS.DROPDOWN_SELECTOR),
            $window: $(window)
        };

        _this.initialize();

        return _this;
    };

    $.extend(FormDropdown.prototype, {
        initialize: function initialize() {
            this.initDropdown();
            this.checkSelected();
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('change', $.proxy(function() {
                this.checkSelected();
                this.elems.$value.text(this.getCheckedText());
            }, this));
            // NOTE: workaround against mobile Chrome bug
            this.elems.$window.on('orientationchange', $.proxy(this._forceClose, this));
        },

        checkSelected: function checkSelected($select) {
            var $selectEl = $select || this.elems.$component;

            this.elems.$wrapper.toggleClass(DEFAULTS.SELECTORS.SELECTED_CLASS, Boolean($selectEl.val()));
        },

        initDropdown: function initDropdown() {
            this.elems.$wrapper
                .append('<div class="' + DEFAULTS.SELECTORS.VALUE_CONTAINER_CLS + '">' + this.getCheckedText() + '</div>')
                .addClass(DEFAULTS.SELECTORS.DROPDOWN_INIT_CLS);

            this.elems.$value = this.elems.$wrapper.find('.' + DEFAULTS.SELECTORS.VALUE_CONTAINER_CLS);
        },

        getCheckedText: function getCheckedText() {
            return this.elems.$component.children(':selected').text();
        },

        _forceClose: function _forceClose() {
            this.elems.$component.trigger('blur');
        }
    });

    app.FormDropdown = FormDropdown;

    return FormDropdown;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $) {
    var app = this;

    /**
     * Default variables
     */

    var DEFAULTS = {
        SCROLL_SPEED: 1000,
        // This distance add for remove sticking of content to top of window
        ADDITIONAL_DISTANCE: 40,
        SELECTORS: {
            HEADER: '.page-header',
            PAGE_SCROLL_CONTAINER: 'html, body'
        }
    };

    /*
     * Constructor
     */
    var AnchorLink = function AnchorLink($element) {
        var _this = this instanceof AnchorLink ? this : Object.create(AnchorLink.prototype);

        _this.elems = {
            $component: $element,
            $header: $(DEFAULTS.SELECTORS.HEADER),
            $pageScrollContainer: $(DEFAULTS.SELECTORS.PAGE_SCROLL_CONTAINER)
        };

        _this.bindEvents();

        return _this;
    };

    $.extend(AnchorLink.prototype, {
        bindEvents: function() {
            var _this = this;

            _this.elems.$component.on('click', function(e) {
                e.preventDefault();

                var href = $(this).attr('href');

                _this.animateToAnchor(href);
            });
        },

        animateToAnchor: function(id) {
            var _this = this;
            var $anchor = $(id);
            var fixedHeaderHeight = (_this.elems.$header.css('position') === 'fixed' ? _this.elems.$header.height() : 0);

            if (_this.elems.$pageScrollContainer.is(':animated')) {
                return false;
            }

            /*
             * When header have fixed position it's not include in anchor jump
             * header position changed on change screen width, that's why it's position don't cached
             */
            _this.elems.$pageScrollContainer.animate({
                scrollTop: $anchor.offset().top - fixedHeaderHeight - DEFAULTS.ADDITIONAL_DISTANCE
            }, DEFAULTS.SCROLL_SPEED);

            // When page is animated user must still be able to scroll
            $(window).one('mousewheel', function() {
                _this.elems.$pageScrollContainer.stop();
            });

            window.location.hash = id.replace('#', '');
        }
    });

    app.AnchorLink = AnchorLink;

    return app.AnchorLink;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, _, Response, Modernizr) {
    var app = this;

    var DEFAULTS = {
        CLASSES: {
            FIXED: 'fixed',
            LT_IE9: 'lt-ie9'
        },
        DELAY: 500,
        THROTTLE: 200
    };

    var PinBlock = function($element) {
        var _this = this instanceof PinBlock ? this : Object.create(PinBlock.prototype);

        _this.DEFAULTS = DEFAULTS;
        _this.elems = {
            $component: $element,
            $window: $(window),
            $html: $('html'),
            $container: $($element.data('pinContainer') || window),
            $wrapper: $($element.data('pinWidth') || window)
        };

        _this.breakpoints = _this.getBreakpoints(_this.elems.$component);
        _this.padding = parseInt(_this.elems.$component.data('pinPadding'), 10) || 0;
        _this.blockHeight = 0;
        _this.currentScrollPosition = 0;

        _this.elems.$window.on('load', function() {
            _this.initialize();
            _this.bindEvents();
        });

        return _this;
    };

    $.extend(PinBlock.prototype, {
        initialize: function initialize() {

            if (Response.band(0, (this.breakpoints[0] - 1))) {
                return false;
            }

            this.startTopPosition = this.elems.$component.offset().top;

            // If pinned block has top margin
            this.startTopMargin = this.elems.$component.css('marginTop');

            // Is default position of fixed element equal to padding
            this.fixedOffset = ((this.startTopPosition + this.startTopMargin) === this.padding) ? '' : this.startTopPosition - this.padding;

            this.elems.$component.width(this.elems.$wrapper.width());

            // Cache initial block height & position
            this.blockHeight = this.elems.$component.outerHeight(true);
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.intervalID = setInterval(function() {
                _this.checkResize();
            }, _this.DEFAULTS.DELAY);

            _this.elems.$window.on('scroll', $.proxy(this.checkPosition, this));

            if (('onorientationchange' in window) && Modernizr.touch) {
                _this.elems.$window.on('orientationchange', _.throttle($.proxy(this.resizeHandler, this), _this.DEFAULTS.THROTTLE));
            } else {
                // Ie8 resize event fix
                if (_this.elems.$html.hasClass(_this.DEFAULTS.CLASSES.LT_IE9)) {
                    var width = _this.elems.$window.width();
                    var height = _this.elems.$window.height();

                    _this.elems.$window.resize(_.throttle(function() {
                        var newWidth = _this.elems.$window.width();
                        var newHeight = _this.elems.$window.height();

                        _this.checkPosition();

                        if (newWidth !== width || newHeight !== height) {
                            width = newWidth;
                            height = newHeight;
                            _this.resizeHandler();
                        }
                    }, _this.DEFAULTS.THROTTLE));
                } else {
                    _this.elems.$window.on('resize', _.throttle($.proxy(_this.resizeHandler, _this), _this.DEFAULTS.THROTTLE));
                }
            }

            _this.elems.$component.on('click resize.pinBlock', $.proxy(_this.checkPosition, _this));

        },

        checkResize: function checkResize() {
            var height = this.elems.$component.outerHeight(true);

            // If element size has changed since the last time, update the element stored height and trigger the 'resize' event.
            if (height !== this.blockHeight) {
                this.blockHeight = height;
                this.elems.$component.trigger('resize.pinBlock');
            }
        },

        checkPosition: function checkPosition() {
            this.currentScrollPosition = this.elems.$window.scrollTop();

            var distance = this.currentScrollPosition - this.startTopPosition + this.padding;
            var blockHeight = this.elems.$component.outerHeight(true);
            var windowWidth = this.elems.$window.width();
            var containerHeight = this.elems.$container.height();
            var containerOffsetWithHeight = this.elems.$container.offset().top + containerHeight;

            // Check breakpoints
            if ((this.breakpoints && (windowWidth < this.breakpoints[0] || windowWidth > this.breakpoints[1])) || blockHeight > containerHeight) {
                // CTCOFECM-22082: browser's native events is bubbling up to this handler & preventing if return value
                this.setStartPosition();
            } else {
                // Check pinned block position
                if (distance > 0) {
                    var offset = (this.fixedOffset > 0) ? this.padding : this.fixedOffset;

                    if (blockHeight + distance + this.startTopPosition > containerOffsetWithHeight) {
                        // Bottom reached
                        var relativeParentOffset = this.elems.$component.parents().filter(function() {
                            var $element = $(this);

                            return $element.is('body') || $element.css('position') !== 'static';
                        }).slice(0, 1).offset().top;

                        this.elems.$component.css({
                            top: (containerOffsetWithHeight - blockHeight - relativeParentOffset) + 'px',
                            position: 'absolute'
                        }).removeClass(this.DEFAULTS.CLASSES.FIXED);
                    } else {
                        if (this.fixedOffset < 0) {
                            this.elems.$component.css({
                                top: 'auto',
                                position: 'fixed'
                            });

                            // If default position of fixed element is not equal to padding
                            if (this.fixedOffset) {
                                this.elems.$component.css({
                                    marginTop: -this.fixedOffset + 'px'
                                });
                            }
                        } else {
                            this.elems.$component.css({
                                top: offset,
                                position: 'fixed'
                            });
                        }
                        this.elems.$component.addClass(this.DEFAULTS.CLASSES.FIXED);
                    }
                } else {
                    if (distance <= 0 && this.elems.$component.css('top') !== 0) {
                        // Top reached
                        this.setStartPosition();
                    }
                }
            }
        },

        resizeHandler: function resizeHandler() {

            if (Response.band(0, (this.breakpoints[0] - 1))) {
                this.setStartPosition();

                return false;
            }

            this.elems.$window.scrollTop(0);

            // Clear inline styles to use default css values
            this.elems.$component.css({
                position: '',
                marginTop: '',
                width: '',
                top: ''
            });

            this.initialize();
            this.checkPosition();
        },

        setStartPosition: function setStartPosition() {
            this.elems.$component.css({
                top: '',
                position: '',
                marginTop: ''
            }).removeClass(this.DEFAULTS.CLASSES.FIXED);
        },

        getBreakpoints: function getBreakpoints($component) {
            var result = false;
            var data = $component.data('pinBreakpoints');

            if (data) {
                result = $.map(data.toString().split(',', 2), function(breakpoint) {
                    return Number(breakpoint);
                });

                if (result.length === 1) {
                    result.push(Infinity);
                }
            }

            return result;
        }
    });

    app.PinBlock = PinBlock;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.Response, window.Modernizr);

// TODO: this component must be removed from global category.

;(function(window, document, $, Response, _, Modernizr) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SELECTORS: {
            PLACEHOLDER_TEMPLATE: '#tab-placeholder-template',
            HEADER: '.page-header',
            PAGE_CONTAINER: '.page-container',
            PAGE_CONTENT: '.page-content',
            PLACEHOLDER: '.global-tab-placeholder',
            ALPHABET_NAV: '.alphabet-nav',
            ALPHABET_NAV_WRAP: '.alphabet-nav__wrap',
            TAB_PANEL_WRAPPER: '.global-tab-panel-wrapper'
        },
        CLASSES: {
            DOCK_TAB_PANEL: 'dock-tab-panel',
            STICKY_TAB_PANEL: 'sticky-tab-panel',
            ACTIVE_CLASS: 'active',
            IS_IE8: 'lt-ie9'
        },
        DATA_ALPHABET_NAV: 'alphabetNav'
    };

    /*
     * Constructor
     */
    var HeaderStickyPanel = function HeaderStickyPanel($element) {

        var _this = this instanceof HeaderStickyPanel ? this : Object.create(HeaderStickyPanel.prototype);

        _this.elems = {
            $component: $element,
            $alphabetNav: $element.find(DEFAULTS.SELECTORS.ALPHABET_NAV),
            $alphabetNavWrap: $element.find(DEFAULTS.SELECTORS.ALPHABET_NAV_WRAP),
            $header: $(DEFAULTS.SELECTORS.HEADER),
            $body: $('body'),
            $pageContainer: $(DEFAULTS.SELECTORS.PAGE_CONTAINER),
            $stickyContainer: $element.parents(DEFAULTS.SELECTORS.TAB_PANEL_WRAPPER),
            $window: $(window)
        };

        _this.isAlphabetnav = _this.elems.$component.data(DEFAULTS.DATA_ALPHABET_NAV);
        _this.elems.$pageContainer.prepend($(DEFAULTS.SELECTORS.PLACEHOLDER_TEMPLATE).html());
        _this.elems.$placeholder = $(DEFAULTS.SELECTORS.PLACEHOLDER);

        _this.initialize();

        return _this;
    };

    $.extend(HeaderStickyPanel.prototype, {

        initialize: function initialize() {
            // NOTE: Don't initialize module if this is IE8
            if ($(document.documentElement).hasClass(DEFAULTS.CLASSES.IS_IE8)) {
                return;
            }

            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$window.on('load', $.proxy(_this.onLoadInit, _this));
        },

        onLoadInit: function onLoadInit() {
            this.elems.$window.on('resize', _.throttle($.proxy(this.handleResize, this), 1000));
            this.handleResize();
        },

        bindSticky: function() {
            this.elems.$stickyContainer = this.elems.$component.parents(DEFAULTS.SELECTORS.TAB_PANEL_WRAPPER);
            this.elems.$stickyContainer.addClass(DEFAULTS.CLASSES.STICKY_TAB_PANEL);
        },

        bindFixed: function() {
            this.resetTabPanel();
            this.initializeStickyPanel();
            this.resolvePanelPosition();

            this.elems.$window.on('scroll.sticky', $.proxy(this.resolvePanelPosition, this));
        },

        initializeStickyPanel: function initializeStickyPanel() {
            var _this = this;

            if (_this.isDesktop) {
                _this.headerHeight = _this.elems.$header.height();
                _this.placeholderHeight = _this.headerHeight;
            } else {
                // The panel sticks to the top of the window
                _this.headerHeight = 0;
                _this.placeholderHeight = _this.elems.$component.height();
                _this.bottomEdge = _this.elems.$stickyContainer.offset().top + _this.elems.$stickyContainer.height();
            }

            _this.stickyPoint = _this.elems.$component.offset().top - _this.headerHeight;
        },

        resetTabPanel: function resetTabPanel() {
            var _this = this;

            _this.elems.$window.scrollTop(0);

            _this.elems.$stickyContainer.removeClass(DEFAULTS.CLASSES.STICKY_TAB_PANEL);
            _this.elems.$stickyContainer = _this.elems.$component.parents(DEFAULTS.SELECTORS.PAGE_CONTENT);
            _this.elems.$stickyContainer.removeClass(DEFAULTS.CLASSES.DOCK_TAB_PANEL);
            _this.elems.$placeholder.height('auto');
        },

        handleResize: function handleResize() {
            var _this = this;

            _this.elems.$window.off('.sticky');
            _this.isDesktop = Response.band(1024);
            _this.isStickyPanel = (Modernizr.csspositionsticky && !_this.isAlphabetnav) || (Modernizr.csspositionsticky && _this.isDesktop);

            if (_this.isStickyPanel) {
                _this.bindSticky();
            } else {
                _this.bindFixed();
            }
        },

        resolvePanelPosition: function resolvePanelPosition() {
            var _this = this;
            var isSticky = _this.stickyPoint < _this.elems.$window.scrollTop();
            var isFitBottomEdge = true;

            if (_this.isAlphabetnav) {
                isFitBottomEdge = _this.bottomEdge > (_this.elems.$alphabetNavWrap.offset().top + _this.elems.$alphabetNavWrap.height());
            }

            if (!_this.isDesktop) {
                isSticky = isSticky && isFitBottomEdge;
            }

            if (isSticky) {
                _this.elems.$stickyContainer.addClass(DEFAULTS.CLASSES.DOCK_TAB_PANEL);
                _this.elems.$placeholder.height(_this.placeholderHeight);
                _this.elems.$component.css({
                    top: _this.headerHeight
                });
                _this.elems.$alphabetNav.addClass(DEFAULTS.CLASSES.ACTIVE_CLASS);
            } else {
                _this.elems.$stickyContainer.removeClass(DEFAULTS.CLASSES.DOCK_TAB_PANEL);
                _this.elems.$placeholder.height('auto');
                _this.elems.$component.css({
                    top: 0
                });
                _this.elems.$alphabetNav.removeClass(DEFAULTS.CLASSES.ACTIVE_CLASS);
            }
        }
    });

    app.HeaderStickyPanel = HeaderStickyPanel;

    return app.HeaderStickyPanel;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.Response, window._, window.Modernizr);
;(function(window, $, Modernizr, _) {

    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            DRAWER_TOGGLE_CLASS: '.drawer-ui__toggle'
        },
        CLASSES: {
            ACTIVE: 'active'
        },
        SETTINGS: {
            closeOnLeaveOutside: true,
            click: true,
            hover: true
        }
    };

    var Drawer = function($element) {
        var _this = this instanceof Drawer ? this : Object.create(Drawer.prototype);

        _this.DEFAULTS = DEFAULTS;
        _this.elems = {
            $component: $element,
            $drawerToggle: $element.find(_this.DEFAULTS.SELECTORS.DRAWER_TOGGLE_CLASS),
            $document: $(window.document)
        };
        _this.settings = {};
        _this.initialize();

        return _this;
    };

    $.extend(Drawer.prototype, {
        initialize: function initialize() {
            $.extend(this.settings, DEFAULTS.SETTINGS, this.elems.$component.data('drawerSettings') || {});
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$document.on('click', function(event) {
                if ($(event.target).closest(_this.elems.$component).length === 0) {
                    _this.closeDrawer(event);
                }
            });

            if (Modernizr.touch || _this.settings.click) {
                _this.elems.$drawerToggle.on('click', $.proxy(this.toggleDrawer, this));

                // TODO: is it necessary?
                // _this.elems.$component.on('click', function(event) {
                //    event.stopPropagation();
                // });
            }

            if (_this.settings.hover) {
                _this.elems.$component.hoverIntent(
                    $.proxy(_this.openDrawer, _this),
                    _this.settings.closeOnLeaveOutside ? $.proxy(_this.closeDrawer, _this) : $.noop
                );
            }

            app.subscribe(app.EVENTS.CLOSE_DRAWER, $.proxy(_this.closeDrawer, _this));
        },

        toggleDrawer: function toggleDrawer(event) {
            if (this.elems.$component.hasClass(this.DEFAULTS.CLASSES.ACTIVE)) {
                this.closeDrawer(event);
            } else {
                this.openDrawer(event);
            }
        },

        openDrawer: function openDrawer() {
            app.trigger(app.EVENTS.CLOSE_DRAWER, this);
            this.elems.$component.addClass(this.DEFAULTS.CLASSES.ACTIVE);
        },

        closeDrawer: function closeDrawer(event) {
            if (
                // Fix for IE and Firefox
                _.isEqual(event, this)) {

                return false;
            }

            this.elems.$component.removeClass(this.DEFAULTS.CLASSES.ACTIVE);
        }
    });

    Drawer.DEFAULTS = DEFAULTS;
    app.Drawer = Drawer;

}).call(window.SPC = window.SPC || {}, window, window.jQuery, window.Modernizr, window._);

;(function(window, $, Modernizr, _) {

    var app = this;
    var DEFAULTS = $.extend({}, app.Drawer.DEFAULTS);

    var SignInDrawer = function($element) {
        var _this = this instanceof SignInDrawer ? this : Object.create(SignInDrawer.prototype);

        _this.DEFAULTS = DEFAULTS;
        _this.elems = {
            $component: $element,
            $drawerToggle: $element.find(_this.DEFAULTS.SELECTORS.DRAWER_TOGGLE_CLASS),
            $document: $(window.document)
        };

        _this.settings = {};
        _this.initialize();

        return _this;
    };

    $.extend(SignInDrawer.prototype, app.Drawer.prototype, {

        closeDrawer: function closeDrawer(event) {
            if (
                // Fix for IE and Firefox
                _.isEqual(event, this)) {

                return false;
            }

            this.elems.$component.removeClass(DEFAULTS.CLASSES.ACTIVE);

            var $signInForm = app.modules.SignIn[0].elems.$component;

            if ($signInForm.spinner('isShowed')) {
                $signInForm.spinner('hide');

                this.elems.$component.spinner('show', {position: 'fixed'});

                app.modules.SignIn[0].$deferred.always(function() {
                    app.modules.MainContentSpinner[0].spinner('hide');
                });
            }
        }
    });

    app.SignInDrawer = SignInDrawer;

}).call(window.SPC = window.SPC || {}, window, window.jQuery, window.Modernizr, window._);
;(function(window, document, $) {
    var app = this;

    /**
     * Default variables
     */
    var DEFAULTS = {
        SELECTORS: {
            SECTION_ATTR: '[data-showmore-section]',
            TRIGGER_ATTR: '[data-showmore-section-trigger]'
        }
    };

    /*
     * Constructor
     */
    var MobileDrawer = function MobileDrawer($element) {
        var _this = this instanceof MobileDrawer ? this : Object.create(MobileDrawer.prototype);

        _this.elems = {
            $component: $element
        };

        _this.initialize();

        return _this;
    };

    $.extend(MobileDrawer.prototype, {
        initialize: function initialize() {
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$component.on('click', DEFAULTS.SELECTORS.TRIGGER_ATTR, function() {
                _this.toggleSection($(this).closest(DEFAULTS.SELECTORS.SECTION_ATTR));
            });
        },

        toggleSection: function toggleSection(section) {
            section.toggleClass('active');
        }
    });

    app.MobileDrawer = MobileDrawer;

    return app.MobileDrawer;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $) {
    var app = this;

    /*
     * Constructor
     */
    var PerfectScroll = function PerfectScroll($element) {
        var _this = this instanceof PerfectScroll ? this : Object.create(PerfectScroll.prototype);

        _this.elems = {
            $component: $element
        };

        _this.initialize();

        return _this;
    };

    $.extend(PerfectScroll.prototype, {
        initialize: function initialize() {
            this.elems.$component.perfectScrollbar();

            return this;
        },

        destroy: function destroy() {
            this.elems.$component.perfectScrollbar('destroy');
        },

        update: function() {
            this.elems.$component.perfectScrollbar('update');
        }
    });

    app.PerfectScroll = PerfectScroll;

    return app.PerfectScroll;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
(function($, undefined) {

    var DEFAULTS = {
        SELECTORS: {
            SPINNER_TEMPLATE: '#spinner-template',
            SPINNER_OVERLAY: '.spinner__overlay',
            BODY: 'body'
        }
    };

    $.fn.spinner = function(action, params) {

        var _this = this;

        var spinnerTemplate = $(DEFAULTS.SELECTORS.SPINNER_TEMPLATE).html();

        var getNextHighestDepth = function getNextHighestDepth() {
            var max = 0;

            $(DEFAULTS.SELECTORS.BODY).children().each(function() {
                if (max < $(this).zIndex()) {
                    max = $(this).zIndex();
                }
            });

            return max + 1;
        };

        var update = function update(element, params) {
            element.$spinner.css({
                left: $(element).offset().left,
                top: $(element).offset().top ,
                width: $(element).outerWidth() ,
                height: $(element).outerHeight()
            });

            if (params && params.position === 'fixed') {

                element.$spinner.find(DEFAULTS.SELECTORS.SPINNER_OVERLAY).css({
                    left: $(element).outerWidth() / 2,
                    top: Math.min($(window).height(), $(element).outerHeight()) / 2,
                    position: 'fixed'
                });
            }

            var zIndex = getNextHighestDepth();

            element.$spinner.zIndex(zIndex);

            $(window).on('resize', function() {
                _this.each(function() {
                    if (typeof this.$spinner !== 'undefined') {
                        update(this);
                    }
                });
            });

            return element.$spinner;
        };

        _this.show = function show(params) {

            if (!_this.outerWidth() || !_this.outerHeight()) {
                return _this;
            }

            _this.each(function() {
                if (typeof this.$spinner === 'undefined') {

                    this.$spinner = $(spinnerTemplate);

                    if (params.insertInside) {
                        $(this).append(this.$spinner);

                    } else {
                        $(DEFAULTS.SELECTORS.BODY).append(this.$spinner);
                        update(this, params);
                    }
                }

                this.$spinner.show();
            });

            return _this;
        };

        _this.hide = function hide() {

            _this.each(function() {
                if (typeof this.$spinner !== 'undefined') {
                    this.$spinner.remove();
                    this.$spinner = undefined;
                }
            });

            return _this;
        };

        if (_this[action]) {
            _this[action](params || {});
        }
    };

})(window.jQuery);

;(function(window, document, $, google) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            PRINT_DATE_CONTAINER: '#page-print-date',
            SHARE_PRINT_LINK: '.share-print__action-link'
        },
        CLASSES: {
            IE10: 'ie10'
        },
        PRINT_MAP_HEIGHT: 380,
        PRINT_PAGE_WIDTH: 650
    };

    /*
     * Constructor
     */
    var Print = function($element) {
        var _this = this instanceof Print ? this : Object.create(Print.prototype);

        _this.elems = {
            $component: $element,
            $printDateContainer: $(DEFAULTS.SELECTORS.PRINT_DATE_CONTAINER),
            $sharePrint: $(DEFAULTS.SELECTORS.SHARE_PRINT_LINK)
        };

        _this.initialize();
        _this.bindEvents();

        return _this;
    };

    $.extend(Print.prototype, {
        initialize: function initialize() {
            var _this = this;

            _this._checkIE10();
            _this.printPage = $.proxy(_this.printPage, _this);
            _this.disableButton();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', this.printPage);

            if (window.matchMedia) {
                window.matchMedia('print').addListener($.proxy(this._getFormattedDate, this));
            }

            $(window).on('beforeprint', $.proxy(this._getFormattedDate, this));

            $(document).on('keydown', $.proxy(this._onRequestPrint, this));
        },

        enableButton: function enableButton() {
            this.elems.$sharePrint.prop('disabled', false);
        },

        disableButton: function disableButton() {
            this.elems.$sharePrint.prop('disabled', true);
        },

        _checkIE10: function() {
            if (navigator.appVersion.indexOf('MSIE 10') !== -1) {
                $(document.documentElement).addClass(DEFAULTS.CLASSES.IE10);
            }
        },

        _onRequestPrint: function(e) {
            if ((e.metaKey || e.ctrlKey) && e.keyCode === 80) {
                this.printPage(e);
            }
        },

        printPage: function printPage(e) {
            e.preventDefault();

            if (app.modules.Map) {
                var mapModule = app.modules.Map[0];

                if (mapModule.printStarted) {
                    return false;
                } else {
                    mapModule.printStarted = true;
                }

                var width = mapModule.elems.$component.width(); // Preserve width added by glb-pin-block
                var center = mapModule.mapService.map.getCenter();
                var idleListener;

                var onIdle = function() {
                    window.print();
                    google.maps.event.removeListener(idleListener);
                    mapModule.printStarted = false;
                    google.maps.event.trigger(mapModule.mapService.map, 'resize');
                    mapModule.mapService.map.setCenter(center);
                };

                idleListener = google.maps.event.addListener(mapModule.mapService.map, 'idle', onIdle);

                mapModule.elems.$component.height(DEFAULTS.PRINT_MAP_HEIGHT);
                mapModule.elems.$component.width(DEFAULTS.PRINT_PAGE_WIDTH);

                google.maps.event.trigger(mapModule.mapService.map, 'resize');

                mapModule.mapService.map.setCenter(center);
                mapModule.elems.$component.width(width);
                mapModule.elems.$component.height('');
            } else {
                window.print();
            }
        },

        _getFormattedDate: function _getFormattedDate() {
            function addLeadingZero(n) {
                return n < 10 ? '0' + n : n.toString();
            }

            var now = new Date();
            var printDate = addLeadingZero(now.getMonth() + 1) + '.' + addLeadingZero(now.getDate()) + '.' + now.getFullYear();
            var printTime = addLeadingZero(now.getHours()) + ':' + addLeadingZero(now.getMinutes());

            this.elems.$printDateContainer.text(printDate + ' / ' + printTime);
        }
    });

    app.Print = Print;

    return app.Print;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.google);

;(function(window, document, $, CQ) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            FORM: '.footer-section__signup',
            CLOSE_BUTTON: '.footer-section__newsletter-close',
            EMAIL_INPUT: '[name="email"]'
        },
        CLASSES: {
            BASIC: 'footer-section__newsletter',
            SIGNUP: 'footer-section__newsletter_signup',
            THANKS: 'footer-section__newsletter_thanks',
            SUBSCRIBED: 'footer-section__newsletter_subscribed',
            VALIDATION_ERROR: 'validation-error',
            VALIDATION_ERROR_SHOW: 'validation-error_show',
            JOIN_OUR_COMMUNITY_HIDE: 'join-our-community_hide'
        },
        SERVICES_URLS: {
            STATUS: '/services/sportchek/customer/subscription/status'
        }
    };

    var JoinOurCommunity = function JoinOurCommunity($element) {
        var _this = this instanceof JoinOurCommunity ? this : Object.create(JoinOurCommunity.prototype);

        _this.elems = {
            $component: $element,
            $form: $element.find(DEFAULTS.SELECTORS.FORM),
            $closeButton: $element.find(DEFAULTS.SELECTORS.CLOSE_BUTTON)
        };

        _this.emailPreferencesURL = _this.elems.$component.data('email-preferences-url');

        _this.bindEvents();

        return _this;
    };

    $.extend(JoinOurCommunity.prototype, {
        bindEvents: function bindEvents() {
            var _this = this;

            _this._bindValidate();

            _this.elems.$closeButton.on('click', function(e) {
                e.preventDefault();

                _this.elems.$component.addClass(DEFAULTS.CLASSES.JOIN_OUR_COMMUNITY_HIDE);
            });
        },

        _bindValidate: function _bindValidate() {
            var _this = this;

            _this.elems.$form.validate({
                errorClass: DEFAULTS.CLASSES.VALIDATION_ERROR,
                errorElement: 'span',
                rules: {
                    email: {
                        required: true,
                        spcEmail: true
                    }
                },
                messages: {
                    email: {
                        required: CQ.I18n.get('error.customers.validation.registerData.login.NotBlank'),
                        spcEmail: CQ.I18n.get('error.customers.validation.registerData.login.Pattern')
                    }
                },
                errorPlacement: function(error, input) {
                    var $error = $(error).addClass(DEFAULTS.CLASSES.VALIDATION_ERROR_SHOW);

                    $(input).after($error);
                },
                submitHandler: function(form) {
                    var data = $(form).toObject();

                    data.email = $.trim(data.email);
                    _this.checkSubscriptionStatus(data);
                }
            });
        },

        toggleBlocks: function toggleBlocks(block) {
            this.elems.$component.removeAttr('class');
            this.elems.$component.addClass(DEFAULTS.CLASSES.BASIC);
            this.elems.$component.addClass(DEFAULTS.CLASSES[block]);
        },

        checkSubscriptionStatus: function checkSubscriptionStatus(sendData) {
            var _this = this;

            $.ajax({
                url: DEFAULTS.SERVICES_URLS.STATUS,
                type: 'POST',
                dataType: 'JSON',
                contentType: 'application/json',
                data: JSON.stringify(sendData),
                beforeSend: function() {
                    app.modules.MainContentSpinner[0].spinner('show');
                },
                success: function(data) {
                    switch (data) {
                        case 'SUBSCRIPTION_ACTIVE_GREATER_OR_EQUAL_THAN_YEAR':

                        case 'NEW_SUBSCRIPTION':
                            app.modules.JoinOurCommunityAntiSpam[0].openModal(sendData.email);
                            app.trigger(app.EVENTS.ANALYTICS.SHOW_SIGNUP_MODAL);

                            break;

                        case 'SUBSCRIPTION_ACTIVE_LESS_THAN_YEAR':
                            _this.toggleBlocks('SUBSCRIBED');

                            app.modules.Confirm.openModal({
                                title: CQ.I18n.get('GLB0120'),
                                description: CQ.I18n.get('GLB0086'),
                                confirmText: CQ.I18n.get('HOM0009'),
                                cancelText: CQ.I18n.get('GLB0166'),
                                cancelTextLink: _this.emailPreferencesURL + '#email=' + sendData.email
                            });

                            break;

                        case 'SUBSCRIPTION_INACTIVE_LESS_THAN_YEAR':

                        case 'SUBSCRIPTION_INACTIVE_GREATER_OR_EQUAL_THAN_YEAR':
                            app.modules.ResubscribeJoinOurCommunityAntiSpam[0].openModal(sendData.email);

                            break;
                    }
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 400:

                        case 424:
                            app.modules.Alert.openModal({
                                title: CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message)
                            });

                            break;

                        default:
                            console.error('"JoinOurCommunity._postData" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                },
                complete: function() {
                    app.modules.MainContentSpinner[0].spinner('hide');
                }
            });
        }
    });

    app.JoinOurCommunity = JoinOurCommunity;

    return app.JoinOurCommunity;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);
;(function(window, document, $, _) {
    var app = this;

    var DEFAULTS = {
        MAX_ITEMS: 4
    };

    var CompareList = function CompareList() {
        var _this = this instanceof CompareList ? this : Object.create(CompareList.prototype);

        return _this;
    };

    $.extend(CompareList.prototype, {

        initialize: function initialize() {
            this.products = [];
            this.restoreCompareList();
        },

        contains: function contains(product) {
            for (var i = 0; i < this.products.length; i++) {
                if (this.products[i].productCode === product.productCode) {
                    return true;
                }
            }

            return false;
        },

        composeUrlParams: function composeUrlParams() {
            var urlParams = [];

            for (var i = 0; i < this.products.length; i++) {
                var prd = {};

                if (this.products[i].colorValue) {
                    prd[this.products[i].productCode] = {
                        color: this.products[i].colorValue
                    };
                } else {
                    prd[this.products[i].productCode] = null;
                }

                urlParams.push($.param(prd, false));
            }

            return urlParams.join('&');
        },

        updateCompareList: function updateCompareList(prd) {
            for (var i = 0; i < this.products.length; i++) {
                if (this.products[i].productCode === prd.productCode) {
                    this.products[i] = prd;

                    return this.saveCompareList();
                }
            }

            return this;
        },

        getCompareList: function getCompareList() {
            return _.pluck(this.products, 'productCode');
        },

        addToCompareList: function addToCompareList(prd) {
            if (this.products.length < DEFAULTS.MAX_ITEMS) {
                this.products.push(prd);
            }

            return this;
        },

        removeFromCompareList: function removeFromCompareList(prd) {
            for (var i = 0; i < this.products.length; i++) {
                if (this.products[i].productCode === prd.productCode) {
                    this.products.splice(i, 1);

                    return this.saveCompareList();
                }
            }

            return this;
        },

        restoreCompareList: function restoreCompareList() {
            var compareList = $.cookie(app.COOKIES.COMPARE_LIST) || '[]';
            this.products = JSON.parse(compareList);

            return this;
        },

        saveCompareList: function saveCompareList() {
            $.cookie(app.COOKIES.COMPARE_LIST, JSON.stringify(this.products), {
                path: '/'
            });

            return this;
        }
    });

    CompareList.DEFAULTS = DEFAULTS;

    app.CompareList = CompareList;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._);
;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            COMPARE_BAR_ITEM: '.product-compare__item',
            COMPARE_BAR_BUTTON: '.product-compare__button',
            COMPARE_BAR_REMOVE_BUTTON: '.remove',
            COMPARE_BAR_IMAGE: '.product-compare-image',
            HIDDEN_CLASS: 'product-compare_hidden',
            HTML: 'html',
            BODY: 'body'
        },
        CLASSES: {
            EMPTY: 'product-compare__item-empty',
            CHECKED: 'product-grid__list-item_state_compare',
            DISABLED: 'button_state_disabled',
            LESS_THEN_IE9: 'lt-ie9'
        },
        SERVICE_URL: ''
    };

    var CompareBar = function CompareBar($element) {
        var _this = this instanceof CompareBar ? this : Object.create(CompareBar.prototype);

        $.extend(DEFAULTS, app.CompareList.DEFAULTS);

        _this.elems = {
            $component: $element,
            $removeBtn: $element.find(DEFAULTS.SELECTORS.COMPARE_BAR_REMOVE_BUTTON),
            $productCompareButton: $element.find(DEFAULTS.SELECTORS.COMPARE_BAR_BUTTON)
        };

        _this.items = $element.find(DEFAULTS.SELECTORS.COMPARE_BAR_ITEM).toArray().reverse();

        DEFAULTS.SERVICE_URL = $element.data('compare-page-url');

        _this.initialize();
        _this.bindEvents();

        _this.render();

        return _this;
    };

    $.extend(CompareBar.prototype, app.CompareList.prototype, {

        bindEvents: function bindEvents() {
            app.subscribe(app.EVENTS.PRODUCT_GRID_LOADED, $.proxy(this._toggleVisibility, this));

            this.elems.$removeBtn.on('click', $.proxy(this.removeItemFromCompareBar, this));
            this.elems.$productCompareButton.on('click', $.proxy(this.gotoComparePage, this));
        },

        gotoComparePage: function moveComparePage(e) {
            e.preventDefault();

            if ($(e.target).hasClass(DEFAULTS.CLASSES.DISABLED)) {
                return;
            }

            var url = DEFAULTS.SERVICE_URL;

            if (this.products.length) {
                url += '#' + this.composeUrlParams();
            }

            this.changeLocation(url);
        },

        // TODO: move it to app/util
        changeLocation: function changeLocation(url) {
            var $html = $(DEFAULTS.SELECTORS.HTML);
            var $body = $(DEFAULTS.SELECTORS.BODY);

            if ($html.hasClass(DEFAULTS.CLASSES.LESS_THEN_IE9)) {
                var referLink = $('a');

                referLink
                    .attr('href', url)
                    .appendTo($body)
                    .get(0).click();
            } else {
                window.location.href = url;
            }
        },

        removeItemFromCompareBar: function removeItemFromCompareBar(e) {
            e.preventDefault();

            var item = $(e.target).closest(DEFAULTS.SELECTORS.COMPARE_BAR_ITEM)[0];

            for (var i = 0; i < this.items.length; i++) {

                if (item === this.items[i]) {
                    // TODO: Add context
                    $('[data-product-code="' + this.products[i].productCode + '"]').removeClass(DEFAULTS.CLASSES.CHECKED);

                    return this.removeFromCompareList(this.products[i]).render();
                }
            }
        },

        toggleCompare: function toggleCompare(data) {
            if (!this.contains(data.product)) {

                if (this.products.length < DEFAULTS.MAX_ITEMS) {
                    $('[data-product-code="' + data.product.productCode + '"]').addClass(DEFAULTS.CLASSES.CHECKED);

                    this.addToCompareList(data.product);
                    this.saveCompareList();
                    this.render();
                } else {
                    app.modules.CompareModal[0].initialize(data.$compareButton);
                }

            } else {
                // TODO: Add context
                $('[data-product-code="' + data.product.productCode + '"]').removeClass(DEFAULTS.CLASSES.CHECKED);

                this.removeFromCompareList(data.product);
                this.render();
            }
        },

        render: function render() {
            var _this = this;

            _this.elems.$productCompareButton.toggleClass(DEFAULTS.CLASSES.DISABLED, (_this.products.length < 2));

            for (var i = 0; i < _this.items.length; i++) {

                if (_this.products[i]) {
                    $(_this.items[i]).find(DEFAULTS.SELECTORS.COMPARE_BAR_IMAGE).attr('src', _this.products[i].img);
                    $(_this.items[i]).removeClass(DEFAULTS.CLASSES.EMPTY);
                } else {
                    $(_this.items[i]).addClass(DEFAULTS.CLASSES.EMPTY);
                }
            }

            return _this;
        },

        _toggleVisibility: function _toggleVisibility(data) {
            if (data.resultCount.total === 0) {
                this.elems.$component.addClass(DEFAULTS.SELECTORS.HIDDEN_CLASS);
            } else {
                this.elems.$component.removeClass(DEFAULTS.SELECTORS.HIDDEN_CLASS);
            }
        }
    });

    app.CompareBar = CompareBar;

    return app.CompareBar;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            MODAL: 'show-compare-modal',
            COMPARE_TRIGGER: 'trigger-error-modal',
            SHIFT_MODAL_LEFT: 'shift-modal-left',
            SHIFT_MODAL_RIGHT: 'shift-modal-right',
            CLOSE_CLASS: '.compareModal__close',
            COMPARE_CLASS: '.compareModal__compare'
        }
    };

    var CompareModal = function CompareModal($element) {
        var _this = this instanceof CompareModal ? this : Object.create(CompareModal.prototype);

        _this.elems = {
            $component: $element,
            $close: $element.find(DEFAULTS.SELECTORS.CLOSE_CLASS),
            $compareLink: $element.find(DEFAULTS.SELECTORS.COMPARE_CLASS),
            $window: $(window)
        };

        _this.bindEvents();

        return _this;
    };

    $.extend(CompareModal.prototype, {
        initialize: function initialize($compareButton) {
            if (this.elems.$compareButton === $compareButton && this.elems.$compareButton.hasClass(DEFAULTS.SELECTORS.COMPARE_TRIGGER)) {
                this.closeCompareModal();
            } else {
                this.closeCompareModal();
                this.elems.$compareButton = $compareButton;
                this.openCompareModal();
            }

            this.positionCompareModal();
            this.checkModalBoudaries();
        },

        bindEvents: function bindEvents() {
            this.elems.$close.on('click', $.proxy(this.closeCompareModal, this));
            this.elems.$compareLink.on('click', function(e) {
                app.modules.CompareBar[0].gotoComparePage(e);
            });
            this.elems.$window.on('scroll resize', $.proxy(this.closeCompareModal, this));
        },

        closeCompareModal: function closeCompareModal(e) {
            if (!this.elems.$compareButton) {
                return;
            }

            if (e) {
                e.preventDefault();
            }

            this.elems.$component.removeClass(DEFAULTS.SELECTORS.MODAL);
            this.elems.$compareButton.removeClass(DEFAULTS.SELECTORS.COMPARE_TRIGGER);
        },

        openCompareModal: function openCompareModal() {
            this.elems.$compareButton.addClass(DEFAULTS.SELECTORS.COMPARE_TRIGGER);
            this.elems.$component.addClass(DEFAULTS.SELECTORS.MODAL);
        },

        positionCompareModal: function positionCompareModal() {
            var offset = this.elems.$compareButton.offset();

            this.elems.$component.css({
                left: offset.left,
                top: offset.top
            });
            this.elems.$component.removeClass(DEFAULTS.SELECTORS.SHIFT_MODAL_RIGHT + ' ' + DEFAULTS.SELECTORS.SHIFT_MODAL_LEFT);
        },

        checkModalBoudaries: function checkModalBoudaries() {
            var modalOffset = this.elems.$component.offset().left;
            var modalWidth = this.elems.$component.outerWidth();
            var modalOffsetTotal = modalOffset + modalWidth;

            if (modalOffset < 0) {
                this.elems.$component.addClass(DEFAULTS.SELECTORS.SHIFT_MODAL_RIGHT);
            }

            if (modalOffsetTotal > this.elems.$window.width()) {
                this.elems.$component.addClass(DEFAULTS.SELECTORS.SHIFT_MODAL_LEFT);
            }
        }
    });

    app.CompareModal = CompareModal;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $, _, dust, Modernizr) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            ITEM_CLASS: '.product-grid__list-item',
            ELLIPSIS_CLASS: '.ellipsis',
            SPINNER_WRAPPER_ID: '#product-grid__spinner-wrapper',
            LAZY_SPINNER: '[data-module-type="LazySpinner"]',
            HTML_BODY: 'html, body',
            HEADER: 'header'
        },
        URLS: {
            SERVICE: '/services/sportchek/search-and-promote/products'
        },
        PAGE_SIZE: 16,
        ADDITIONAL_OFFSET: 4000
    };

    var ProductGrid = function ProductGrid() {
        return this instanceof ProductGrid ? this : Object.create(ProductGrid.prototype);
    };

    $.extend(ProductGrid.prototype, {
        globalInitialize: function globalInitialize() {
            this.elems = this.elems || {};

            this.allowHistory = true;

            // TODO: use createSubmodule
            app.createModule($(DEFAULTS.SELECTORS.LAZY_SPINNER));

            this.elems.$htmlBody = $(DEFAULTS.SELECTORS.HTML_BODY);
            this.elems.$spinnerWrapper = $(DEFAULTS.SELECTORS.SPINNER_WRAPPER_ID);
            this.elems.$window = $(window);

            this.elems.$header = $(DEFAULTS.SELECTORS.HEADER);

            this.searchParams = {
                q: '',
                page: 1,
                count: DEFAULTS.PAGE_SIZE
            };

            this.gridStatus = {
                loadingInProgress: false,
                gridItemsLoaded: false,
                pageSize: DEFAULTS.PAGE_SIZE
            };

            if (!app.modules.ProductGridItem) {
                app.modules.ProductGridItem = [];
            }

            this.lastId = 0;

            this.bindGlobalEvents();
        },

        bindGlobalEvents: function bindGlobalEvents() {
            this.elems.$window.on('hashchange', $.proxy(this.clearVisitedHistory, this));
            this.elems.$window.on('scroll', $.proxy(this._onScroll, this));
        },

        _onScroll: function _onScroll() {
            if (!(this.gridStatus.gridItemsLoaded || this.gridStatus.loadingInProgress)) {
                var spinnerTopPosition = this.elems.$spinnerWrapper.position().top;
                var viewPortBottomPoint = this.elems.$window.scrollTop() + this.elems.$window.height();

                if (viewPortBottomPoint + DEFAULTS.ADDITIONAL_OFFSET >= spinnerTopPosition) {
                    this.getNextPage();
                }
            }

            if (Modernizr.history && this.allowHistory) {
                this._saveTopProduct();
            }
        },

        _isVisibleItem: function _isVisibleItem(elem) {
            // FIXME: magic 18px
            var topVisiblePoint = (window.scrollY || window.pageYOffset) - this.elems.$component.position().top + this.elems.$header.height() + 18;
            var $elem = $(elem);
            var elementTop = $elem.position().top;

            return elementTop >= topVisiblePoint;
        },

        _findFirstVisible: function _findFirstVisible() {
            var $gridItems = this.elems.$component.find(DEFAULTS.SELECTORS.ITEM_CLASS);

            for (var i = 0; i < $gridItems.length; i++) {
                var $gridItem = $gridItems.eq(i);

                if (this._isVisibleItem($gridItem)) {

                    return $gridItem;
                }
            }

            return null;
        },

        _saveTopProduct: function _saveTopProduct() {
            var hashParams = $.bbq.getState();
            var lastVisibleItem = this._findFirstVisible();
            var lastVisibleProductNumber;

            if (lastVisibleItem) {
                lastVisibleProductNumber = lastVisibleItem.data('id');
            }

            if (lastVisibleProductNumber) {
                hashParams.lastVisibleProductNumber = lastVisibleProductNumber;

                window.history.replaceState(hashParams, '', '#' + $.param(hashParams));
            }
        },

        clearVisitedHistory: function clearVisitedHistory() {
            var hashParams = $.bbq.getState();

            if (hashParams.lastVisibleProductNumber) {
                delete hashParams.lastVisibleProductNumber;

                window.history.replaceState(hashParams, '', '#' + $.param(hashParams));
            }
        },

        render: function render(data, isNewPage) {
            var _this = this;

            data = _this.extendDataProperties(data);

            dust.render('productGridItem', data, function(error, productList) {
                var $productList = $(productList);

                if (data && data.products.length) {
                    $productList.each(function() {
                        var $productListItem = $(this);

                        if ($productListItem.data('module-type')) {
                            app.createModule($productListItem);
                        }

                        app.createSubModule($productListItem, _this);
                    });
                }

                _this.elems.$component.append($productList);

                if (_.isObject(isNewPage)) {
                    var settings = isNewPage;

                    var scrollTo = _this.elems.$component.find('[data-id="' + settings.lastVisibleProductNumber + '"]').position().top;

                    $.extend(_this.searchParams, settings);
                    _this.elems.$htmlBody.animate({scrollTop: scrollTo - 10});
                }

                $productList.find(DEFAULTS.SELECTORS.ELLIPSIS_CLASS).dotdotdot({
                    watch: 'window'
                });
            });
        },

        getFirstPage: function getFirstPage() {
            var _this = this;
            var lastVisibleProductNumber = $.bbq.getState().lastVisibleProductNumber;
            var settings = true;

            if (_this.getDataRequest) {
                _this.getDataRequest.abort();
            }

            app.modules.ProductGridItem = [];
            _this._setFirstPageSettings();
            _this._clearSearchResults();

            if (_this.allowHistory && lastVisibleProductNumber) {
                var loadedPageCount = Math.ceil(lastVisibleProductNumber / DEFAULTS.PAGE_SIZE);

                _this.searchParams.count = DEFAULTS.PAGE_SIZE * loadedPageCount;

                settings = {
                    count: DEFAULTS.PAGE_SIZE,
                    page: loadedPageCount,
                    lastVisibleProductNumber: lastVisibleProductNumber
                };
            }

            _this.getData(settings);
        },

        _setFirstPageSettings: function _setFirstPageSettings() {
            this.lastId = 0;
            this.searchParams.page = 1;
            this.searchParams.count = this.gridStatus.pageSize;
            this.gridStatus.gridItemsLoaded = false;
        },

        _clearSearchResults: function _clearSearchResults() {
            this.elems.$component.empty();
        },

        getNextPage: function getNextPage() {
            this.gridStatus.gridItemsLoaded = this.lastId === this.resultsQuantity;

            if (!this.gridStatus.gridItemsLoaded) {
                this.searchParams.page += 1;
                this.searchParams.count = this.gridStatus.pageSize;
                this.getData(false);
            }
        },

        extendDataProperties: function extendDataProperties(data) {
            var _this = this;

            data = data || {};

            if (data.products && data.products.length) {

                // Extends products with CompareList data
                var compareList = app.modules.CompareBar[0].getCompareList();

                _.each(data.products, function(product) {
                    product.inCompareList = _.contains(compareList, product.code);
                    product.id = _this.lastId;

                    _this.lastId += 1;
                });
            }

            data.q = _this.searchParams.q;
            data.gridType = _this.gridType;

            return data;
        },

        getData: function getData(settings) {
            var _this = this;

            var resultsQuantity = Boolean(_this.resultsQuantity);
            var $spinnerElement = null;

            if (settings && resultsQuantity) {
                $spinnerElement = app.modules.MainContentSpinner[0];
            } else {
                $spinnerElement = app.modules.LazySpinner[0];
            }

            _this.getDataRequest = $.ajax({
                url: DEFAULTS.URLS.SERVICE,
                beforeSend: function() {
                    _this.gridStatus.loadingInProgress = true;

                    $spinnerElement.spinner('show', {
                        insertInside: true
                    });
                },
                data: _this.searchParams,
                type: 'GET',
                success: function(data, status, jqXhr) {
                    if (data.redirect) {
                        jqXhr.notHideSpinner = true;
                        window.location.assign(data.redirect);

                        return;
                    }

                    // NOTE: exception case. real products length can be less then result count
                    if (data.products.length === 0 && _this.lastId < data.resultCount.total) {
                        _this.gridStatus.gridItemsLoaded = true;

                        return;
                    }

                    app.trigger(app.EVENTS.PRODUCT_GRID_LOADED, data);
                    app.trigger(app.EVENTS.ANALYTICS.PRODUCT_GRID_LOADED, data);

                    _this.resultsQuantity = data.resultCount.total;

                    if (settings) {
                        _this.elems.$htmlBody.animate({scrollTop: 0});
                    }

                    _this.render(data, settings);
                },
                error: function(jqXhr, ajaxOptions, thrownError) {
                    _this.render(null);

                    console.error('"ProductGrid.getData" >> error: request failed!', jqXhr, ajaxOptions, thrownError);
                },
                complete: function(jqXhr) {
                    if (!jqXhr.notHideSpinner) {
                        $spinnerElement.spinner('hide');
                    }

                    _this.gridStatus.loadingInProgress = false;
                }
            });
        }
    });

    ProductGrid.DEFAULTS = DEFAULTS;

    app.ProductGrid = ProductGrid;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.dust, window.Modernizr);

;(function(window, document, $, Modernizr, _, Response) {

    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            TOGGLE_QUICKVIEW: '.product-quickview-btn, .product-promo-text__more',
            EXPAND_COLORS_BUTTON: '.product-colors-item_plus',
            GRID_ITEM_COLORS: '.product-colors',
            HOVERED_LIST_ITEM: '.product-grid__list-item.hover',

            PRODUCT_COLORS_ITEM: '.product-colors-item',
            PRODUCT_COLORS_ITEM_SELECTED: '.product-colors-item_selected',
            PRODUCT_GRID_IMAGE_TEMPLATE: '.product-image-wrap',
            PRODUCT_GRID_LINK: '.product-grid__link_image',
            PRODUCT_GRID_IMAGE: '.product-grid-image',

            PRODUCT_COMPARE_CHECKBOX: '.product-compare-checkbox',
            PRODUCT_IMG: '.product-grid-image',

            QUICK_VIEW: '.quickview__content-wrap'
        },

        CLASSES: {
            PRODUCT_COLORS_ITEM: 'product-colors-item',
            PRODUCT_COLORS_ITEM_SELECTED: 'selected',
            HOVER: 'hover',
            ACTIVE: 'active',
            NO_ANIMATION: 'no-animation'
        },
        TABLET_LANDSCAPE_DIMENSIONS: 769,
        DELAY: 500,
        THROTTLE: 200
    };

    var ProductGridItem = function ProductGridItem($element) {
        var _this = this instanceof ProductGridItem ? this : Object.create(ProductGridItem.prototype);

        _this.elems = {
            $component: $element,
            $quickViewButton: $element.find(DEFAULTS.SELECTORS.TOGGLE_QUICKVIEW),
            $quickView: $element.find(DEFAULTS.SELECTORS.QUICK_VIEW),
            $expandButton: $element.find(DEFAULTS.SELECTORS.EXPAND_COLORS_BUTTON),
            $compareButton: $element.find(DEFAULTS.SELECTORS.PRODUCT_COMPARE_CHECKBOX),
            $colorWrapper: $element.find(DEFAULTS.SELECTORS.GRID_ITEM_COLORS),
            $colorButton: $element.find(DEFAULTS.SELECTORS.PRODUCT_COLORS_ITEM),
            $productImage: $element.find(DEFAULTS.SELECTORS.PRODUCT_IMG),
            $productLink: $element.find(DEFAULTS.SELECTORS.PRODUCT_GRID_LINK),
            $image: $element.find(DEFAULTS.SELECTORS.PRODUCT_GRID_IMAGE),
            $imageWrapper: $element.find(DEFAULTS.SELECTORS.PRODUCT_GRID_IMAGE_TEMPLATE)
        };

        _this.grid = (app.modules.SearchProductGrid) ? app.modules.SearchProductGrid[0] : app.modules.SubcategoryProductGrid[0];

        // Here used .attr method because .data removes leading zeros
        _this.productCode = _this.elems.$component.attr('data-product-code');
        _this.productPageUrl = _this.elems.$component.data('product-page-url');
        _this.id = _this.elems.$component.data('id');
        _this.skuQuery = null;
        _this.timeoutId = null;
        _this.subModules = {};

        _this.bindEvents();

        return _this;
    };

    $.extend(ProductGridItem.prototype, {
        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$compareButton.on('click', $.proxy(this.toggleCompareButton, this));

            if (!Modernizr.touch) {
                _this.elems.$expandButton.on('click', $.proxy(this.expandColorBar, this));
                _this.elems.$quickViewButton.on('click', $.proxy(this.openQuickView, this));
                _this.elems.$colorButton.on('click', $.proxy(this.changeColor, this));
                _this.elems.$imageWrapper.on('mouseenter mouseleave', $.proxy(this.toggleQuickViewButton, this));
            } else {
                $(window).on('resize',  _.throttle($.proxy(this.bindOnResize, this), DEFAULTS.THROTTLE));

                this.bindOnResize();
            }

            app.subscribe(app.EVENTS.CHANGE_PRODUCT_COLOR, function(data) {
                if (data.productCode === _this.productCode) {
                    var $colorButton = _this.elems.$colorButton.filter('[data-color-value="' + data.colorCode + '"]');

                    $colorButton.trigger('click');
                }
            });
        },

        bindOnResize: function bindOnResize() {
            this.elems.$productLink.off('click.quickView');
            this.elems.$quickViewButton.off('click.quickView');

            if (Response.band(DEFAULTS.TABLET_LANDSCAPE_DIMENSIONS)) {
                this.elems.$productLink.on('click.quickView', $.proxy(this.toggleQuickView, this));
                this.elems.$quickViewButton.on('click.quickView', $.proxy(this.toggleQuickView, this));
            }
        },

        openQuickView: function openQuickView(e) {
            var moveToAnotherQuickView = true;

            if (e) {
                moveToAnotherQuickView = false;
                e.stopPropagation();
                e.preventDefault();
            }

            if (!this.subModules.QuickView) {
                this.subModules.QuickView = new app.QuickView(this.elems.$quickView, this);
            }

            this.subModules.QuickView.initialize(moveToAnotherQuickView);
        },

        toggleQuickView: function toggleQuickView(e) {
            e.preventDefault();

            if (this.subModules.QuickView && this.subModules.QuickView.$detachedComponent === null) {
                this.subModules.QuickView.close();
            } else {
                this.openQuickView(e);
            }
        },

        toggleQuickViewButton: function toggleQuickViewButton(e) {
            var _this = this;

            if (e.type === 'mouseenter') {
                window.clearTimeout(_this.timeoutId);

                _this.timeoutId = window.setTimeout(function() {
                    _this.elems.$component.addClass(DEFAULTS.CLASSES.HOVER);
                }, DEFAULTS.DELAY);

            } else {
                _this.elems.$component.removeClass(DEFAULTS.CLASSES.HOVER);

                if (!_this.elems.$component.hasClass(DEFAULTS.CLASSES.ACTIVE)) {
                    _this.elems.$colorWrapper.removeClass(DEFAULTS.CLASSES.ACTIVE);
                }

                window.clearTimeout(_this.timeoutId);
            }
        },

        toggleCompareButton: function toggleCompareButton(e) {
            e.preventDefault();

            app.modules.CompareBar[0].toggleCompare({
                product: {
                    colorValue: this.skuQuery && this.skuQuery.color || null,
                    productCode: this.productCode,
                    img: this.elems.$productImage.attr('src')
                },
                $compareButton: this.elems.$compareButton
            });
        },

        expandColorBar: function expandColorBar() {
            this.elems.$colorWrapper.addClass(DEFAULTS.CLASSES.ACTIVE);
        },

        changeColor: function changeColor(e) {
            var $selectedColorButton = $(e.target);

            if ($selectedColorButton.hasClass(DEFAULTS.CLASSES.PRODUCT_COLORS_ITEM_SELECTED)) {
                return;
            }

            var _this = this;

            var imageUrl = $selectedColorButton.data('image-url');
            var $link = _this.elems.$component.find(DEFAULTS.SELECTORS.PRODUCT_GRID_LINK);
            var rawHref = $link.data('raw-href');
            var colorValue = $selectedColorButton.data('colorValue');
            var hashParams = {};

            _this.elems.$image.attr('src', imageUrl);
            _this.skuQuery = {
                color: colorValue.toString()
            };
            hashParams[_this.productCode] = _this.skuQuery;

            $link.attr('href', rawHref + '#' + $.param(hashParams, false));

            _this.elems.$colorButton.removeClass(DEFAULTS.CLASSES.PRODUCT_COLORS_ITEM_SELECTED);
            $selectedColorButton.addClass(DEFAULTS.CLASSES.PRODUCT_COLORS_ITEM_SELECTED);

            app.modules.CompareBar[0]
                .updateCompareList({
                    colorValue: colorValue,
                    productCode: _this.productCode,
                    img: _this.elems.$productImage.attr('src')
                })
                .render();
        }
    });

    app.ProductGridItem = ProductGridItem;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.Modernizr, window._, window.Response);

;(function(window, document, $, dust, _, Response) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            PREVIOUS_BUTTON_CLASS: '.quickview__btn_prev',
            NEXT_BUTTON_CLASS: '.quickview__btn_next',

            PRODUCT_SPACER: '.product-spacer',
            DATA_EXPANDING_CLOSE: '.quickview__close',

            WRAPPER_CLASS: '.quickview',
            BODY: 'body, html',

            PRODUCT_DESCRIPTION: '.product-detail__description-read-more',
            PRODUCT_DESCRIPTION_LINK: 'a.product-detail__description-read-more-link'
        },
        CLASSES: {
            ACTIVE: 'active',
            NO_ANIMATION: 'no-animation'
        },
        SCROLL_PADDING: -145,
        TABLET_LANDSCAPE_DIMENSIONS: 769,
        THROTTLE: 200,
        SUFFIX: '/jcr:content.quickview.json',
        PRODUCT_DESCRIPTION_HEIGHT: 80
    };

    var QuickView = function QuickView($element, parent) {
        var _this = this instanceof QuickView ? this : Object.create(QuickView.prototype);

        _this.elems = {
            $component: $element,
            $wrapper: $element.parent(DEFAULTS.SELECTORS.WRAPPER_CLASS),
            $body: $(DEFAULTS.SELECTORS.BODY),
            $productDescription: $('')
        };
        _this.elems.$spacer = _this.elems.$wrapper.next(DEFAULTS.SELECTORS.PRODUCT_SPACER);

        _this.productData = null;
        _this.parent = parent;
        _this.subModules = {};

        _this.bindEvents();

        return _this;
    };

    $.extend(QuickView.prototype, {
        initialize: function initialize(moveToAnotherQuickView) {
            var _this = this;

            if (_this.$detachedComponent) {
                _this.elems.$wrapper.append(_this.$detachedComponent);
            }

            if (_this.productData) {
                _this.open(moveToAnotherQuickView);
            } else {
                _this.getData(moveToAnotherQuickView);
            }
        },

        bindEvents: function bindEvents() {
            // jscs:disable
            this.elems.$component.on('click', DEFAULTS.SELECTORS.PREVIOUS_BUTTON_CLASS, $.proxy(this.moveTo, this, -1));
            this.elems.$component.on('click', DEFAULTS.SELECTORS.NEXT_BUTTON_CLASS, $.proxy(this.moveTo, this, +1));
            // jscs:enable
            this.elems.$component.on('click', DEFAULTS.SELECTORS.DATA_EXPANDING_CLOSE, $.proxy(this.close, this));
            $(window).on('resize', _.throttle($.proxy(this.onResize, this), DEFAULTS.THROTTLE));

            app.subscribe(app.EVENTS.CLOSE_QUICK_VIEW, $.proxy(this.close, this));
        },

        onResize: function onResize() {
            if (Response.band(DEFAULTS.TABLET_LANDSCAPE_DIMENSIONS)) {
                this.defineHeight();
            } else {
                this.close();
            }
        },

        moveTo: function moveTo(increment) {
            if (app.modules.ProductGridItem[this.parent.id + increment]) {
                app.modules.ProductGridItem[this.parent.id + increment].openQuickView();
            }
        },

        open: function open(moveToAnotherQuickView) {
            var _this = this;

            app.trigger(app.EVENTS.CLOSE_QUICK_VIEW, _this.parent.id);

            setTimeout(function() {

                if (moveToAnotherQuickView) {
                    _this.parent.grid.elems.$component.addClass(DEFAULTS.CLASSES.NO_ANIMATION);
                }

                _this.productData = _this.extendProductData(_this.productData);

                dust.render('productGridQuickview', _this.productData, function(error, out) {
                    var $quickView = _this.elems.$component.html(out);

                    app.createSubModule(_this.elems.$component, _this);

                    _this.elems.$productDescription = $quickView.find(DEFAULTS.SELECTORS.PRODUCT_DESCRIPTION);

                    _this.elems.$productDescription.dotdotdot({
                        height: DEFAULTS.PRODUCT_DESCRIPTION_HEIGHT,
                        after: DEFAULTS.SELECTORS.PRODUCT_DESCRIPTION_LINK,
                        watch: 'window'
                    });

                    _this.defineHeight();
                    _this.parent.elems.$component.addClass(DEFAULTS.CLASSES.ACTIVE);
                    _this.defineTop(_this.elems.$component);

                    _this.parent.grid.elems.$component.removeClass(DEFAULTS.CLASSES.NO_ANIMATION);
                    _this.$detachedComponent = null;
                });

                app.trigger(app.EVENTS.ANALYTICS.QUICK_VIEW_CLICKED, _this.productData);

            }, 0);
        },

        close: function close(id) {
            if (this.parent.id === id) {
                return;
            }

            this.elems.$spacer.height(0);
            this.elems.$wrapper.height(0);

            if (this.parent) {
                this.parent.elems.$component.removeClass(DEFAULTS.CLASSES.ACTIVE);
            }

            if (_.isObject(id)) {
                this.defineTop(this.parent.elems.$component);
            }

            this._destroyOldContent();

            this.elems.$productDescription.trigger('destroy');

            this.$detachedComponent = this.elems.$component.detach();
        },

        extendProductData: function extendProductData(data) {
            data.hasPrev = this.parent.id !== 0;
            data.hasNext = this.parent.id !== app.modules.ProductGridItem.length - 1;
            data.skuQuery = this.parent.skuQuery;

            // FIXME: rename on backend "path" to "productPageUrl"
            data.productPageUrl = data.path;

            return data;
        },

        defineTop: function defineTop($element) {
            var top = $element.offset().top + DEFAULTS.SCROLL_PADDING;

            this.elems.$body.scrollTop(top);
        },

        defineHeight: function defineHeight() {
            var _this = this;
            var height = _this.elems.$component.outerHeight();

            _this.elems.$spacer.height(height);
            _this.elems.$wrapper.height(height);
        },

        getData: function getData(moveToAnotherQuickView) {
            var _this = this;

            $.ajax({
                url: _this.parent.productPageUrl + DEFAULTS.SUFFIX,
                beforeSend: function() {
                    app.modules.MainContentSpinner[0].spinner('show');
                },
                type: 'GET',
                success: function(data) {
                    // FIXME:
                    data.type = data.type.toLowerCase();

                    _this.productData = data;
                    _this.open(moveToAnotherQuickView);
                },
                error: function(jqXhr, ajaxOptions, thrownError) {
                    _this.close();

                    console.error('"QuickView.getData" >> error: request failed!', jqXhr, ajaxOptions, thrownError);
                },
                complete: function() {
                    app.modules.MainContentSpinner[0].spinner('hide');
                }
            });
        },

        _destroyOldContent: function _destroyOldContent() {

            /**
             * Create and initialize following modules:
             * - MediaViewer
             * - SkuSelector
             * - AddToCart
             * - FindInStore
             * - AddToWishList
             */
            /* This.elems.$component.find('[data-module-type]').each(function() {
                var moduleName = $(this).data('module-type');

                if (app.modules[moduleName] && app.modules[moduleName][app.modules[moduleName].length - 1]) {
                    var module = app.modules[moduleName][app.modules[moduleName].length - 1];

                    if ('destroy' in module) {
                        module.destroy();
                    }

                    delete app.modules[moduleName][app.modules[moduleName].length - 1];

                    app.modules[moduleName].splice(app.modules[moduleName].length - 1, 1);
                }
            });*/

            _.each(this.subModules, function(modules) {
                _.each(modules, function(module) {
                    if ('destroy' in module) {
                        module.destroy();
                    }
                });
            });

            delete this.subModules;
        }
    });

    app.QuickView = QuickView;

    return app.QuickView;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust, window._, window.Response);

;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            GRID_ITEM: '.static-grid__item',
            GRID_ITEM_IMAGE: '.static-grid__item_image'
        }
    };

    var BannerGrid = function BannerGrid($element) {
        var _this = this instanceof BannerGrid ? this : Object.create(BannerGrid.prototype);

        _this.elems = {
            $component: $element
        };

        _this.initialize();

        return _this;
    };

    $.extend(BannerGrid.prototype, {

        initialize: function initialize() {
            var $gridItemImage = this.elems.$component.find(DEFAULTS.SELECTORS.GRID_ITEM_IMAGE);
            var sectionType = $gridItemImage.closest(DEFAULTS.SELECTORS.GRID_ITEM).data('sectionType');
            var dataImageSize = '[data-image-size="' + sectionType + '"]';
            var imageSrc = $gridItemImage.nextAll(dataImageSize).data('src');

            if (!imageSrc) {
                imageSrc = $gridItemImage.nextAll(dataImageSize).data('placeholderSrc');
            }

            // If image was set at Adobe Target, avoid image override
            if (!$gridItemImage.attr('src') || $gridItemImage.attr('src').indexOf('data:image') !== -1) {
                $gridItemImage.attr('src', imageSrc);
            } else {
                // Add to ADOBE Target image right params
                if (imageSrc.indexOf('?') !== -1) {
                    var imageParams = imageSrc.split('?')[1];
                    var adobeTargetImageUrl = $gridItemImage.attr('src').split('?')[0];

                    $gridItemImage.attr('src', adobeTargetImageUrl + '?' + imageParams);
                }

                $gridItemImage.attr('style', '');
            }
        }
    });

    app.BannerGrid = BannerGrid;

    return app.BannerGrid;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, Modernizr) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            PARENT: '.page-container',
            HEADER_CLASS: 'header-banner',
            SALE_BANNER_LINK: '.sale-banner__link',
            CLOSE_BTN: '.sale-banner-close'
        }
    };

    var PromoWide = function PromoWide($element) {
        var _this = this instanceof PromoWide ? this : Object.create(PromoWide.prototype);

        _this.elems = {
            $component: $element,
            $close: $element.find(DEFAULTS.SELECTORS.CLOSE_BTN),
            $headerBanner: $element.closest(DEFAULTS.SELECTORS.PARENT).addClass(DEFAULTS.SELECTORS.HEADER_CLASS),
            $saleBannerLink: $element.find(DEFAULTS.SELECTORS.SALE_BANNER_LINK)
        };

        _this.initialize();

        return _this;
    };

    $.extend(PromoWide.prototype, {
        initialize: function initialize() {
            this.bindEvents();

            if (Modernizr.sessionstorage) {
                this._checkSession();
            }
        },

        bindEvents: function bindEvents() {
            this.elems.$close.on('click', $.proxy(this._setSession, this));
            this.elems.$saleBannerLink.on('click', $.proxy(this.openPromo, this));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this._setSession, this));
        },

        close: function close() {
            this.elems.$component.hide();
            this.elems.$headerBanner.removeClass(DEFAULTS.SELECTORS.HEADER_CLASS);
        },

        openPromo: function openPromo(event) {
            var $promoText = $(event.currentTarget).data('promo-text');

            event.preventDefault();
            app.modules.PromoDescription[0].openModal($promoText);
        },

        _checkSession: function checkSession() {
            if (sessionStorage.isWideBannerClosed) {
                this.close();
            }
        },

        _setSession: function setSession() {
            if (Modernizr.sessionstorage) {
                sessionStorage.setItem(app.SESSION_VARS.IS_WIDE_BANNER_CLOSED, true);
            }

            this.close();
        }
    });

    app.PromoWide = PromoWide;

    return app.PromoWide;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.Modernizr);
;(function(window, document, $, CQ) {
    var app = this;

    /*
     * Constructor
     */
    var CookieEnabled = function CookieEnabled() {
        var _this = this instanceof CookieEnabled ? this : Object.create(CookieEnabled.prototype);

        _this.initialize();

        return _this;
    };

    $.extend(CookieEnabled.prototype, {
        initialize: function initialize() {
            // Set cookie to verify if it's enabled or not
            $.cookie(app.COOKIES.COOKIE_ENABLED, true, {
                path: '/'
            });

            var cookieEnabled = $.cookie(app.COOKIES.COOKIE_ENABLED);

            if (!cookieEnabled) {
                this._open();
            }
        },

        _reloadPage: function _reloadPage() {
            window.location.reload();
        },

        _open: function _open() {
            app.modules.Confirm.openModal({
                title: CQ.I18n.get('GLB0170'),
                description: CQ.I18n.get('GLB0171'),
                confirmText: CQ.I18n.get('GLB0034')
            }, this._reloadPage);
        }
    });

    app.CookieEnabled = CookieEnabled;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);
;(function(window, document, $, CQ) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {

        SELECTORS: {
            LINK_REGISTER: '.activity-modal__register__link',
            FORGOT_PASSWORD_FORM: '.forgot-password-form',
            FORGOT_PASSWORD_BUTTON: '.forgot-password-form__submit',
            REGISTRATION_LINK: '.forgot-password-modal__register__link'
        },

        VALIDATION_ERROR: 'validation-error',
        VALIDATION_ERROR_SHOW: 'validation-error_show',

        SERVICES: {
            FORGOT_PASSWORD: '/services/sportchek/customers/forgotpassword'
        }
    };

    /*
     * Constructor
     */
    var ForgotPassword = function ForgotPassword($element) {
        var _this = this instanceof ForgotPassword ? this : Object.create(ForgotPassword.prototype);

        _this.elems = {
            $component: $element,
            $form: $element.find(DEFAULTS.SELECTORS.FORGOT_PASSWORD_FORM)
        };

        _this.bindEvents();

        return _this;
    };

    $.extend(ForgotPassword.prototype, {
        bindEvents: function bindEvents() {
            this._bindValidate();
            this.elems.$component.on('click', DEFAULTS.SELECTORS.REGISTRATION_LINK, $.proxy(this.clickRegister, this));
        },

        _bindValidate: function _bindValidate() {
            var _this = this;

            _this.validator = _this.elems.$form.validate({
                errorClass: DEFAULTS.VALIDATION_ERROR,
                errorElement: 'span',
                rules: {
                    email: {
                        required: true,
                        spcEmail: true
                    }
                },
                messages: {
                    email: {
                        required: CQ.I18n.get('error.customers.validation.registerData.login.NotBlank'),
                        spcEmail: CQ.I18n.get('error.customers.validation.registerData.login.Pattern')
                    }
                },
                errorPlacement: function(error, input) {
                    $(input).after($(error).addClass(DEFAULTS.VALIDATION_ERROR_SHOW));
                },
                submitHandler: function(form) {
                    var data = $(form).toObject();

                    data.email = $.trim(data.email);
                    _this.getPassword(data);
                }
            });
        },

        getPassword: function getPassword(formObject) {
            var _this = this;

            $.ajax({
                url: DEFAULTS.SERVICES.FORGOT_PASSWORD,
                type: 'POST',
                contentType: 'application/json; charset=utf-8',
                data: JSON.stringify(formObject),
                dataType: 'JSON',

                beforeSend: function() {
                    app.modules.MainContentSpinner[0].spinner('show');
                },

                success: function() {
                    app.modules.Alert.openModal({
                        title: CQ.I18n.get('GLB0118'),
                        description: CQ.I18n.get('GLB0119')
                    });
                    _this.clearForm();
                },

                error: function(jqXhr, ajaxOptions, error) {
                    switch (jqXhr.status) {
                        case 400:
                            app.modules.Alert.openModal({
                                title: CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message)
                            });

                            break;

                        case 403:

                        case 424:
                            _this.validator.showErrors({
                                email: CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message)
                            });

                            break;

                        default:
                            console.error('"ForgotPassword.getPassword" >> ' + jqXhr.status + ' (' + error + ')');
                    }
                },

                complete: function() {
                    app.modules.MainContentSpinner[0].spinner('hide');
                }
            });
        },

        clearForm: function clearForm() {
            this.elems.$form[0].reset();
            this.validator.resetForm();
        },

        clickRegister: function clickRegister() {
            app.trigger(app.EVENTS.ANALYTICS.SHOW_REGISTER_MODAL, {formLocation: 'Forgot Password Modal'});
        }
    });

    app.ForgotPassword = ForgotPassword;

    return app.ForgotPassword;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);
;(function(window, document, $, CQ) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SERVICES: {
            FORGOT_PASSWORD: '/services/sportchek/customers/resetpassword',
            VALIDATE_TOKEN: '/services/sportchek/customers/security/validate/token'
        },

        VALIDATION_ERROR: 'validation-error',
        VALIDATION_ERROR_SHOW: 'validation-error_show'
    };

    /*
     * Constructor
     */
    var ChangeForgotPassword = function ChangeForgotPassword($element) {
        var _this = this instanceof ChangeForgotPassword ? this : Object.create(ChangeForgotPassword.prototype);

        _this.elems = {
            $component: $element
        };

        _this.token = null;

        _this.initialize();
        _this.bindEvents();

        return _this;
    };

    $.extend(ChangeForgotPassword.prototype, {
        initialize: function initialize() {

            // Open change forgot password modal window if 'changePasswordToken' exist
            this._activateChangeForgotPassword();
        },

        bindEvents: function bindEvents() {
            this._bindValidate();
        },

        _bindValidate: function _bindValidate() {
            var _this = this;

            _this.validator = _this.elems.$component.validate({
                errorClass: DEFAULTS.VALIDATION_ERROR,
                errorElement: 'span',
                rules: {
                    password: {
                        required: true,
                        rangelength: [6, 40],
                        spcPassword: true
                    },
                    confirmPassword: {
                        equalTo: _this.elems.$component.find('input[name="password"]')
                    }
                },
                messages: {
                    password: {
                        required: CQ.I18n.get('error.customers.validation.registerData.password.NotBlank'),
                        rangelength: CQ.I18n.get('error.customers.validation.registerData.password.Size'),
                        spcPassword: CQ.I18n.get('error.customers.validation.registerData.password.Pattern')
                    },
                    confirmPassword: {
                        equalTo: CQ.I18n.get('error.customers.validation.registerData.password.Equal')
                    }
                },
                errorPlacement: function(error, input) {
                    $(input).after($(error).addClass(DEFAULTS.VALIDATION_ERROR_SHOW));
                },
                submitHandler: function(form) {
                    _this._changePassword(form);
                }
            });
        },

        _activateChangeForgotPassword: function _activateChangeForgotPassword() {
            var _this = this;
            var changePasswordToken = $.bbq.getState().changePasswordToken;

            if (changePasswordToken) {
                _this._validateToken(changePasswordToken);
            }
        },

        _validateToken: function _validateToken(token) {
            var _this = this;

            $.ajax({
                url: DEFAULTS.SERVICES.VALIDATE_TOKEN,
                type: 'GET',
                data: 'token=' + token,
                dataType: 'JSON',
                success: function() {
                    app.modules.AuthModal[0].open({
                        step: 'change-forgot-password'
                    });

                    _this.token = token;
                },
                error: function(jqXhr, ajaxOptions, error) {
                    switch (jqXhr.status) {
                        case 400:

                        case 424:
                            app.modules.AuthModal[0].open({
                                step: 'forgot-password-error'
                            });

                            break;

                        default:
                            console.error('"ChangeForgotPassword._validateToken" >> ' + jqXhr.status + ' (' + error + ')');
                    }
                }
            });
        },

        _changePassword: function _changePassword(form) {
            var _this = this;
            var formData = $(form).toObject();

            // Not supported by the contract
            delete formData.confirmPassword;
            // Add token value to the data that have to be send to the service
            formData.token = _this.token;

            $.ajax({
                url: DEFAULTS.SERVICES.FORGOT_PASSWORD,
                type: 'POST',
                contentType: 'application/json; charset=utf-8',
                data: JSON.stringify(formData),
                dataType: 'JSON',
                beforeSend: function() {
                    app.modules.MainContentSpinner[0].spinner('show');
                },
                success: function() {
                    app.modules.AuthModal[0].gotoStep({
                        step: 'change-forgot-password-confirmation'
                    });

                    _this.elems.$component[0].reset();
                },
                error: function(jqXhr, ajaxOptions, error) {
                    switch (jqXhr.status) {
                        case 400:

                        case 424:
                            _this.validator.showErrors({
                                password: CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message)
                            });

                            break;

                        default:
                            console.error('"ChangeForgotPassword._changePassword" >> ' + jqXhr.status + ' (' + error + ')');
                    }
                },
                complete: function() {
                    app.modules.MainContentSpinner[0].spinner('hide');
                }
            });
        }
    });

    app.ChangeForgotPassword = ChangeForgotPassword;

    return app.ChangeForgotPassword;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);

;(function(window, document, $, CQ, Modernizr) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SELECTORS: {
            AUTH_MODAL: '#auth-modal',
            STEP: '[data-step]',
            // We need to change only first.
            TITLE: '.modal__title:first',
            DESCRIPTION: 'p.gray-text',
            MFP_CONTENT: '.mfp-content',
            FORM_SUBMIT_MESSAGE: '.sign-up-message-form__submit',
            REGISTRATION_LINK: '.signin-checkout-guest-modal__register__link'
        },
        CLASSES: {
            MAIN_CLASS: 'default-modal auth-modal expandable-modal',
            MFP_CONTENT: 'mfp-content'
        },
        TABLET_PORTRAIT: 768
    };

    /*
     * Constructor
     */
    var AuthModal = function AuthModal($element) {
        var _this = this instanceof AuthModal ? this : Object.create(AuthModal.prototype);

        _this.elems = {
            $component: $element
        };

        _this.initializedStep = '';
        _this.doNotOpen = false;
        _this.initializedOnCloseCallback = $.noop;

        _this.bindEvents();

        return _this;
    };

    $.extend(AuthModal.prototype, {
        bindEvents: function bindEvents() {
            var _this = this;

            // TODO: remove this binding
            _this.elems.$component.on('click', DEFAULTS.SELECTORS.FORM_SUBMIT_MESSAGE, function(e) {
                e.preventDefault();

                $.SpcMagnificPopup.close();
            });

            _this.elems.$component.on('click', '[data-goto-step]', function(e) {
                e.preventDefault();

                _this.gotoStep({
                    step: $(this).data('goto-step')
                });
            });

            this.elems.$component.on('click', DEFAULTS.SELECTORS.REGISTRATION_LINK, $.proxy(this.clickRegister, this));
        },

        preventOpen: function preventOpen() {
            this.doNotOpen = true;
        },

        /**
         * @param {Object} [config]
         */
        open: function open(config) {
            var _this = this;

            config = config || {};

            // FIXME:
            /*
             * Should ignore state of 'doNotOpen' flag for step 'resend-activation-link-confirmation'
             */
            if (_this.doNotOpen && config.step !== 'resend-activation-link-confirmation') {
                return;
            }

            if (app.modules.SessionExpirationModal) {
                app.modules.SessionExpirationModal[0].cancelRedirect();
                app.modules.SessionExpirationModal[0].close();
            }

            var $popupContent = $.SpcMagnificPopup.getInstance().content;

            var isPopupOpened = $popupContent ? $popupContent.hasClass('auth-modal') : false;

            if (isPopupOpened && config.step) {
                _this.gotoStep(config);

                return;

            } else {
                $.SpcMagnificPopup.getInstance().close();
            }

            _this.initializedStep = _this.initializedStep || config.step;
            _this.initializedOnCloseCallback = config.onClose || _this.initializedOnCloseCallback || $.noop;

            $.SpcMagnificPopup.open({
                mainClass: DEFAULTS.CLASSES.MAIN_CLASS,
                items: {
                    src: DEFAULTS.SELECTORS.AUTH_MODAL
                },
                callbacks: {
                    open: function() {
                        _this.gotoStep(config);

                        if (config.onOpen) {
                            config.onOpen();
                        }
                    },

                    close: function() {
                        _this.elems.$component
                            .closest(DEFAULTS.SELECTORS.MFP_CONTENT)
                            .attr('class', DEFAULTS.CLASSES.MFP_CONTENT);

                        _this.initializedOnCloseCallback();

                        _this.initializedStep = '';
                        _this.initializedOnCloseCallback = null;

                        // FIXME:

                        /*
                         * If current page is Account Page
                         */
                        if (app.modules.AccountSideBar && !app.modules.User.isLoggedIn()) {
                            _this.preventOpen();

                            app.modules.User.logOut();
                            app.modules.HeaderLogo[0].goToHome();
                        }
                    }
                }
            });
        },

        close: function close() {
            $.SpcMagnificPopup.close();
        },

        gotoStep: function gotoStep(config) {
            config = config || {};

            var step = config.step || 'signin';

            if (step === 'signin' && this.initializedStep === 'signin-checkout') {
                step = 'signin-checkout';
            }

            var $stepElement = this.elems.$component.find('[data-step="' + step + '"]');

            this.elems.$component
                .closest(DEFAULTS.SELECTORS.MFP_CONTENT)
                .attr('class', 'mfp-content mfp-content__' + step);

            this.elems.$component
                .find(DEFAULTS.SELECTORS.STEP)
                .hide();

            if (config.title) {
                $stepElement.find(DEFAULTS.SELECTORS.TITLE).text(CQ.I18n.get(config.title));
            }

            if (config.descriptionKey) {
                $stepElement.find(DEFAULTS.SELECTORS.DESCRIPTION).text(CQ.I18n.get(config.description));
            }

            $stepElement.show();

            if (!Modernizr.touch) {
                setTimeout(function() {
                    $stepElement.find('input').eq(0).focus();
                }, 100);
            }

            return this;
        },

        clickRegister: function clickRegister() {
            app.trigger(app.EVENTS.ANALYTICS.SHOW_REGISTER_MODAL);
        }
    });

    app.AuthModal = AuthModal;

    return app.AuthModal;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ, window.Modernizr);
;(function(window, document, $, CQ) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SELECTORS: {
            REGISTER_BUTTON: '.register-form__submit',
            REGISTER_MODAL: '.register-modal'
        },

        VALIDATION_ERROR: 'validation-error',
        VALIDATION_ERROR_SHOW: 'validation-error_show',

        SERVICES: {
            SIGN_UP: '/services/sportchek/customers/signup'
        }
    };

    /*
     * Constructor
     */
    var Register = function Register($element) {
        var _this = this instanceof Register ? this : Object.create(Register.prototype);

        _this.elems = {
            $component: $element,
            $registerModal: $element.closest(DEFAULTS.SELECTORS.REGISTER_MODAL)
        };

        _this.bindEvents();

        return _this;
    };

    $.extend(Register.prototype, {
        bindEvents: function bindEvents() {
            this._bindValidate();
        },

        _bindValidate: function _bindValidate() {
            var _this = this;

            _this.elems.$component.validate({
                errorClass: DEFAULTS.VALIDATION_ERROR,
                errorElement: 'span',
                rules: {
                    login: {
                        required: true,
                        spcEmail: true
                    },
                    password: {
                        required: true,
                        rangelength: [6, 40],
                        notEqualTo: 'input[name="login"]',
                        spcPassword: true
                    },
                    confirmPassword: {
                        required: true,
                        rangelength: [6, 40],
                        notEqualTo: 'input[name="login"]',
                        spcPassword: true,
                        equalTo: _this.elems.$component.find('input[name="password"]')
                    }
                },
                messages: {
                    login: {
                        required: CQ.I18n.get('error.customers.validation.registerData.login.NotBlank'),
                        spcEmail: CQ.I18n.get('error.customers.validation.registerData.login.Pattern')
                    },
                    password: {
                        required: CQ.I18n.get('error.customers.validation.registerData.password.NotBlank'),
                        rangelength: CQ.I18n.get('error.customers.validation.registerData.password.Size'),
                        notEqualTo: CQ.I18n.get('error.customers.validation.credentials.same'),
                        spcPassword: CQ.I18n.get('error.customers.validation.registerData.password.Pattern')
                    },
                    confirmPassword: {
                        required: CQ.I18n.get('error.customers.validation.registerData.password.NotBlank'),
                        rangelength: CQ.I18n.get('error.customers.validation.registerData.password.Size'),
                        notEqualTo: CQ.I18n.get('error.customers.validation.credentials.same'),
                        spcPassword: CQ.I18n.get('error.customers.validation.registerData.password.Pattern'),
                        equalTo: CQ.I18n.get('error.customers.validation.registerData.password.Equal')
                    }
                },
                errorPlacement: function(error, input) {
                    $(input).after($(error).addClass(DEFAULTS.VALIDATION_ERROR_SHOW));
                },
                submitHandler: function(form) {
                    _this.register(form);
                }
            });
        },

        register: function register(form) {
            var _this = this;
            var formData = $(form).toObject();

            formData.login = $.trim(formData.login);
            // Not supported by the contract
            delete formData.confirmPassword;

            $.ajax({
                url: DEFAULTS.SERVICES.SIGN_UP,
                type: 'POST',
                contentType: 'application/json; charset=utf-8',
                data: JSON.stringify(formData),
                dataType: 'JSON',

                beforeSend: function() {
                    _this.elems.$registerModal.spinner('show');
                },

                success: function(data) {
                    app.trigger(app.EVENTS.ANALYTICS.COMPLETE_REGISTER_MODAL, data);

                    app.modules.User.update(data);

                    app.modules.AuthModal[0].gotoStep({
                        step: 'register-confirmation'
                    });

                    _this.elems.$component[0].reset();
                },

                error: function(jqXhr, ajaxOptions, error) {
                    switch (jqXhr.status) {
                        case 400:
                            // TODO: must be handled by a separate status
                            if (JSON.parse(jqXhr.responseText).messages[0].message === 'error.customers.validation.email.duplicate') {
                                app.modules.AuthModal[0].gotoStep({
                                    step: 'register-error'
                                });
                                _this.elems.$component[0].reset();

                                break;
                            }

                            app.modules.Alert.openModal({
                                title: CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message)
                            });

                            break;

                        case 403:

                        case 404:
                            // FIXME: messages[0].message absent when service not found
                            app.modules.Alert.openModal({
                                title: CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message)
                            });

                            break;

                        default:
                            console.error('"Register.register" >> ' + jqXhr.status + ' (' + error + ')');
                    }
                },

                complete: function() {
                    _this.elems.$registerModal.spinner('hide');
                }
            });
        }
    });

    Register.DEFAULTS = DEFAULTS;

    app.Register = Register;

    return app.Register;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);
;(function(window, document, $, dust) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SELECTORS: {
            MODAL_ID: '#promotion-details',
            MODAL_PLACEHOLDER_CLASS: '.promotion-details__placeholder',
            ELLIPSIS: '.ellipsis'
        },
        MODAL_MAIN_CLASS: 'default-modal default-modal_wide',
        SERVICES_URL: {
            INFO: '/services/sportchek/cart/cartPromoMessages'
        }
    };

    var PromotionDetails = function PromotionDetails($element) {
        var _this = this instanceof PromotionDetails ? this : Object.create(PromotionDetails.prototype);

        _this.elems = {
            $component: $element,
            $placeholder: $(DEFAULTS.SELECTORS.MODAL_ID).find(DEFAULTS.SELECTORS.MODAL_PLACEHOLDER_CLASS)
        };

        _this.data = _this.elems.$component.data('promotional-modal');

        _this.initialize();
        _this.bindEvents();

        return _this;
    };

    $.extend(PromotionDetails.prototype, {
        initialize: function initialize() {
            this.elems.$component.find(DEFAULTS.SELECTORS.ELLIPSIS).dotdotdot({
                watch: 'window'
            });
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', $.proxy(this._open, this));
        },

        _open: function _open(e) {
            e.preventDefault();

            var _this = this;

            $.SpcMagnificPopup.open({
                mainClass: DEFAULTS.MODAL_MAIN_CLASS,
                items: {
                    src: DEFAULTS.SELECTORS.MODAL_ID
                },
                callbacks: {
                    open: function() {
                        _this.onPopupOpen(this);
                    },
                    close: function() {
                        _this.elems.$placeholder.empty();
                    }
                }
            });
        },

        onPopupOpen: function onPopupOpen() {
            if (this.data && this.data.productMessages && this.data.productMessages[0].longMessage !== undefined) {
                this.render(this.data);
            } else {
                this._getProductInfo();
            }
        },

        _close: function _close() {
            $.SpcMagnificPopup.close();
        },

        _getProductInfo: function _getProductInfo() {
            var _this = this;

            $.ajax({
                url: DEFAULTS.SERVICES_URL.INFO,
                type: 'GET',
                beforeSend: function() {
                    _this.elems.$placeholder.spinner('show');
                },
                success: function(data) {
                    _this.render(data);
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    console.error('"PromotionDetails._getProductInfo" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    app.modules.Alert.openModal({
                        title: '"PromotionDetails._getProductInfo" >> ' + jqXhr.status + ' (' + errorThrown + ')'
                    });

                    _this._close();
                },
                complete: function() {
                    _this.elems.$placeholder.spinner('hide');
                }
            });
        },

        render: function render(data) {
            var _this = this;

            // FIXME
            data.isShipping = _this.data && _this.data.isShipping;
            data.emptyPromoMessage = _this._isEmptyPromoMessage(data);
            dust.render('promotionDetails', data, function(error, out) {
                _this.elems.$placeholder.html(out);
            });
        },

        _isEmptyPromoMessage: function _isEmptyPromoMessage(data) {
            var productMessages = data.productMessages;
            var i;

            for (i = 0; productMessages && i < productMessages.length; i++) {
                if (productMessages[i].shortMessage || productMessages[i].longMessage.length) {
                    return false;
                }
            }

            var appliedOrderPromoMessages = data.appliedOrderPromoMessages;

            for (i = 0; appliedOrderPromoMessages && i < appliedOrderPromoMessages.length; i++) {
                if (appliedOrderPromoMessages[i].shortMessage || appliedOrderPromoMessages[i].longMessage.length) {
                    return false;
                }
            }

            var appliedProductPromoMessages = data.appliedProductPromoMessages;

            for (i = 0; appliedProductPromoMessages && i < appliedProductPromoMessages.length; i++) {
                if (appliedProductPromoMessages[i].shortMessage || appliedProductPromoMessages[i].longMessage.length) {
                    return false;
                }
            }

            return true;
        }
    });

    PromotionDetails.DEFAULTS = DEFAULTS;
    app.PromotionDetails = PromotionDetails;

    return app.PromotionDetails;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust);
;(function(window, document, $, dust) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {

        SELECTORS: {
            MODAL_ID: '#session-expiration-modal',
            EXPIRATION_WARNING: '.expiration-modal__expiration-warning',
            EXPIRATION_MESSAGE: '.expiration-modal__expiration-message',
            ACTION_TRIGGER: '[data-action]',
            CONTINUE_BUTTON: '.expiration-modal__continue-button'
        },

        CLASSES: {
            HIDDEN: 'mfp-hide'
        },

        SERVICES: {
            PROLONG: '/services/sportchek/customers/login/prolong'
        },

        CONST: {
            WARNING: 1,
            MESSAGE: 2
        },

        PAGE_REFERRERS: {
            HOME: 'home',
            SHOPPING_CART: 'shopping-cart'
        },

        KEY: 'sportchek-modal',

        EXPIRATION_WARNING_TIME: '13:00',
        EXPIRATION_MESSAGE_TIME: '02:00'
    };

    var SessionExpirationModal = function SessionExpirationModal($element) {
        var _this = this instanceof SessionExpirationModal ? this : Object.create(SessionExpirationModal.prototype);

        _this.elems = {
            $component: $element,
            $expirationWarning: null,
            $expirationMessage: null
        };
        _this.subModules = {};

        _this.timeout = null;
        _this.timeoutID = null;
        _this.action = null;
        _this.activeWindow = DEFAULTS.CONST.WARNING;
        _this.redirectToAnotherPage = '';

        _this.initialize();

        return _this;
    };

    $.extend(SessionExpirationModal.prototype, {

        initialize: function initialize() {
            this.bindEvents();
            this.resetCountdown();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            $.ajaxPrefilter(function(options) {
                if (options.url.match('/services/sportchek/')) {
                    _this.resetCountdown();
                }
            });

            app.subscribe(app.EVENTS.LOG_IN, function() {
                _this.close(false);
            });

            app.subscribe(app.EVENTS.LOG_OUT, function() {
                _this.clearCountdown();

                if (_this.isShoppingCartPage()) {
                    app.modules.ShoppingCart[0].getRecalculatedCart();
                }

                /*
                 * Redirection to ShoppingCart page or Home page depending on what the current page is
                 */
                _this.redirect();
            });

            _this.elems.$component.on('click', DEFAULTS.SELECTORS.ACTION_TRIGGER, function(e) {
                e.preventDefault();

                switch ($(e.currentTarget).data('action')) {
                    case 'login':
                        _this.close(false);

                        app.modules.AuthModal[0].open();

                        break;

                    case 'register':
                        _this.close(false);

                        app.modules.AuthModal[0].open({
                            step: 'register'
                        });

                        break;

                    case 'continue':

                        if (_this.activeWindow === DEFAULTS.CONST.WARNING) {
                            _this.elems.$expirationWarning.addClass(DEFAULTS.CLASSES.HIDDEN);

                            _this.keepLoggedIn(e.delegateTarget);
                            _this.close(false);

                        } else {
                            _this.close(true);
                        }

                        break;
                }
            });

            return _this;
        },

        openModal: function openModal() {
            var _this = this;

            $.SpcMagnificPopup.open({
                items: {
                    src: DEFAULTS.SELECTORS.MODAL_ID
                },
                callbacks: {
                    close: function() {
                        _this.redirectToAnotherPage = '';

                        /*
                         * If user close first warning window by clicking cross sign then keep session
                         */
                        if (_this.activeWindow === DEFAULTS.CONST.WARNING  && app.modules.User.isLoggedIn()) {
                            _this.elems.$component.find(DEFAULTS.SELECTORS.CONTINUE_BUTTON).click();
                        }

                        /*
                         * Check the second Expiration Window
                         */
                        if (_this.activeWindow === DEFAULTS.CONST.MESSAGE) {
                            /*
                             * If user is on any page except Checkout and ShoppingCart page then move to Home page
                             */
                            if (!_this.isCheckoutPage() && !_this.isShoppingCartPage()) {
                                _this.redirectToAnotherPage = DEFAULTS.PAGE_REFERRERS.HOME;
                            }

                            /*
                             * If user is on Checkout page then always move to shopping cart. No matter if he is a guest of registered user
                             */
                            if (_this.isCheckoutPage()) {
                                _this.redirectToAnotherPage = DEFAULTS.PAGE_REFERRERS.SHOPPING_CART;
                                _this.redirect();
                            }
                        }

                        if (!app.modules.User.isLoggedIn() && _this.activeWindow === DEFAULTS.CONST.MESSAGE) {
                            app.modules.AuthModal[0].preventOpen();
                            app.modules.User.logOut();
                        }
                    }
                }
            });

            return _this;
        },

        isShoppingCartPage: function isShoppingCartPage() {
            return Boolean(app.modules.ProductList);
        },

        isCheckoutPage: function isCheckoutPage() {
            return Boolean(app.modules.StepsBar);
        },

        cancelRedirect: function cancelRedirect() {
            this.redirect = $.noop;
        },

        redirect: function redirect() {

            if (this.redirectToAnotherPage === DEFAULTS.PAGE_REFERRERS.HOME) {
                app.modules.HeaderLogo[0].goToHome();
            }

            if (this.redirectToAnotherPage === DEFAULTS.PAGE_REFERRERS.SHOPPING_CART) {
                app.modules.StepsBar[0].goToShoppingCart();
            }
        },

        keepLoggedIn: function keepLoggedIn(form) {

            var $form = $(form);
            var params = $form.toObject({
                skipEmpty: false
            });

            $.ajax({
                url: DEFAULTS.SERVICES.PROLONG,
                type: 'POST',
                dataType: 'JSON',
                data: JSON.stringify(params),

                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 403:
                            app.modules.User.logOut();

                            break;

                        case 424:
                            app.modules.Alert.openModal({
                                title: JSON.parse(jqXhr.responseText).messages[0].message
                            });

                            break;

                        default:
                            console.error('"LoggedInTimeoutModal.keepLoggedIn" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                }
            });

            return this;
        },

        // Show popup with information: "Your session will be expired after 2 minutes"
        showExpirationWarning: function showExpirationWarning() {
            $.SpcMagnificPopup.close();

            this.render();
            this.activeWindow = DEFAULTS.CONST.WARNING;

            this.elems.$expirationWarning.removeClass(DEFAULTS.CLASSES.HIDDEN);
            this.elems.$expirationMessage.addClass(DEFAULTS.CLASSES.HIDDEN);

            this.openModal().wait(DEFAULTS.EXPIRATION_MESSAGE_TIME, this.showExpirationMessage);

            return this;
        },

        // Show popup with information: "Your session ALREADY EXPIRED, please login again"
        showExpirationMessage: function showExpirationMessage() {

            this.render();
            this.activeWindow = DEFAULTS.CONST.MESSAGE;

            this.elems.$expirationWarning.addClass(DEFAULTS.CLASSES.HIDDEN);
            this.elems.$expirationMessage.removeClass(DEFAULTS.CLASSES.HIDDEN);

            this.openModal();

            app.modules.User.clearUserData();

            return this;
        },

        close: function _close() {
            var $popupContent = $.SpcMagnificPopup.getInstance().content;
            var isPopupOpened = $popupContent ? $popupContent.hasClass('expiration-modal') : false;

            if (isPopupOpened) {
                $.SpcMagnificPopup.close();
            }

            return this;
        },

        wait: function wait(_time, action) {
            this.clearCountdown();

            var time = _time || '00:00';
            var arr = time.split(':');

            var min = parseInt(arr[0], 10) || 0;
            var sec = parseInt(arr[1], 10) || 0;

            this.timeout = (min * 60 + sec) * 1000;
            this.action = action;

            return this.startCountdown();
        },

        startCountdown: function _startCountdown() {
            var _this = this;

            _this.timeoutID = setTimeout(function() {
                _this.clearCountdown();

                if (_this.action) {
                    _this.action.call(_this);
                }

            }, _this.timeout);

            return _this;
        },

        resetCountdown: function resetCountdown() {
            if (!app.modules.User.isRememberMe()) {
                this.wait(DEFAULTS.EXPIRATION_WARNING_TIME, this.showExpirationWarning);
            }

            return this;
        },

        clearCountdown: function _clearCountdown() {
            clearTimeout(this.timeoutID);

            this.timeoutID = null;
            this.timeout = null;

            return this;
        },

        render: function render() {
            var _this = this;

            var settings = {
                userIsLoggedIn: app.modules.User.isLoggedIn()
            };

            dust.render('sessionExpirationModal', settings, function(error, out) {
                _this.elems.$component.html(out);

                _this.elems.$expirationWarning = _this.elems.$component.find(DEFAULTS.SELECTORS.EXPIRATION_WARNING);
                _this.elems.$expirationMessage = _this.elems.$component.find(DEFAULTS.SELECTORS.EXPIRATION_MESSAGE);

                app.createSubModule(_this.elems.$component, _this);
            });

            return this;
        }
    });

    app.SessionExpirationModal = SessionExpirationModal;

    return app.SessionExpirationModal;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust);
;(function(window, document, $, dust, Modernizr) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SELECTORS: {
            MODAL_ID: '#video-modal',
            PLAY_BUTTON: '[href="#video-modal"]',

            PLAYER: '.video-modal__player',

            REPLAY_BUTTON: '.video-modal__button_replay',
            AFTERPLAY_SCREEN: '.video-modal__overlay',

            DESCRIPTION: '.video-modal__descr',
            SHOW_MORE_LINK: '.video-modal__more-link'
        },
        CLASSES: {
            ACTIVE_DESCRIPTION: 'video-modal__descr_active',
            VIDEO_MODAL_OVERLAY_ONE_BTN: 'video-modal__overlay_one_btn'
        },
        MODAL_MAIN_CLASS: 'default-modal video-modal',
        MAX_DESCRIPTION_SIZE: 170
    };
    /*
     * Constructor
     */
    var Video = function Video($element) {
        var _this = this instanceof Video ? this : Object.create(Video.prototype);

        _this.elems = {
            $component: $element,
            $playButton: $(DEFAULTS.SELECTORS.PLAY_BUTTON),
            $description: $(''),
            $afterplayScreen: $(''),
            $player: $(''),
            $window: $(window)
        };

        _this.data = null;
        _this.bindEventInterval = '';

        _this.initialize();

        return _this;
    };

    $.extend(Video.prototype, {

        initialize: function initialize() {
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$playButton.on('click', $.proxy(_this._prepareData, _this));

            _this.elems.$component.on('click', DEFAULTS.SELECTORS.SHOW_MORE_LINK, $.proxy(_this._showMoreDescription, _this));

            _this.elems.$component.on('click', DEFAULTS.SELECTORS.REPLAY_BUTTON, $.proxy(_this._play, _this));
        },

        // FIXME:
        _bindPlayerEvents: function _bindPlayerEvents() {
            var _this = this;

            switch (_this.data.videoUrlType) {
                case 'youtubePlayer':

                    var $videoFrame = _this.elems.$player.get(0).contentWindow;

                    _this.bindEventInterval = setInterval(function() {
                        $videoFrame.postMessage('{"event":"listening","id":"apiID"}', '*');
                    }, 1000);

                    _this.elems.$window.on('message.youtube-message', function(event) {
                        var eventOrig = event.originalEvent;

                        if (eventOrig.source === $videoFrame) {
                            var json = JSON.parse(eventOrig.data);

                            if (_this.bindEventInterval) {
                                _this.bindEventInterval = clearInterval(_this.bindEventInterval);
                            }

                            // PlayerState: 0-ended, 1-playing, 2-paused, 3-buffering
                            if (typeof (json.info.playerState) !== 'undefined') {
                                _this._toggleAfterplayScreen(json.info.playerState === 0);
                            }
                        }
                    });

                    break;

                case 'quicktimePlayer':
                    _this.elems.$player.on('qt_ended', $.proxy(_this._toggleAfterplayScreen, _this, true));

                    break;

                default:
                    _this.elems.$player.on('play', $.proxy(_this._toggleAfterplayScreen, _this, false));
                    _this.elems.$player.on('seeking', $.proxy(_this._toggleAfterplayScreen, _this, false));
                    _this.elems.$player.on('ended', $.proxy(_this._toggleAfterplayScreen, _this, true));

                    break;
            }

        },

        _unbindPlayerEvents: function _bindPlayerEvents() {
            var _this = this;

            if (_this.data.videoUrlType === 'youtubePlayer') {
                if (_this.bindEventInterval) {
                    _this.bindEventInterval = clearInterval(_this.bindEventInterval);
                }

                _this.elems.$window.off('.youtube-message');
            }
        },

        _prepareData: function _prepareData(e) {
            e.preventDefault();

            var _this = this;
            var $playButton = $(e.currentTarget);

            _this.data = $playButton.data('video-info');
            _this.data.maxDescriptionSize = DEFAULTS.MAX_DESCRIPTION_SIZE;

            // In case of video tag is not supported (IE8), application will use flash video player
            // TODO: rename videoUrlType to playerType
            if (!Modernizr.video && _this.data.videoUrlType === 'html5Player') {
                _this.data.videoUrlType = 'flashPlayer';
            }

            _this.openModal();
        },

        _showMoreDescription: function _showMoreDescription() {
            this.elems.$description.addClass(DEFAULTS.CLASSES.ACTIVE_DESCRIPTION);
        },

        _toggleAfterplayScreen: function _toggleAfterplayScreen(show) {
            this.elems.$afterplayScreen.toggle(show);

            // NOTE: detect single button, related to CTCOFECM-27353
            if (this.elems.$afterplayScreen.children().length === 1) {
                this.elems.$afterplayScreen.addClass(DEFAULTS.CLASSES.VIDEO_MODAL_OVERLAY_ONE_BTN);
            }
        },

        openModal: function openModal() {
            var _this = this;

            $.SpcMagnificPopup.open({
                mainClass: DEFAULTS.MODAL_MAIN_CLASS,
                items: {
                    src: DEFAULTS.SELECTORS.MODAL_ID
                },
                callbacks: {
                    open: function() {
                        _this.render();
                    },
                    close: function() {
                        _this.elems.$component.empty();
                        _this._unbindPlayerEvents();
                    }
                }
            });
        },

        _play: function _play() {
            var _this = this;

            _this._toggleAfterplayScreen(false);

            switch (_this.data.videoUrlType) {
                case 'youtubePlayer':
                    _this.elems.$player.get(0).contentWindow.postMessage('{"event":"command","id":"apiID","func":"playVideo"}', '*');

                    break;

                case 'quicktimePlayer':
                    _this.elems.$player.get(0).Play();

                    break;

                default:
                    _this.elems.$player.get(0).play();

                    break;
            }
        },

        _extendWithUserData: function _extendWithUserData() {
            var _this = this;

            _this.data.userIsLoggedIn = app.modules.User.isLoggedIn();
        },

        render: function render() {
            var _this = this;

            _this._extendWithUserData();

            dust.render('videoModal', _this.data, function(error, out) {
                _this.elems.$component.html(out);

                _this.elems.$description = _this.elems.$component.find(DEFAULTS.SELECTORS.DESCRIPTION);
                _this.elems.$afterplayScreen = _this.elems.$component.find(DEFAULTS.SELECTORS.AFTERPLAY_SCREEN);
                _this.elems.$player = _this.elems.$component.find(DEFAULTS.SELECTORS.PLAYER);

                _this._bindPlayerEvents();
            });
        }
    });

    app.Video = Video;

    return app.Video;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.dust, window.Modernizr);

;(function(window, document, $) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {

        SELECTORS: {
            MODAL_ID: '#promo-description-modal',
            CONTENT_WRAPPER: '.modal__main-content'
        },
        CLASSES: {
            RED_DOTS: 'red-dotted-list'
        }
    };
    /*
     * Constructor
     */
    var PromoDescription = function PromoDescription($element) {
        var _this = this instanceof PromoDescription ? this : Object.create(PromoDescription.prototype);

        _this.elems = {
            $component: $element,
            $contentWrapper: $element.find(DEFAULTS.SELECTORS.CONTENT_WRAPPER)
        };

        return _this;
    };

    $.extend(PromoDescription.prototype, {

        openModal: function openModal(promoDescription) {
            var _this = this;

            $.SpcMagnificPopup.open({
                items: {
                    src: DEFAULTS.SELECTORS.MODAL_ID
                },
                callbacks: {
                    open: function() {
                        _this.elems.$contentWrapper.html(promoDescription);
                        _this.elems.$contentWrapper.find('ul, ol').addClass(DEFAULTS.CLASSES.RED_DOTS);
                    }
                }
            });

            return _this;
        },

        close: function _close() {
            $.SpcMagnificPopup.close();

            return this;
        }
    });

    app.PromoDescription = PromoDescription;

    return app.PromoDescription;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, CQ) {
    var app = this;

    /*
     * Constructor
     */
    var SignInPrompt = function SignInPrompt() {
        var _this = this instanceof SignInPrompt ? this : Object.create(SignInPrompt.prototype);

        _this.initialize();

        return _this;
    };

    $.extend(SignInPrompt.prototype, {
        initialize: function initialize() {
            if (app.modules.User.isLoggedIn()) {
                $.bbq.removeState('showSignInModal');
            } else {
                this._checkModulesReadyState();
            }

            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(_this._checkModulesReadyState, _this));
        },

        _showSignInModal: function _showSignInModal() {
            app.modules.AuthModal[0].open({
                step: 'signin',
                title: CQ.I18n.get('GLB0088'),
                onClose: function() {
                    if (app.modules.User.isLoggedIn()) {
                        $.bbq.removeState('showSignInModal');
                    } else {
                        app.modules.HeaderLogo[0].goToHome();
                    }
                }
            });
        },

        _checkModulesReadyState: function _checkModulesReadyState() {
            var attempts = 0;
            var MAX_ATTEMPTS = 50;
            var waitForAuthModal = null;
            var _this = this;

            waitForAuthModal = setInterval(function() {
                if (app.modules.AuthModal || attempts === MAX_ATTEMPTS) {
                    clearInterval(waitForAuthModal);

                    if (!app.modules.User.isLoggedIn()) {
                        _this._showSignInModal();
                    } else {
                        $.bbq.removeState('showSignInModal');
                    }

                } else {
                    attempts++;
                }
            }, 100);
        }
    });

    app.SignInPrompt = SignInPrompt;

    return app.SignInPrompt;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);

;(function(window, $, _, dust, CQ) {
    var app = this;

    var DEFAULTS = {
        MAIN_CLASS: 'default-modal anti-spam-legislation',
        SELECTORS: {
            MODAL_ID: '#anti-spam-legislation',
            FORM_ID: '#anti-spam-legislation__form',
            CHECKBOX_ID: '#anti-spam-legislation-checkbox',
            EMAIL_NAME: 'input[name="email"]',
            POSTAL_CODE_NAME: 'input[name="postalCode"]',
            PHONE_NAME: 'input[name="phoneNumber"]',
            MODAL_TITLE: '.modal__title',
            MODAL_SUBTITLE: '.modal__subtitle',
            MODAL_CONFIRMATION_TEXT: '.confirmation-text'
        },
        CLASSES: {
            VALIDATION_ERROR: 'validation-error',
            VALIDATION_ERROR_SHOW: 'validation-error_show'
        },
        SERVICES_URL: {
            SUBSCRIPTION: '/services/sportchek/customer/subscription/subscribe',
            GET_SUBSCRIPTION_PREFERENCES: '/services/sportchek/customer/subscription/get'
        },
        MASK: {
            PHONE: '999-999-9999',
            POSTAL_CODE: 'a9a 9a9'
        }
    };

    var JoinOurCommunityAntiSpam = function JoinOurCommunityAntiSpam($element) {
        var _this = this instanceof JoinOurCommunityAntiSpam ? this : Object.create(JoinOurCommunityAntiSpam.prototype);

        _this.elems = {
            $component: $element,
            $form: $(DEFAULTS.SELECTORS.FORM_ID),
            $agreeCheckbox: $element.find(DEFAULTS.SELECTORS.CHECKBOX_ID),
            $emailField: $element.find(DEFAULTS.SELECTORS.EMAIL_NAME)
        };

        _this.emailPreferencesURL = _this.elems.$component.data('email-preferences-url');
        _this.formContentURL = _this.elems.$component.data('join-our-community-url');

        _this.initialize();

        return _this;
    };

    $.extend(JoinOurCommunityAntiSpam.prototype, {
        initialize: function initialize() {
            // TODO: remove when placeholder polyfill will be ready
            this.isOldIe = $(document.documentElement).hasClass('lt-ie9');

            // TODO: remove when placeholder polyfill will be ready
            if (this.isOldIe) {
                this._showLabels();
            }

            this._updateUserData();
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            app.subscribe(app.EVENTS.LOG_IN, $.proxy(this._updateUserData, this));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this._updateUserData, this));

            this.elems.$component.on('change', DEFAULTS.SELECTORS.POSTAL_CODE_NAME, function() {
                $(this).trigger('paste.mask');
            });
        },

        openModal: function openModal(email, closeCallback) {
            var _this = this;

            $.SpcMagnificPopup.open({
                mainClass: DEFAULTS.MAIN_CLASS,
                items: {
                    src: DEFAULTS.SELECTORS.MODAL_ID
                },
                callbacks: {
                    open: function() {
                        var formData = {
                            email: email
                        };

                        _this.elems.$form[0].reset();

                        _this.getFormContent();

                        if (app.modules.User.isLoggedIn && email === _this.userData.uid) {
                            $.extend(formData, {
                                firstName: _this.userData.firstName,
                                lastName: _this.userData.lastName,
                                postalCode: _this.userData.postalCode
                            });

                            _this.getSubscriptionPreferences()
                                .done(function(data) {
                                    $.extend(formData, {
                                        email: data.email,
                                        postalCode: data.postalCode,
                                        phoneNumber: data.phoneNumber
                                    });
                                })
                                .always(function() {
                                    _this._populateForm(formData);
                                });
                        } else {
                            _this._populateForm(formData);
                        }

                        _this.elems.$agreeCheckbox.prop('checked', false);
                        _this._bindValidate();
                    },
                    close: function() {
                        if (closeCallback) {
                            closeCallback();
                        }
                    }
                }
            });

            return _this;
        },

        _bindValidate: function _bindValidate() {
            var _this = this;

            _this.elems.$form
                .find(DEFAULTS.SELECTORS.POSTAL_CODE_NAME)
                .mask(DEFAULTS.MASK.POSTAL_CODE, {
                    completed: function() {
                        var value = this.val();
                        this.val(value.toUpperCase());
                    }
                });

            _this.elems.$form
                .find(DEFAULTS.SELECTORS.PHONE_NAME)
                .mask(DEFAULTS.MASK.PHONE, {
                    autoclear: false
                });

            _this.elems.$form.validate({
                errorClass: DEFAULTS.CLASSES.VALIDATION_ERROR,
                onfocusout: function(element) {
                    setTimeout(function() {
                        $(element).valid(); // Need to recheck after removed mask placeholder
                    }, 0);
                },
                errorElement: 'span',
                rules: {
                    email: {
                        required: true,
                        spcEmail: true
                    },
                    confirmEmail: {
                        equalToIgnoreCase: DEFAULTS.SELECTORS.EMAIL_NAME
                    },
                    postalCode: {
                        required: true,
                        spcPostalCode: true
                    },
                    firstName: {
                        // TODO: add length validation for firstName everywhere on site
                        maxlength: 50,
                        spcName: true
                    },
                    lastName: {
                        // TODO: add length validation for lastName everywhere on site
                        maxlength: 50,
                        spcName: true
                    },
                    phoneNumber: {
                        spcPhone: true
                    }
                },
                messages: {
                    firstName: {
                        maxlength: CQ.I18n.get('error.customers.validation.fglAddressData.firstName.Size', 50),
                        spcName: CQ.I18n.get('ACC0089')
                    },
                    lastName: {
                        maxlength: CQ.I18n.get('error.customers.validation.fglAddressData.lastName.Size', 50),
                        spcName: CQ.I18n.get('ACC0089')
                    },
                    email: {
                        required: CQ.I18n.get('error.customers.validation.registerData.login.NotBlank'),
                        spcEmail: CQ.I18n.get('error.customers.validation.registerData.login.Pattern')
                    },

                    confirmEmail: {
                        equalToIgnoreCase: CQ.I18n.get('error.customers.validation.registerData.login.confirm')
                    },
                    postalCode: {
                        required: CQ.I18n.get('error.joinOurCommunity.postalCode.NotBlank'),
                        spcPostalCode: CQ.I18n.get('error.joinOurCommunity.postalCode.Pattern')
                    },
                    phoneNumber: {
                        spcPhone: CQ.I18n.get('ACC0093')
                    }
                },
                errorPlacement: function(error, input) {
                    $(input).after($(error).addClass(DEFAULTS.CLASSES.VALIDATION_ERROR_SHOW));
                },
                submitHandler: function() {
                    _this._postData();
                }
            });
        },

        getFormContent: function getFormContent() {
            var _this = this;

            $.ajax({
                url: _this.formContentURL,
                type: 'GET',
                dataType: 'json',

                success: function(data) {
                    var confirmationTextHTML = $('<div/>').html(data.confirmationText).text();

                    _this.elems.$form.find(DEFAULTS.SELECTORS.MODAL_TITLE).html(data.title);
                    _this.elems.$form.find(DEFAULTS.SELECTORS.MODAL_SUBTITLE).html(data.subtitle);
                    _this.elems.$form.find(DEFAULTS.SELECTORS.MODAL_CONFIRMATION_TEXT).html(confirmationTextHTML);
                },

                error: function(jqXhr, textStatus, errorThrown) {
                    console.error('"JoinOurCommunityAntiSpam.getFormContent" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                }
            });
        },

        getSubscriptionPreferences: function getSubscriptionPreferences() {
            var _this = this;

            return $.ajax({
                url: DEFAULTS.SERVICES_URL.GET_SUBSCRIPTION_PREFERENCES + '?email=' + _this.userData.uid,
                type: 'GET',
                cache: false,
                beforeSend: function() {
                    _this.elems.$form.spinner('show');
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 403:
                            app.modules.User.logOut();

                            break;

                        default:
                            console.error('"JoinOurCommunityAntiSpam.getSubscriptionPreferences" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                },
                complete: function() {
                    _this.elems.$form.spinner('hide');
                }
            });
        },

        _populateForm: function _populateForm(formData) {
            for (var key in formData) {
                if (formData.hasOwnProperty(key)) {
                    this.elems.$form.find('[name=' + key + ']').val(formData[key]);
                }
            }
        },

        _postData: function _postData() {
            var _this = this;

            var formObject = _this.elems.$form.toObject();

            formObject.email = formObject.email.toLowerCase();
            delete formObject.confirmEmail;

            if (formObject.phoneNumber) {
                formObject.phoneNumbers = [{
                        number: formObject.phoneNumber,
                        type: 'MOBILE',
                        primary: true
                    }];
                delete formObject.phoneNumber;
            }

            $.SpcMagnificPopup.close();

            $.ajax({
                url: DEFAULTS.SERVICES_URL.SUBSCRIPTION,
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(formObject),
                success: function() {
                    app.trigger(app.EVENTS.ANALYTICS.SUBSCRIPTION_COMPLETE);

                    app.modules.JoinOurCommunity[0].toggleBlocks('THANKS');

                    app.modules.Alert.openModal({
                        title: CQ.I18n.get('GLB0133'),
                        description: CQ.I18n.get('GLB0134'),
                        buttonText: CQ.I18n.get('GLB0135')
                    });
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 424:
                            app.modules.JoinOurCommunity[0].toggleBlocks('SUBSCRIBED');

                            app.modules.Confirm.openModal({
                                title: CQ.I18n.get('GLB0120'),
                                description: CQ.I18n.get('GLB0086'),
                                buttonText: CQ.I18n.get('HOM0009'),
                                cancelText: CQ.I18n.get('GLB0166'),
                                cancelTextLink: _this.emailPreferencesURL + '#email=' + formObject.email
                            });

                            break;

                        default:
                            console.error('"JoinOurCommunityAntiSpam._postData" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                }
            });
        },

        _updateUserData: function updateUserData() {
            this.userData = app.modules.User.get();
        },

        // TODO: remove when placeholder polyfill will be ready
        _showLabels: _.once(function _showLabels() {
            $(DEFAULTS.SELECTORS.MODAL_ID).find('input[type=text]').each(function() {
                var $element = $(this);
                var message =  $element.attr('placeholder');

                if ($element.attr('placeholder')) {
                    if (message[0] === '*') {
                        $('<label class="modal__label"><span class="modal__label-imp">*</span>' + $element.attr('placeholder').slice(1) + '</label>').insertBefore($element);
                    } else {
                        $('<label class="modal__label">' + $element.attr('placeholder') + '</label>').insertBefore($element);
                    }
                }
            });
        })
    });

    JoinOurCommunityAntiSpam.DEFAULTS = DEFAULTS;
    app.JoinOurCommunityAntiSpam = JoinOurCommunityAntiSpam;

}).call(window.SPC = window.SPC || {}, window, window.jQuery, window._, window.dust, window.CQ);
;(function(window, $, _, dust, CQ) {
    var app = this;

    var DEFAULTS = {};
    $.extend(DEFAULTS, app.JoinOurCommunityAntiSpam.DEFAULTS, {
        SERVICES_URL: {
            RESUBSCRIBE: '/services/sportchek/customer/subscription/resubscribe'
        }
    });

    var ResubscribeJoinOurCommunityAntiSpam = function ResubscribeJoinOurCommunityAntiSpam($element) {
        var _this = this instanceof ResubscribeJoinOurCommunityAntiSpam ? this : Object.create(ResubscribeJoinOurCommunityAntiSpam.prototype);

        _this.elems = {
            $component: $element,
            $form: $(DEFAULTS.SELECTORS.FORM_ID),
            $cancelButton: $element.find(DEFAULTS.SELECTORS.CANCEL_CLASS),
            $agreeCheckbox: $element.find(DEFAULTS.SELECTORS.CHECKBOX_ID),
            $emailField: $element.find(DEFAULTS.SELECTORS.EMAIL_NAME)
        };

        _this.initialize();

        return _this;
    };

    $.extend(ResubscribeJoinOurCommunityAntiSpam.prototype, app.JoinOurCommunityAntiSpam.prototype, {
        _postData: function _postData() {
            var _this = this;

            /**
             * @returns {String}
             * @private
             */
            function _getFormData() {
                var formObject = _this.elems.$form.toObject();

                formObject.email = formObject.email.toLowerCase();
                delete formObject.confirmEmail;

                if (formObject.phoneNumber) {
                    formObject.phoneNumbers = [{
                        number: formObject.phoneNumber,
                        type: 'MOBILE',
                        primary: true
                    }];
                    delete formObject.phoneNumber;
                }

                return JSON.stringify(formObject);
            }

            $.SpcMagnificPopup.close();

            $.ajax({
                url: DEFAULTS.SERVICES_URL.RESUBSCRIBE,
                type: 'POST',
                contentType: 'application/json',
                data: _getFormData(),
                success: function() {
                    app.modules.JoinOurCommunity[0].toggleBlocks('SUBSCRIBED');
                    app.modules.Alert.openModal({
                        title: CQ.I18n.get('GLB0112')
                    });
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 424:
                            app.modules.Alert.openModal({
                                title: CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message)
                            });

                            break;

                        default:
                            console.error('"JoinOurCommunity._postData" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                }
            });
        }
    });

    app.ResubscribeJoinOurCommunityAntiSpam = ResubscribeJoinOurCommunityAntiSpam;

}).call(window.SPC = window.SPC || {}, window, window.jQuery, window._, window.dust, window.CQ);
;(function(window, document, $, CQ) {
    var app = this;

    var DEFAULTS = {
        SERVICES_URLS: {
            RESEND: '/services/sportchek/customers/email/resend'
        },
        SELECTORS: {
            CANCEL: '.resend-activation-link-modal__cancel'
        }
    };

    var ResendActivationLink = function ResendActivationLink($element) {
        var _this = this instanceof ResendActivationLink ? this : Object.create(ResendActivationLink.prototype);

        _this.elems = {
            $component: $element,
            $cancel: $element.find(DEFAULTS.SELECTORS.CANCEL)
        };

        _this.bindEvents();

        return _this;
    };

    $.extend(ResendActivationLink.prototype, {
        bindEvents: function bindEvents() {
            this.elems.$component.on('click', ':submit', $.proxy(this._resendLink, this));
            this.elems.$cancel.on('click', this._close);
        },

        _resendLink: function _resendLink(e) {
            e.preventDefault();

            var _this = this;
            var data = {
                email: _this._getUserEmail()
            };

            $.ajax({
                url: DEFAULTS.SERVICES_URLS.RESEND,
                type: 'POST',
                contentType: 'application/json',
                dataType: 'JSON',
                data: JSON.stringify(data),
                beforeSend: function() {
                    app.modules.MainContentSpinner[0].spinner('show');
                },
                success: function() {
                    app.modules.AuthModal[0].open({
                        step: 'resend-activation-link-confirmation'
                    });
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    if (jqXhr.status === 424) {
                        var message = CQ.I18n.get(JSON.parse(jqXhr.responseText).messages[0].message);

                        app.modules.Alert.openModal({
                            title: message
                        });
                    } else {
                        console.error('"ResendActivationLink._resendLink" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                },
                complete: function() {
                    app.modules.MainContentSpinner[0].spinner('hide');
                }
            });
        },

        _getUserEmail: function _getUserEmail() {
            return app.modules.User.email || $.bbq.getState().email;
        },

        _close: function _close() {
            $.SpcMagnificPopup.close();

            return false;
        }
    });

    app.ResendActivationLink = ResendActivationLink;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ);

;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            MODAL_ID: '#resend-activation-link-expired-modal'
        },
        CLASSES: {
            MAIN_CLASS: 'default-modal resend-activation-link-expired-modal'
        }
    };

    var ResendActivationLinkExpired = function ResendActivationLinkExpired($element) {
        var _this = this instanceof ResendActivationLinkExpired ? this : Object.create(ResendActivationLinkExpired.prototype);

        _this.elems = {
            $component: $element
        };

        return _this;
    };

    $.extend(ResendActivationLinkExpired.prototype, {
        openModal: function() {
            $.SpcMagnificPopup.open({
                mainClass: DEFAULTS.CLASSES.MAIN_CLASS,
                items: {
                    src: DEFAULTS.SELECTORS.MODAL_ID
                }
            });
        }
    });

    app.ResendActivationLinkExpired = ResendActivationLinkExpired;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            MODAL_ID: '#safety-and-warranty-modal-content',
            MAIN_CONTENT: '.modal__main-content',
            CONFIRMATION_BUTTON: '.safety-and-warranty-panel__confirmation',
            CANCELLATION_BUTTON: '.safety-and-warranty-panel__cancellation'
        },
        MODAL_MAIN_CLASS: 'default-modal information-modal'
    };

    var SafetyAndWarranty = function SafetyAndWarranty($element, parentModule) {
        var _this = this instanceof SafetyAndWarranty ? this : Object.create(SafetyAndWarranty.prototype);

        _this.elems = {
            $component: $element,
            $modal: $(DEFAULTS.SELECTORS.MODAL_ID)
        };

        _this.data = {
            pageUrl: _this.elems.$component.data('page-url')
        };

        _this.parentPreventClick = parentModule.preventChildModuleClick;

        _this.confirmationCallback = $.noop;

        _this.bindEvents();

        return _this;
    };

    $.extend(SafetyAndWarranty.prototype, {
        bindEvents: function bindEvents() {
            var _this = this;

            if (!_this.parentPreventClick) {
                _this.elems.$component.on('click', $.proxy(_this.open, _this));
            }
        },

        /**
         * @param {Object} params.
         * If params is "function" that passed from parent module then invoking it,
         * otherwise if it's "event" object then prevent default action (usually it's link).
         */
        open: function open(params) {
            var _this = this;

            if (typeof params === 'function') {
                _this.confirmationCallback = params;
            } else {
                params.preventDefault();
            }

            $.SpcMagnificPopup.open({
                mainClass: DEFAULTS.MODAL_MAIN_CLASS,
                items: {
                    src: DEFAULTS.SELECTORS.MODAL_ID
                },
                callbacks: {
                    open: function() {
                        _this._getInfo();
                    }
                }
            });
        },

        _getInfo: function _getInfo() {
            var _this = this;

            $.ajax({
                url: _this.data.pageUrl,
                type: 'GET',
                success: function(data) {
                    _this._render(data);
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    console.error('"SafetyAndWarranty._getInfo" >> ' + jqXhr.status + ' (' + errorThrown + ')');

                    $.SpcMagnificPopup.close();

                    app.modules.Alert.openModal({
                        title: '"SafetyAndWarranty._getInfo" >> ' + jqXhr.status + ' (' + errorThrown + ')'
                    });
                }
            });
        },

        _handleConfirmation: function _handleConfirmation() {
            this.confirmationCallback();

            $.SpcMagnificPopup.close();
        },

        _handleCancellation: function _handleCancellation(e) {
            e.preventDefault();

            $.SpcMagnificPopup.close();
        },

        _render: function _render(data) {
            var _this = this;

            _this.elems.$modal
                .find(DEFAULTS.SELECTORS.MAIN_CONTENT)
                    .remove()
                .end()
                    .prepend(data);

            _this.elems.$modal
                .find(DEFAULTS.SELECTORS.CONFIRMATION_BUTTON)
                    .on('click', $.proxy(_this._handleConfirmation, _this));

            _this.elems.$modal
               .find(DEFAULTS.SELECTORS.CANCELLATION_BUTTON)
                    .on('click', $.proxy(_this._handleCancellation, _this));
        }
    });

    app.SafetyAndWarranty = SafetyAndWarranty;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            CONTAINER_CLASS: '.description-block',
            MODAL_LINK: 'a[href="#showJoinOurCommunityModal=true"]'
        }
    };

    /*
     * Constructor
     */
    var ShowJoinOurCommunityModal = function ShowJoinOurCommunityModal() {
        var _this = this instanceof ShowJoinOurCommunityModal ? this : Object.create(ShowJoinOurCommunityModal.prototype);

        _this.elems = {
            $modalLink: $(DEFAULTS.SELECTORS.CONTAINER_CLASS).find(DEFAULTS.SELECTORS.MODAL_LINK)
        };

        _this.initialize();
        _this.bindEvents();

        return _this;
    };

    $.extend(ShowJoinOurCommunityModal.prototype, {
        initialize: function initialize() {
            this._onHashChange();
        },

        bindEvents: function bindEvents() {
            this.elems.$modalLink.on('click', $.proxy(this._saveHashState, this));

            $(window).on('hashchange', $.proxy(this._onHashChange, this));
        },

        _saveHashState: function __saveHashState(e) {
            e.preventDefault();

            var href = $.param.fragment(e.target.href);

            $.bbq.pushState(href);
        },

        _onHashChange: function _onHashChange() {

            var showJoinOurCommunityModal = $.bbq.getState().showJoinOurCommunityModal;
            var showJoinOurCommunityModalWEmail = $.bbq.getState().showJoinOurCommunityModalWEmail;

            if (showJoinOurCommunityModalWEmail !== undefined) {
                $.bbq.removeState('showJoinOurCommunityModalWEmail');
                this._showModal(showJoinOurCommunityModalWEmail);

                return;
            }

            if (showJoinOurCommunityModal === 'true') {
                $.bbq.removeState('showJoinOurCommunityModal');

                this._showModal();
            }
        },

        _showModal: function _showModal(email) {
            var attempts = 0;
            var MAX_ATTEMPTS = 5;
            var waitModal = null;

            email = email || '';

            waitModal = setInterval(function() {
                if (app.modules.JoinOurCommunityAntiSpam || attempts === MAX_ATTEMPTS) {
                    clearInterval(waitModal);
                    app.modules.JoinOurCommunityAntiSpam[0].openModal(email);
                } else {
                    attempts++;
                }
            }, 100);
        }
    });

    app.ShowJoinOurCommunityModal = ShowJoinOurCommunityModal;

    return app.ShowJoinOurCommunityModal;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, _, CQ, undefined) {
    var app = this;

    /*
     * Default Variables
     */
    var DEFAULTS = {
        SERVICES_URLS: {
            SUBSCRIBE: '/services/sportchek/subscriptions/add'
        },

        BUTTON_SUBSCRIBED: 'button-subscribe_active',

        CLASSES: {
            HOME_GRID: ['.static-grid__item_size_small-square', '.static-grid__item_size_small-rectangle']
        }
    };

    /*
     * Constructor
     */
    var ActivitySubscribe = function ActivitySubscribe($element) {
        var _this = this instanceof ActivitySubscribe ? this : Object.create(ActivitySubscribe.prototype);

        _this.elems = {
            $component: $element
        };

        _this.activityText = _this.elems.$component.data('activity-text');

        _this.initialize();
        _this.bindEvents();

        return _this;
    };

    $.extend(ActivitySubscribe.prototype, {

        initialize: function initialize() {
            this.userData = app.modules.User.get();
            this.path = this.elems.$component.data('subscriptionPath');
            this.attributeCode = this.elems.$component.data('attrCode');
            this.attributeGroupingCode = this.elems.$component.data('attrGroupingCode');
            this.resolveButtonState();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', $.proxy(this.subscribe, this));
            app.subscribe(app.EVENTS.LOG_OUT, $.proxy(this._changeButtonState, this, true));
            app.subscribe(app.EVENTS.LOG_IN, $.proxy(this.resolveButtonState, this));
        },

        subscribe: function subscribe(e) {
            e.preventDefault();

            var _this = this;

            _this.proxiedDoSubscribe = $.proxy(_this._doSubscribe, _this);

            if (_this.elems.$component.hasClass(DEFAULTS.BUTTON_SUBSCRIBED)) {
                _this._doUnsubscribe();
            } else {
                if (!app.modules.User.isLoggedIn()) {

                    app.modules.AuthModal[0].open({
                        step: 'signin',
                        title: 'GLB0083',

                        onOpen: function() {
                            app.subscribe(app.EVENTS.LOG_IN, _this.proxiedDoSubscribe);
                        },

                        onClose: function() {
                            app.unsubscribe(app.EVENTS.LOG_IN, _this.proxiedDoSubscribe);
                        }
                    });

                } else {
                    _this._doSubscribe();
                }
            }

        },

        _doSubscribe: function _doSubscribe() {

            var _this = this;
            var data = _this._createData();
            $.ajax({
                url: DEFAULTS.SERVICES_URLS.SUBSCRIBE,
                data: JSON.stringify(data),
                type: 'POST',
                contentType: 'application/json',
                success: function() {
                    _this._changeButtonState(false);
                    _this.userData.activities = data.activities;
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 403:
                            app.modules.User.logOut();

                            break;

                        default:
                            console.error('"ActivitySubscribe._doSubscribe" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                }
            });
        },

        _doUnsubscribe: function _doUnsubscribe() {
            var _this = this;
            var data = _this._createData();

            _.remove(data.activities, function(subscription) {
                return subscription.path === _this.path;
            });

            _this.userData.activities = data.activities;

            $.ajax({
                url: DEFAULTS.SERVICES_URLS.SUBSCRIBE,
                data: JSON.stringify(data),
                type: 'POST',
                contentType: 'application/json',
                success: function() {
                    _this._changeButtonState(true);
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    switch (jqXhr.status) {
                        case 403:
                            app.modules.User.logOut();

                            break;

                        default:
                            console.error('"ActivitySubscribe._doUnsubscribe" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                    }
                }
            });
        },

        resolveButtonState: function resolveButtonState() {
            var _this = this;

            if (_this.userData.activities) {
                var isEnabled = true;

                _.each(_this.userData.activities, function(subscription) {
                    if (subscription.path === _this.path) {
                        isEnabled = false;
                    }
                });

                _this._changeButtonState(isEnabled);
            }

            if (!_this._isHomeGrid()) {
                _this.elems.$component.show();
            }
        },

        _isHomeGrid: function _isHomeGrid() {
            var _this = this;
            var result = false;

            _.each(DEFAULTS.CLASSES.HOME_GRID, function(item) {
                var $homeGrid = _this.elems.$component.closest(item);

                if ($homeGrid.length) {
                    result = true;
                }
            });

            return result;
        },

        _createData: function _createData() {
            var _this = this;
            var activities = [];
            var data = {};

            if (_this.userData.activities) {
                activities = _.cloneDeep(_this.userData.activities);
            }

            var subscription = {
                path: _this.path, attributeCode: _this.attributeCode, attributeGroupingCode: _this.attributeGroupingCode
            };
            activities.push(subscription);

            data.activities = _.uniq(activities, 'path');

            return data;
        },

        _changeButtonState: function _changeButtonState(isEnabled) {

            if (isEnabled) {

                if (this.activityText !== '' && this.activityText !== undefined) {
                    this.elems.$component.text(CQ.I18n.get('GLB0156') + ' ' + this.activityText);
                } else {
                    this.elems.$component.text(CQ.I18n.get('GLB0038'));
                }

                this.elems.$component.removeClass(DEFAULTS.BUTTON_SUBSCRIBED);

            } else {

                if (this.activityText !== '' && this.activityText !== undefined) {
                    this.elems.$component.text(CQ.I18n.get('GLB0157') + ' ' + this.activityText);
                } else {
                    this.elems.$component.text(CQ.I18n.get('GLB0114'));
                }

                this.elems.$component.addClass(DEFAULTS.BUTTON_SUBSCRIBED);
            }
        }

    });

    app.ActivitySubscribe = ActivitySubscribe;

    return app.ActivitySubscribe;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.CQ);

;(function(window, document, $, Response) {
    var app = this;

    var DEFAULTS = {
        SELECTORS: {
            LOGO: '.size-chart__logo',
            MEASUREMENT_BUTTON: '.size-chart__measurement-button',
            MEASUREMENT_BLOCK: '.size-chart__measurement-block',
            MAIN_CONTENT: '.modal__main-content'
        },
        TABLET_PORTRAIT: 768,
        MEASUREMENT_OPENED_CLASS: 'size-chart__measurement_opened',
        MEASUREMENT_ANIMATION_SPEED: 150
    };

    var SizeChart = function SizeChart($element, data) {
        var _this = this instanceof SizeChart ? this : Object.create(SizeChart.prototype);

        _this.elems = {
            $component: $element,
            $measurement: $('')
        };

        _this.data = data;

        _this.initialize();

        return _this;
    };

    $.extend(SizeChart.prototype, {
        initialize: function initialize() {
            // Opened by default for desktop & tablet
            if (Response.band(0, (DEFAULTS.TABLET_PORTRAIT - 1))) {
                this.elems.$component.removeClass(DEFAULTS.MEASUREMENT_OPENED_CLASS);
            }

            this.render(this.data);

            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$component.off('.measurementToggle');
            _this.elems.$component.on('click.measurementToggle', DEFAULTS.SELECTORS.MEASUREMENT_BUTTON, $.proxy(this._measurementToggle, this));
        },

        _measurementToggle: function _measurementToggle(e) {
            e.preventDefault();

            var _this = this;

            _this.elems.$measurement.slideToggle(DEFAULTS.MEASUREMENT_ANIMATION_SPEED, function() {
                _this.elems.$component.toggleClass(DEFAULTS.MEASUREMENT_OPENED_CLASS);
            });
        },

        render: function render(data) {
            this.elems.$component
                .find(DEFAULTS.SELECTORS.MAIN_CONTENT)
                    .remove()
                .end()
                    .prepend(data.content);

            var $brandLogoImage = this.elems.$component.find(DEFAULTS.SELECTORS.LOGO);

            if (data.brandLogoPath) {
                $brandLogoImage.attr('src', data.brandLogoPath);
                $brandLogoImage.show();
            }

            this.elems.$measurement = this.elems.$component.find(DEFAULTS.SELECTORS.MEASUREMENT_BLOCK);
        }
    });

    app.SizeChart = SizeChart;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.Response);

;(function(window, document, $, _, CQ, mboxDefine, mboxUpdate) {
    var app = this;

    var prepareParams = function(firstParam, params) {
        var array = [firstParam];

        _.each(params, function(value, key) {
            var string = key + '=' + value;
            array.push(string);
        });

        return array;
    };

    var Mbox = function Mbox($element, name, params) {
        var _this = this instanceof Mbox ? this : Object.create(Mbox.prototype);

        _this.elems = {
            $component: $element
        };

        _this.id = _this.elems.$component[0].id;
        _this.name = name || _this.elems.$component.data('name');
        _this.params = params || _this.elems.$component.data('params');

        if (!_.isEmpty(_this.name) && !_.isEmpty(_this.params)) {
            _this.initialize();
        }

        return _this;
    };

    $.extend(Mbox.prototype, {
        initialize: function initialize() {
            mboxDefine(this.id, this.name);

            this.update();
        },

        update: function update() {
            var params = prepareParams(this.name, this.params);

            mboxUpdate.apply(this, params);
        }
    });

    app.Mbox = Mbox;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.CQ, window.mboxDefine, window.mboxUpdate);

;(function(window, document, $, _, dust) {

    var app = this;

    var DEFAULTS = {

        SELECTORS: {
            CONTINUE_CHECKOUT_BUTTON: '.continue-checkout',
            MODAL_PLACEHOLDER_CLASS: '.co-sidebar__action-placeholder',
            STICKY_CLASS: 'co-sidebar__action_sticky',
            DATA_PIN_CONTAINER_ATTR: 'pin-container'
        },

        PADDING: 0
    };

    var CheckoutPanel = function CheckoutPanel($element) {
        var _this = this instanceof CheckoutPanel ? this : Object.create(CheckoutPanel.prototype);

        _this.elems = {
            $component: $element,
            $continueCheckoutButton: $element.find(DEFAULTS.SELECTORS.CONTINUE_CHECKOUT_BUTTON),
            $window: $(window),
            $placeholder: $(DEFAULTS.SELECTORS.MODAL_PLACEHOLDER_CLASS),
            $container: $($element.data(DEFAULTS.SELECTORS.DATA_PIN_CONTAINER_ATTR) || window)
        };

        _this.initialize();

        return _this;
    };

    $.extend(CheckoutPanel.prototype, {
        initialize: function initialize() {
            this._initStartPosition();
            this.bindEvents();
        },

        _initStartPosition: function _initStartPosition() {
            this.startTopPosition = this.elems.$container.offset().top;
            this._updateTop(true);
        },

        bindEvents: function bindEvents() {
            var proxiedUpdateHeight = $.proxy(this._updateHeight, this, true);
            var render = $.proxy(dust.render, dust);

            dust.render = function(name, data, callback) {
                render(name, data, callback);
                proxiedUpdateHeight();
            };

            this.elems.$window.on('scroll', $.proxy(this._updateTop, this, true));
            this.elems.$window.on('resize', _.debounce(proxiedUpdateHeight, 150));
        },

        _updateHeight: function _updateHeight(scrolled) {
            this.containerHeight = this.elems.$container.height();
            this.windowHeight = this.elems.$window.height();
            this.elems.$placeholder.height(this.elems.$component.outerHeight());

            if (scrolled) {
                this._checkDistance();
            }
        },

        _updateTop: function _updateTop(scrolled) {
            this.top = this.elems.$window.scrollTop();
            this._updateHeight(scrolled);
        },

        _checkDistance: function _checkDistance() {
            var distance = this.top + this.windowHeight - this.startTopPosition + DEFAULTS.PADDING;

            this.elems.$component.toggleClass(DEFAULTS.SELECTORS.STICKY_CLASS, distance && distance < this.containerHeight);
        }
    });

    app.CheckoutPanel = CheckoutPanel;

    return app.CheckoutPanel;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.dust);
;(function(window, document, $) {
    var app = this;

    var CheckoutAsGuest = function CheckoutAsGuest($el) {
        var _this = this instanceof CheckoutAsGuest ? this : Object.create(CheckoutAsGuest.prototype);

        _this.elems = {
            $component: $el
        };

        _this.initialize();

        return _this;
    };

    $.extend(CheckoutAsGuest.prototype, {
        initialize: function initialize() {
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$component.on('click', $.proxy(_this._processToNextPage, _this));
        },

        _processToNextPage: function _processToNextPage(e) {
            e.preventDefault();

            /**
             * For Guest user call processExpressCheckout() method and change
             * shopping cart status from 'CART_CREATED' to 'CART_CHECKOUT'.
             */
            if (app.modules.ShoppingCheckoutPanel[0]) {
                app.modules.ShoppingCheckoutPanel[0].processExpressCheckout(false);
            }
        }
    });

    app.CheckoutAsGuest = CheckoutAsGuest;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $) {
    var app = this;

    /*
     * Constructor
     */
    var JoinOurCommunityModal = function JoinOurCommunityModal() {
        var _this = this instanceof JoinOurCommunityModal ? this : Object.create(JoinOurCommunityModal.prototype);

        _this.initialize();

        return _this;
    };

    $.extend(JoinOurCommunityModal.prototype, {

        initialize: function initialize() {
            var email = $.bbq.getState().subscribeEmail;

            if (email) {
                this._showModal(email);
            }
        },

        _showModal: function _showModal(email) {
            var attempts = 0;
            var MAX_ATTEMPTS = 5;
            var waitModal = null;

            waitModal = setInterval(function() {
                if (app.modules.JoinOurCommunityAntiSpam || attempts === MAX_ATTEMPTS) {
                    clearInterval(waitModal);
                    app.modules.JoinOurCommunityAntiSpam[0].openModal(email);
                } else {
                    attempts++;
                }
            }, 100);
        }
    });

    app.JoinOurCommunityModal = JoinOurCommunityModal;

    return app.JoinOurCommunityModal;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);

;(function(window, document, $, CQ, dust) {
    var app = this;

    var DEFAULTS = {
        SERVICES_URL: '',
        SELECTORS: {
            MODAL: '#share-by-email',
            CONTENT: '.modal__main-content'
        },
        VALIDATION_ERROR: 'validation-error',
        VALIDATION_ERROR_SHOW: 'validation-error_show',
        MODAL_MAIN_CLASS: 'default-modal email-wishlist-modal default-modal_wide'
    };

    var ShareByEmail = function ShareByEmail($element) {
        var _this = this instanceof ShareByEmail ? this : Object.create(ShareByEmail.prototype);

        _this.elems = {
            $component: $element,
            $modal: $(DEFAULTS.SELECTORS.MODAL),
            $form: $('')
        };

        _this.elems.$content = _this.elems.$modal.find(DEFAULTS.SELECTORS.CONTENT);

        _this.initialize();

        return _this;
    };

    $.extend(ShareByEmail.prototype, {
        initialize: function initialize() {
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', $.proxy(this.beforeOpenModal, this));
        },

        beforeOpenModal: $.noop,

        collectFormData: function collectFormData($form) {
            return $form.toObject();
        },

        _openModal: function _openModal() {
            var _this = this;

            $.SpcMagnificPopup.open({
                mainClass: DEFAULTS.MODAL_MAIN_CLASS,
                items: {
                    src: DEFAULTS.SELECTORS.MODAL
                },
                callbacks: {
                    open: function() {
                        var userData = app.modules.User.get();
                        var data = {
                            senderEmail: userData.uid,
                            firstName: userData.firstName,
                            lastName: userData.lastName
                        };

                        _this.render(data);
                    }
                }
            });
        },

        render: function render(data) {
            var _this = this;

            dust.render('ShareByEmail', data, function(error, out) {
                _this.elems.$content.html(out);

                app.createSubModule(_this.elems.$content, _this);

                _this.elems.$form = _this.elems.$content.find('form');
                _this._bindValidate(_this.elems.$form);
            });
        },

        _bindValidate: function _bindValidate($form) {
            var _this = this;

            $form.validate({
                onfocusout: function(input) {
                    if ($(input).data($.mask.dataName)) {
                        setTimeout(function() {
                            $(input).valid();
                        }, 0);
                    } else {
                        $(input).valid();
                    }
                },
                errorClass: DEFAULTS.VALIDATION_ERROR,
                errorElement: 'span',
                rules: {
                    toRecipient: {
                        required: true,
                        spcEmail: true
                    },
                    senderEmail: {
                        required: true,
                        spcEmail: true
                    },
                    firstName: {
                        required: true,
                        maxlength: 50
                    },
                    lastName: {
                        required: true,
                        maxlength: 50
                    },
                    personalMessage: {
                        maxlength: 120
                    }
                },
                messages: {
                    toRecipient: {
                        required: CQ.I18n.get('error.customers.validation.registerData.login.NotBlank'),
                        spcEmail: CQ.I18n.get('GLB0140')
                    },
                    senderEmail: {
                        required: CQ.I18n.get('error.customers.validation.registerData.login.NotBlank'),
                        spcEmail: CQ.I18n.get('error.customers.validation.registerData.login.Pattern')
                    },
                    firstName: {
                        required: CQ.I18n.get('GLB0141')
                    },
                    lastName: {
                        required: CQ.I18n.get('GLB0142')
                    }
                },
                errorPlacement: function(error, input) {
                    $(input).after($(error).addClass(DEFAULTS.VALIDATION_ERROR_SHOW));
                },
                submitHandler: function(form) {
                    _this._postData(form);
                }
            });
        },

        _postData: function _postData(form) {
            var _this = this;
            var data = _this.collectFormData($(form));

            $.ajax({
                url: DEFAULTS.SERVICES_URL,
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(data),
                beforeSend: function() {
                    _this.elems.$content.spinner('show');
                },
                success: function() {
                    $.SpcMagnificPopup.close();
                },
                error: function(jqXhr, textStatus, errorThrown) {
                    app.modules.Alert.openModal({
                        title: '"ShareByEmail._postData" >> ' + jqXhr.status + ' (' + errorThrown + ')'
                    });
                    console.error('"ShareByEmail._postData" >> ' + jqXhr.status + ' (' + errorThrown + ')');
                },
                complete: function() {
                    _this.elems.$content.spinner('hide');
                }
            });
        }
    });

    ShareByEmail.DEFAULTS = DEFAULTS;
    app.ShareByEmail = ShareByEmail;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window.CQ, window.dust);
;(function(window, document, $) {
    var app = this;

    /*
     * Constructor
     */
    var ShareViaFacebook = function ShareViaFacebook($element) {
        var _this = this instanceof ShareViaFacebook ? this : Object.create(ShareViaFacebook.prototype);

        _this.elems = {
            $component: $element
        };

        _this.initialize();

        return _this;
    };

    $.extend(ShareViaFacebook.prototype, {
        initialize: function initialize() {
            this.bindEvents();
        },

        bindEvents: function bindEvents() {
            this.elems.$component.on('click', $.proxy(this.shareData, this));
        },

        shareData: function shareData() {
            var FB = window.FB;

            if (FB && FB.ui) {
                FB.ui({
                    method: 'share1',
                    href: window.location.href
                }, function(response) {});
            } else {
                console.error('"ShareViaFacebook.shareData" >> Facebook object (FB) is undefined');
            }
        }
    });

    app.ShareViaFacebook = ShareViaFacebook;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        CLASSES: {
            PLACEHOLDER: 'placeholder',
            INPUT_PLACEHOLDER: 'placeholder_input',
            TEXTAREA_PLACEHOLDER: 'placeholder_textarea'
        }
    };

    var TextFieldPlaceholder = function TextFieldPlaceholder(el) {
        var _this = this instanceof TextFieldPlaceholder ? this : Object.create(TextFieldPlaceholder.prototype);

        _this.elems = {
            $component: $(el),
            $window: $(window)
        };

        if (!this.placeholderSupport && this.elems.$component.attr('placeholder')) {
            _this.initialize();
        }

        return _this;
    };

    $.extend(TextFieldPlaceholder.prototype, {
        initialize: function initialize() {
            this.drawPlaceholder();
            this.bindEvents();
        },

        placeholderSupport: (function placeholderSupport() {
            var input = document.createElement('input');

            return 'placeholder' in input || 'placeHolder' in input;
        })(),

        drawPlaceholder: function drawPlaceholder() {
            var className = DEFAULTS.CLASSES.PLACEHOLDER + ' ' + (this.elems.$component.is('input') ? DEFAULTS.CLASSES.INPUT_PLACEHOLDER : DEFAULTS.CLASSES.TEXTAREA_PLACEHOLDER);

            this.elems.$placeholder = $('<span class="' + className + '">' + this.elems.$component.attr('placeholder') + '</span>');

            this.elems.$placeholder.insertBefore(this.elems.$component);

            this.checkPlaceholder();

            this.redrawPlaceholder();
        },

        redrawPlaceholder: function redrawPlaceholder() {
            var styles = {
                'padding-top': this.elems.$component.css('padding-top'),
                'padding-right': this.elems.$component.css('padding-right'),
                'padding-bottom': this.elems.$component.css('padding-bottom'),
                'padding-left': this.elems.$component.css('padding-left'),
                'border-top-width': this.elems.$component.css('border-top-width'),
                'border-right-width': this.elems.$component.css('border-right-width'),
                'border-bottom-width': this.elems.$component.css('border-bottom-width'),
                'border-left-width': this.elems.$component.css('border-left-width'),
                font: this.elems.$component.css('font'),
                'border-color': 'transparent'
            };

            if (this.elems.$component.is(':visible')) {
                styles.width = this.elems.$component.width();
                styles.height = this.elems.$component.height();
            }

            this.elems.$placeholder.css(styles);
        },

        checkPlaceholder: function checkPlaceholder() {
            if (this.elems.$component.val()) {
                this.hidePlaceholder();
            } else {
                this.showPlaceholder();
            }
        },

        hidePlaceholder: function hidePlaceholder() {
            this.elems.$placeholder.hide();
        },

        showPlaceholder: function showPlaceholder() {
            this.elems.$placeholder.show();
        },

        focusInput: function focusInput() {
            this.elems.$component.focus();
        },

        bindEvents: function bindEvents() {
            var _this = this;

            _this.elems.$component.on('keyup keydown change', $.proxy(_this.checkPlaceholder, _this));
            _this.elems.$placeholder.on('click', $.proxy(_this.focusInput, _this));
            _this.elems.$window.on('resize', $.proxy(_this.redrawPlaceholder, _this));

            // Wait for mask
            setTimeout(function() {
                if (_this.elems.$component.data('rawMaskFn')) {
                    _this.elems.$component.on('focus', $.proxy(_this.hidePlaceholder, _this))
                        .on('blur', $.proxy(_this.checkPlaceholder, _this));
                }
            }, 0);
        }
    });

    app.TextFieldPlaceholder = TextFieldPlaceholder;

    return TextFieldPlaceholder;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $) {
    var app = this;

    var LazySpinner = function LazySpinner($element) {
        var _this = this instanceof LazySpinner ? this : Object.create(LazySpinner.prototype);

        _this.elems = {
            $component: $element
        };

        return _this;
    };

    $.extend(LazySpinner.prototype, {
        spinner: function spinner(action) {
            var _this = this;

            if (action === 'show') {
                _this.elems.$component.show();

                return;
            }

            if (action === 'hide') {
                _this.elems.$component.hide();
            }
        }
    });

    app.LazySpinner = LazySpinner;

    return app.LazySpinner;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $) {
    var app = this;

    var DEFAULTS = {
        SERVICES_URL: {
            TRY_COMPLETE_ORDER_PLACEMENT: '/services/sportchek/tryCompleteOrderPlacement/'
        }
    };

    var CheckLastPaymentOrderStatus = function CheckLastPaymentOrderStatus() {
        var _this = this instanceof CheckLastPaymentOrderStatus ? this : Object.create(CheckLastPaymentOrderStatus.prototype);

        _this.initialize();

        return _this;
    };

    $.extend(CheckLastPaymentOrderStatus.prototype, {
        initialize: function initialize() {
            var orderId = $.cookie(app.COOKIES.LAST_PAYMENT_ATTEMPT_ORDER_ID);
            var pageTittle = app.modules.Page.getPageData().title;
            var isPaymentOrConfirmationPage = pageTittle === 'Payment' || pageTittle === 'Confirmation' || pageTittle === 'Paypal payment';

            if (orderId && !isPaymentOrConfirmationPage) {
                this.checkLastOrderStatus(orderId);
            }
        },

        checkLastOrderStatus: function checkLastOrderStatus(orderId) {
            $.ajax({
                url: DEFAULTS.SERVICES_URL.TRY_COMPLETE_ORDER_PLACEMENT + orderId,
                type: 'PUT',
                dataType: 'JSON',
                contentType: 'application/json',
                complete: function() {
                    $.removeCookie(app.COOKIES.LAST_PAYMENT_ATTEMPT_ORDER_ID, {
                        path: '/'
                    });

                    if (app.modules.MiniCart && app.modules.MiniCart[0]) {
                        app.modules.MiniCart[0].updateCart();
                    }
                }
            });
        }
    });

    app.CheckLastPaymentOrderStatus = CheckLastPaymentOrderStatus;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery);
;(function(window, document, $, _, dust) {
    var app = this;

    var DEFAULTS = {
        YOUTUBE_PATTERN: 'youtu'
    };

    var MarketingIframe = function MarketingIframe($el) {
        var _this = this instanceof MarketingIframe ? this : Object.create(MarketingIframe.prototype);

        _this.elems = {
            $component: $el,
            $window: $(window)
        };

        _this.defaultSettings = {
            width: 800,
            height: 400
        };

        _this.settings = _this.elems.$component.data('settings');

        _this.settings.width = _this.settings.width || _this.defaultSettings.width;
        _this.settings.height = _this.settings.height || _this.defaultSettings.height;

        _this.initialize();

        return _this;
    };

    $.extend(MarketingIframe.prototype, {
        initialize: function initialize() {
            this.settings.isYoutube = this.settings.url.indexOf(DEFAULTS.YOUTUBE_PATTERN) !== -1;

            this.bindEvents();
            this.render();
        },

        bindEvents: function bindEvents() {
            this.elems.$window.on('resize', $.proxy(this.onResize, this));
        },

        render: function render() {
            var _this = this;

            if (_this.settings.url) {
                dust.render('marketingIframe', this.settings, function(error, out) {
                    _this.elems.$component.html(out);
                    _this.elems.$iframe = _this.elems.$component.find('iframe');
                    _this.onResize();
                });
            }

        },

        onResize: function onResize() {
            if (this.settings.fixedSize) {
                return;
            }

            var aspectRatio = this.settings.width / this.settings.height;
            var containerWidth = this.elems.$component.width();
            var iframeHeight = containerWidth / aspectRatio;

            this.elems.$iframe.height(iframeHeight);
        }
    });

    app.MarketingIframe = MarketingIframe;

}).call(window.SPC = window.SPC || {}, window, document, window.jQuery, window._, window.dust, window.CQ);
